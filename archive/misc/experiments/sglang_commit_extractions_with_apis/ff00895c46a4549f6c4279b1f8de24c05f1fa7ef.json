{
  "commit_hash": "ff00895c46a4549f6c4279b1f8de24c05f1fa7ef",
  "pr_url": "https://github.com/sgl-project/sglang/pull/6456",
  "pr_date": "2025-06-03",
  "timeline_text": "Copy link Contributor jianan-gu commented May 20, 2025 \u2022 edited Loading Uh oh! There was an error while loading. Please reload this page . Overview: This PR is adding the following CPU optimized sgl-kernels that are at least used in Qwen3/LLama1-4 models: - TopK fusions: \n      TopK+sigmoid\n      softmax+TopK\n- Norm fusion:\n      L2norm\n- RoPE fusions:\n      origin rope fusion (gpt_neox style and gptj style) Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions jianan-gu added 4 commits May 20, 2025 02:49 add l2norm and topksigmoid fusion 01cf742 minor fix for topk 92bbb20 add topk fusion 1df4104 add rope origin version (gptj/neox models 712f717 jianan-gu requested review from zhyncs , ispobock , HandH1998 , BBuf , yizhang2077 , merrymercy and FlamingoPg as code owners May 20, 2025 08:33 jianan-gu marked this pull request as draft May 20, 2025 08:34 jianan-gu added 3 commits May 27, 2025 02:25 add ut and format 05fc942 Merge branch 'main' into llama_qwen_cpu_opt ca9007c use torch.ops after rebase c509760 jianan-gu changed the title [Draft] Add CPU optimized kernels for topk and rope fusions Add CPU optimized kernels for topk and rope fusions May 27, 2025 add norm ut f72a727 jianan-gu marked this pull request as ready for review May 27, 2025 07:22 jianan-gu requested a review\n  from Ying1123 as a code owner May 27, 2025 07:22 mingfeima requested changes May 28, 2025 View reviewed changes Copy link Collaborator mingfeima left a comment There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment merge test_moe_topk_sigmoid.py and test_moe_topk_softmax.py with existing one: test_topk.py try to merge the rope impls with existing one, say pass a inline function as argument at the entry function or use ENUM and template specification. both methods are OK. this will greatly simplify the code structure. use at::parallel_for Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions sgl-kernel/csrc/cpu/rope.cpp Outdated Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . test/srt/cpu/test_moe_topk_softmax.py Outdated Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . test/srt/cpu/test_moe_topk_softmax.py Outdated Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . sgl-kernel/csrc/cpu/topk.cpp Outdated Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . sgl-kernel/csrc/cpu/topk.cpp Outdated Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . sgl-kernel/csrc/cpu/rope.cpp Outdated Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . sgl-kernel/csrc/cpu/rope.cpp Outdated } template <typename scalar_t> void rotary_embedding_origin_gptj_impl( Copy link Collaborator mingfeima May 28, 2025 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment can we merge this function with the existing one. say pass a lambda as an arguement. Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions Copy link Contributor Author jianan-gu Jun 2, 2025 \u2022 edited Loading Uh oh! There was an error while loading. Please reload this page . There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment Detailed check current Deepseek rope and origin rope (gptj/neox style), following key differences of usages: input 3D for Deepseek rope (num tokens, heads, head size), while origin rope is with input 2D (num tokens, heads * head size), not spilt from Q/K Deepseek rope takes q_pe/ k_pe, all embedding dim is aligned with input dim and rope dim, while origin rope could accept different dims Thus, merging functions from their implementations may not be strightforward and hard to be common for all. Here trying to refine rope to merge the dispatch ops together and leave only one rotary_embedding_cpu as common, while the underneath implementations remained different. And total 4 kinds of implementations are needed ( input 2D or 3D, is_neox or not) Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions sgl-kernel/csrc/cpu/rope.cpp Outdated Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . sgl-kernel/csrc/cpu/rope.cpp Outdated @@ -65,8 +65,230 @@ void rope_kernel_impl( } }); } template <typename scalar_t> void rotary_embedding_origin_impl( Copy link Collaborator mingfeima May 28, 2025 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment can we merge this function with the existing one. say pass a lambda as an argument. Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions mingfeima added sgl-kernel intel cpu cpu backend performance optimization labels May 28, 2025 mingfeima marked this pull request as draft May 28, 2025 04:56 jianan-gu added 5 commits May 28, 2025 10:11 refine topk fusions 8ffdc1e refine float convert 1bb2e9f use aten parallel for rope a0ce705 refine rope 8ba163e Merge branch 'main' into llama_qwen_cpu_opt c04b389 jianan-gu marked this pull request as ready for review June 2, 2025 15:36 jianan-gu requested a review\n  from mingfeima June 2, 2025 15:36 jianan-gu and others added 3 commits June 2, 2025 23:40 minor refine 7840e02 Merge branch 'main' into llama_qwen_cpu_opt 52869e0 Merge branch 'main' into llama_qwen_cpu_opt 1b676b3 zhyncs reviewed Jun 3, 2025 View reviewed changes sgl-kernel/csrc/cpu/rope.cpp Outdated Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . fix typo and ci 9e3d7dd zhyncs approved these changes Jun 3, 2025 View reviewed changes Hide details View details zhyncs merged commit ff00895 into sgl-project : main Jun 3, 2025 2 of 39 checks passed Uh oh! There was an error while loading. Please reload this page . Layssy pushed a commit\n        to Layssy/sglang-iaas\n      that referenced\n      this pull request Jun 9, 2025 Add CPU optimized kernels for topk and rope fusions ( sgl-project#6456 ) 348a895 xwu-intel pushed a commit\n        to xwu-intel/sglang\n      that referenced\n      this pull request Jun 17, 2025 Add CPU optimized kernels for topk and rope fusions ( sgl-project#6456 ) c1e5cab walker-ai pushed a commit\n        to walker-ai/sglang\n      that referenced\n      this pull request Jul 8, 2025 PullRequest: 52 sgl_20250610_sync_tag047 \u2026 a19e2e2 Merge branch 'sgl_20250610_sync_tag047 of git@code.alipay.com:Theta/SGLang.git into main https://code.alipay.com/Theta/SGLang/pull_requests/52 Reviewed-by: \u5251\u5ddd <jianchuan.gys@antgroup.com>\n\n\n* [Bugfix] Fix slice operation when chunk size mismatch ( sgl-project#6697 )\n* [Bugfix] Fix ChatCompletion endpoint of mini_lb when stream is set ( sgl-project#6703 )\n* [CI] Fix setup of disaggregation with different tp ( sgl-project#6706 )\n* [PD] Remove Unnecessary Exception Handling for FastQueue.get() ( sgl-project#6712 )\n* Fuse routed_scaling_factor in DeepSeek ( sgl-project#6710 )\n* Overlap two kernels in DeepSeek with communication ( sgl-project#6711 )\n* Minor refactor two-batch overlap ( sgl-project#6682 )\n* Speed up when having padding tokens two-batch overlap ( sgl-project#6668 )\n* [Feature] Support Flashinfer fp8 blockwise GEMM kernel on Blackwell ( sgl-project#6479 )\n* Fix LoRA bench ( sgl-project#6719 )\n* temp\n* Fix PP for Qwen3 MoE ( sgl-project#6709 )\n* [feat] triton kernel for get_last_loc ( sgl-project#6676 )\n* [fix] more mem for draft_extend cuda_graph ( sgl-project#6726 )\n* [PD] bug fix:  Update status if nixl receiver send a a dummy req. ( sgl-project#6720 )\n* Tune memory arguments on B200 ( sgl-project#6718 )\n* Add DeepSeek-R1-0528 function call chat template ( sgl-project#6725 )\n* refactor(tool call): Fix BaseFormatDetector tool_index issue and refactor `parse_streaming_increment` ( sgl-project#6715 )\n* Add draft extend CUDA graph for Triton backend ( sgl-project#6705 )\n* refactor apply_w8a8_block_fp8_linear in fp ( sgl-project#6545 )\n* [PD] Support completion endpoint ( sgl-project#6729 )\n* PD Rust LB (PO2) ( sgl-project#6437 )\n* Super tiny enable sole usage of expert distribution metrics and update doc ( sgl-project#6680 )\n* Support picking variants\u00a0of EPLB algorithms ( sgl-project#6728 )\n* Support tuning DeepEP configs ( sgl-project#6742 )\n* [test] add ut and bm for get_last_loc ( sgl-project#6746 )\n* Fix mem_fraction_static for AMD CI ( sgl-project#6748 )\n* [fix][RL] Fix DeepSeekV3ForCausalLM.post_load_weights for multiple update weight ( sgl-project#6265 )\n* Improve EPLB logical to physical dispatch map ( sgl-project#6727 )\n* Update DeepSeek-R1-0528 function call chat template ( sgl-project#6765 )\n* [PD] Optimize time out logic and add env var doc for mooncake ( sgl-project#6761 )\n* Fix aiohttp 'Chunk too big' in bench_serving ( sgl-project#6737 )\n* Support sliding window in triton backend ( sgl-project#6509 )\n* Fix shared experts fusion error ( sgl-project#6289 )\n* Fix one bug in the grouped-gemm triton kernel ( sgl-project#6772 )\n* update llama4 chat template and pythonic parser ( sgl-project#6679 )\n* feat(tool call): Enhance Llama32Detector for improved JSON parsing in non-stream ( sgl-project#6784 )\n* Support token-level quantization for EP MoE ( sgl-project#6782 )\n* Temporarily lower mmlu threshold for triton sliding window backend ( sgl-project#6785 )\n* ci: relax test_function_call_required ( sgl-project#6786 )\n* Add intel_amx backend for Radix Attention for CPU ( sgl-project#6408 )\n* Fix incorrect LoRA weight loading for fused gate_up_proj ( sgl-project#6734 )\n* fix(PD-disaggregation): Can not get local ip ( sgl-project#6792 )\n* [FIX] mmmu bench serving result display error ( sgl-project#6525 ) ( sgl-project#6791 )\n* Bump torch to 2.7.0 ( sgl-project#6788 )\n* chore: bump sgl-kernel v0.1.5 ( sgl-project#6794 )\n* Improve profiler and integrate profiler in bench_one_batch_server ( sgl-project#6787 )\n* chore: upgrade sgl-kernel v0.1.5 ( sgl-project#6795 )\n* [Minor] Always append newline after image token when parsing chat message ( sgl-project#6797 )\n* Update CI tests for Llama4 models ( sgl-project#6421 )\n* [Feat] Enable PDL automatically on Hopper architecture ( sgl-project#5981 )\n* chore: update blackwell docker ( sgl-project#6800 )\n* misc: cache is_hopper_arch ( sgl-project#6799 )\n* Remove contiguous before Flashinfer groupwise fp8 gemm ( sgl-project#6804 )\n* Correctly abort the failed grammar requests & Improve the handling of abort ( sgl-project#6803 )\n* [EP] Add cuda kernel for moe_ep_pre_reorder ( sgl-project#6699 )\n* Add draft extend CUDA graph for flashinfer backend  ( sgl-project#6805 )\n* Refactor CustomOp to avoid confusing bugs ( sgl-project#5382 )\n* Tiny log prefill time ( sgl-project#6780 )\n* Tiny fix EPLB assertion about rebalancing period and recorder window size ( sgl-project#6813 )\n* Add simple utility to dump tensors for debugging ( sgl-project#6815 )\n* Fix profiles do not have consistent names ( sgl-project#6811 )\n* Speed up rebalancing when using non-static dispatch algorithms ( sgl-project#6812 )\n* [1/2] Add Kernel support for Cutlass based Fused FP4 MoE ( sgl-project#6093 )\n* [Router] Fix k8s Service Discovery ( sgl-project#6766 )\n* Add CPU optimized kernels for topk and rope fusions  ( sgl-project#6456 )\n* fix new_page_count_next_decode ( sgl-project#6671 )\n* Fix wrong weight reference in dynamic EPLB ( sgl-project#6818 )\n* Minor add metrics to expert location updater ( sgl-project#6816 )\n* [Refactor] Rename `n_share_experts_fusion` as `num_fused_shared_experts` ( sgl-project#6735 )\n* [FEAT] Add transformers backend support  ( sgl-project#5929 )\n* [fix] recover auto-dispatch for rmsnorm and rope ( sgl-project#6745 )\n* fix ep_moe_reorder kernel bugs ( sgl-project#6858 )\n* [Refactor] Multimodal data processing for VLM ( sgl-project#6659 )\n* Decoder-only Scoring API ( sgl-project#6460 )\n* feat: add dp-rank to KV events ( sgl-project#6852 )\n* Set `num_fused_shared_experts` as `num_shared_experts` when shared_experts fusion is not disabled ( sgl-project#6736 )\n* Fix one missing arg in DeepEP ( sgl-project#6878 )\n* Support LoRA in TestOpenAIVisionServer and fix fused kv_proj loading bug. ( sgl-project#6861 )\n* support 1 shot allreduce  in 1-node and 2-node using mscclpp ( sgl-project#6277 )\n* Fix Qwen3MoE missing token padding optimization ( sgl-project#6820 )\n* Tiny update error hints ( sgl-project#6846 )\n* Support layerwise rebalancing experts ( sgl-project#6851 )\n* Tiny allow profiler API to auto create directory ( sgl-project#6865 )\n* Support Blackwell DeepEP docker images ( sgl-project#6868 )\n* [EP] Add cuda kernel for moe_ep_post_reorder ( sgl-project#6837 )\n* [theta]merge 0605\n* oai: fix openAI client error with single request via batch api ( sgl-project#6170 )\n* [PD] Fix potential perf spike caused by tracker gc and optimize doc ( sgl-project#6764 )\n* Use deepgemm instead of triton for fused_qkv_a_proj_with_mqa ( sgl-project#6890 )\n* [CUTLASS-FP4-MOE]  Introduce CutlassMoEParams class for easy initialization of Cutlass Grouped Gems Metadata ( sgl-project#6887 )\n* bugfix(OAI): Fix image_data processing for jinja chat templates ( sgl-project#6877 )\n* [CPU] enable CI for PRs, add Dockerfile and auto build task ( sgl-project#6458 )\n* AITER backend extension and workload optimizations ( sgl-project#6838 )\n* [theta]merge\n* [theta]merge\n* [Feature] Support Flashinfer fmha on Blackwell ( sgl-project#6930 )\n* Fix a bug in abort & Improve docstrings for abort ( sgl-project#6931 )\n* Tiny support customize DeepEP max dispatch tokens per rank ( sgl-project#6934 )\n* Sync the changes on cuda graph runners ( sgl-project#6932 )\n* [PD] Optimize transfer queue forward logic for dummy rank ( sgl-project#6922 )\n* [Refactor] image data process in bench_serving ( sgl-project#6879 )\n* [fix] logical_to_all_physical_map index 256 is out of bounds in EP parallel. ( sgl-project#6767 )\n* Add triton fused moe kernel config for E=257 on B200 ( sgl-project#6939 )\n* [sgl-kernel] update deepgemm ( sgl-project#6942 )\n* chore: bump sgl-kernel v0.1.6 ( sgl-project#6943 )\n* Minor compile fused topk ( sgl-project#6944 )\n* [Bugfix] pipeline parallelism and Eagle Qwen2 ( sgl-project#6910 )\n* Tiny re-introduce profile id logging ( sgl-project#6912 )\n* Add triton version as a fused_moe_triton config search key to avoid performace decrease in different Triton version ( sgl-project#5955 )\n* reduce torch.zeros overhead in moe align block size kernel ( sgl-project#6369 )\n* chore: upgrade sgl-kernel v0.1.6 ( sgl-project#6945 )\n* add fbgemm moe grouped gemm kernel benchmark ( sgl-project#6924 )\n* [Docker] Add docker file for SGL Router ( sgl-project#6915 )\n* Disabling mixed chunked prefill when eagle is enabled ( sgl-project#6874 )\n* Add canary for EPLB rebalancing ( sgl-project#6895 )\n* Refactor global_server_args_dict ( sgl-project#6866 )\n* Fuse routed scaling factor in topk_reduce kernel ( sgl-project#6220 )\n* Update server timeout time in AMD CI. ( sgl-project#6953 )\n* [misc] add is_cpu() ( sgl-project#6950 )\n* Add H20 fused MoE kernel tuning configs for DeepSeek-R1/V3 ( sgl-project#6885 )\n* Add a CUDA kernel for fusing mapping and weighted sum for MoE. ( sgl-project#6916 )\n* chore: bump sgl-kernel v0.1.6.post1 ( sgl-project#6955 )\n* chore: upgrade sgl-kernel v0.1.6.post1 ( sgl-project#6957 )\n* [DeepseekR1-FP4] Add Support for nvidia/DeepSeekR1-FP4 model ( sgl-project#6853 )\n* Revert \"Fuse routed scaling factor in topk_reduce kernel ( sgl-project#6220 )\" ( sgl-project#6968 )\n* [AMD] Add more tests to per-commit-amd ( sgl-project#6926 )\n* chore: bump sgl-kernel v0.1.7 ( sgl-project#6963 )\n* Slightly improve the sampler to skip unnecessary steps ( sgl-project#6956 )\n* rebase h20 fused_moe config ( sgl-project#6966 )\n* Fix CI and triton moe Configs ( sgl-project#6974 )\n* Remove unnecessary kernels of num_token_non_padded ( sgl-project#6965 )\n* Extend cuda graph capture bs for B200 ( sgl-project#6937 )\n* Fuse routed scaling factor in deepseek ( sgl-project#6970 )\n* Sync cuda graph runners ( sgl-project#6976 )\n* Fix draft extend ut stability with flush cache ( sgl-project#6979 )\n* Fix triton sliding window test case ( sgl-project#6981 )\n* Fix expert distribution dumping causes OOM ( sgl-project#6967 )\n* Minor remove one kernel for DeepSeek ( sgl-project#6977 )\n* [perf][sgl-kernel] extend cutlass_mla_decode to support num_head < 128 ( sgl-project#6929 )\n* Enable more unit tests for AMD CI. ( sgl-project#6983 )\n* Use torch.compile to fuse flash attention decode metadata preparation ( sgl-project#6973 )\n* Eliminate stream sync to speed up LoRA batch init  ( sgl-project#6960 )\n* support qwen3 emebedding ( sgl-project#6990 )\n* Fix torch profiler bugs for bench_offline_throughput.py ( sgl-project#6557 )\n* chore: upgrade flashinfer v0.2.6.post1 jit ( sgl-project#6958 )\n* cleanup tmp dir ( sgl-project#7007 )\n* chore: update pr test xeon ( sgl-project#7008 )\n* Fix cutlass MLA gets almost zero accuracy ( sgl-project#6998 )\n* Update amd nightly models CI. ( sgl-project#6992 )\n* feat: add direct routing strategy to DP worker ( sgl-project#6884 )\n* Fallback to lower triton version for unfound fused moe configs ( sgl-project#7013 )\n* Fix torchvision version for Blackwell ( sgl-project#7015 )\n* Simplify prepare_extend_after_decode ( sgl-project#6987 )\n* Migrate to assertEqual ( sgl-project#6741 )\n* Fix torch version in blackwell dockerfile ( sgl-project#7017 )\n* chore: update pr test xeon ( sgl-project#7018 )\n* Update default settings for blackwell ( sgl-project#7023 )\n* Support both approximate and exact expert distribution collection ( sgl-project#6964 )\n* Add decode req pool ( sgl-project#6980 )\n* [theta]merge 0610\n* [theta]merge 0610\n* [CI] Add CI workflow for sgl-router docker build ( sgl-project#7027 )\n* Fix fused_moe triton configs ( sgl-project#7029 )\n* CPU: map changes from developing branch in sgl-kernel ( sgl-project#6833 )\n* chore: bump v0.4.7 ( sgl-project#7038 )\n* Update README.md ( sgl-project#7040 ) Sign up for free to join this conversation on GitHub .\n    Already have an account? Sign in to comment",
  "timeline_extracted_at": "2025-09-11 18:57:01",
  "has_lm_eval": true,
  "has_performance": true,
  "has_serving": true,
  "has_general_test": true,
  "test_details": "LM_EVAL | PERF | SERVING | TEST",
  "analysis_extracted_at": null,
  "models": [
    "Qwen/Qwen2.5-7B-Instruct",
    "meta-llama/Llama-3.1-8B-Instruct"
  ],
  "lm_eval_commands": [
    "lm_eval --model sglang --model_args pretrained=Qwen/Qwen2.5-7B-Instruct --tasks gsm8k --batch_size 8"
  ],
  "perf_command": "python benchmarks/benchmark_serving.py --model Qwen/Qwen2.5-7B-Instruct --dataset-name random --random-input-len 256 --random-output-len 256",
  "commit_subject": "Add CPU optimized kernels for topk and rope fusions  (#6456)",
  "commit_message": "Add CPU optimized kernels for topk and rope fusions  (#6456)",
  "commit_date": "2025-06-02T17:37:34-07:00",
  "files_changed": [
    "sgl-kernel/csrc/cpu/norm.cpp",
    "sgl-kernel/csrc/cpu/rope.cpp",
    "sgl-kernel/csrc/cpu/topk.cpp",
    "sgl-kernel/csrc/cpu/torch_extension_cpu.cpp",
    "test/srt/cpu/test_norm.py",
    "test/srt/cpu/test_rope.py",
    "test/srt/cpu/test_topk.py"
  ],
  "functions_changed": [],
  "stats": {
    "commit_year": 2025,
    "num_edited_lines": 935,
    "num_files": 7,
    "num_hunks": 17,
    "num_non_test_edited_lines": 935,
    "num_non_test_files": 7,
    "num_test_files": 0,
    "only_non_test_files": 1,
    "only_test_files": 0
  },
  "diff_text": "diff --git a/sgl-kernel/csrc/cpu/norm.cpp b/sgl-kernel/csrc/cpu/norm.cpp\nindex 391a0d4e5..88faafd5b 100644\n--- a/sgl-kernel/csrc/cpu/norm.cpp\n+++ b/sgl-kernel/csrc/cpu/norm.cpp\n@@ -4,6 +4,67 @@\n namespace {\n \n // NB: avoid using `at::vec::map<>` on bfloat16 or half\n+// Llama4TextL2Norm\n+template <typename scalar_t>\n+void l2norm_kernel_impl(\n+    scalar_t* __restrict__ output,\n+    const scalar_t* __restrict__ input,\n+    int64_t batch_size,\n+    int64_t hidden_size,\n+    float eps = 1e-5) {\n+  using bVec = at::vec::Vectorized<scalar_t>;\n+  using fVec = at::vec::Vectorized<float>;\n+\n+  constexpr int kVecSize = bVec::size();\n+  at::parallel_for(0, batch_size, 0, [&](int64_t begin, int64_t end) {\n+    for (int64_t i = begin; i < end; ++i) {\n+      // local ptrs\n+      scalar_t* __restrict__ out_ptr = output + i * hidden_size;\n+      const scalar_t* __restrict__ input_ptr = input + i * hidden_size;\n+\n+      fVec sum_fvec = fVec(float(0));\n+      float sum_val = float(0);\n+\n+      int64_t d;\n+#pragma GCC unroll 4\n+      for (d = 0; d <= hidden_size - kVecSize; d += kVecSize) {\n+        bVec x_bvec = bVec::loadu(input_ptr + d);\n+        fVec x_fvec0, x_fvec1;\n+        std::tie(x_fvec0, x_fvec1) = at::vec::convert_to_float(x_bvec);\n+\n+        sum_fvec += x_fvec0 * x_fvec0;\n+        sum_fvec += x_fvec1 * x_fvec1;\n+      }\n+#pragma GCC unroll 4\n+      for (; d < hidden_size; ++d) {\n+        float x_val = static_cast<float>(input_ptr[d]);\n+        sum_val += x_val * x_val;\n+      }\n+\n+      sum_val += vec_reduce_sum(sum_fvec);\n+      float rsqrt_var = float(1) / std::sqrt(sum_val / hidden_size + eps);\n+      const fVec scale_fvec = fVec(rsqrt_var);\n+\n+#pragma GCC unroll 4\n+      for (d = 0; d <= hidden_size - kVecSize; d += kVecSize) {\n+        bVec x_bvec = bVec::loadu(input_ptr + d);\n+        fVec x_fvec0, x_fvec1;\n+        std::tie(x_fvec0, x_fvec1) = at::vec::convert_to_float(x_bvec);\n+\n+        x_fvec0 = x_fvec0 * scale_fvec;\n+        x_fvec1 = x_fvec1 * scale_fvec;\n+\n+        bVec out_bvec = convert_from_float_ext<scalar_t>(x_fvec0, x_fvec1);\n+        out_bvec.store(out_ptr + d);\n+      }\n+#pragma GCC unroll 4\n+      for (; d < hidden_size; ++d) {\n+        float x_val = static_cast<float>(input_ptr[d]);\n+        out_ptr[d] = static_cast<scalar_t>(x_val * rsqrt_var);\n+      }\n+    }\n+  });\n+}\n template <typename scalar_t>\n void rmsnorm_kernel_impl(\n     scalar_t* __restrict__ output,\n@@ -160,6 +221,22 @@ void fused_add_rmsnorm_kernel_impl(\n \n }  // anonymous namespace\n \n+// input : {batch_size, hidden_size}\n+at::Tensor l2norm_cpu(at::Tensor& input, double eps) {\n+  RECORD_FUNCTION(\"sgl-kernel::l2norm_cpu\", std::vector<c10::IValue>({input}));\n+\n+  CHECK_INPUT(input);\n+  CHECK_DIM(2, input);\n+  int64_t batch_size = input.size(0);\n+  int64_t hidden_size = input.size(1);\n+  at::Tensor output = at::empty_like(input);\n+\n+  AT_DISPATCH_REDUCED_FLOATING_TYPES(input.scalar_type(), \"l2norm_kernel\", [&] {\n+    l2norm_kernel_impl<scalar_t>(output.data_ptr<scalar_t>(), input.data_ptr<scalar_t>(), batch_size, hidden_size, eps);\n+  });\n+  return output;\n+}\n+\n // input : {batch_size, hidden_size}\n // weight: {hidden_size}\n at::Tensor rmsnorm_cpu(at::Tensor& input, at::Tensor& weight, double eps) {\ndiff --git a/sgl-kernel/csrc/cpu/rope.cpp b/sgl-kernel/csrc/cpu/rope.cpp\nindex 64bc297fe..1c6249466 100644\n--- a/sgl-kernel/csrc/cpu/rope.cpp\n+++ b/sgl-kernel/csrc/cpu/rope.cpp\n@@ -4,126 +4,343 @@\n namespace {\n \n template <typename scalar_t>\n-void rope_kernel_impl(\n-    scalar_t* __restrict__ q_pe_out,\n-    scalar_t* __restrict__ k_pe_out,\n-    int64_t* __restrict__ t_pos,\n-    scalar_t* __restrict__ q_pe,\n-    scalar_t* __restrict__ k_pe,\n-    scalar_t* __restrict__ t_emb_pos,\n-    int64_t seq_len,\n-    int64_t num_head,\n+void rotary_embedding_3D_kernel_impl(\n+    scalar_t* __restrict__ query_out,\n+    scalar_t* __restrict__ key_out,\n+    int64_t* __restrict__ positions,\n+    scalar_t* __restrict__ query,\n+    scalar_t* __restrict__ key,\n+    scalar_t* __restrict__ cos_sin_cache,\n+    int64_t num_tokens,\n+    int64_t num_heads,\n+    int64_t num_kv_heads,\n+    int64_t head_size,\n     int64_t rotary_dim,\n-    int64_t HR,\n-    int64_t q_pe_stride_s,\n-    int64_t out_stride_qs,\n-    int64_t out_stride_ks,\n-    int64_t HK,\n-    int64_t k_pe_stride_s,\n-    int64_t q_pe_stride_n,\n-    int64_t out_stride_qn) {\n+    int64_t query_stride_s,\n+    int64_t query_out_stride_s,\n+    int64_t key_out_stride_s,\n+    int64_t key_stride_s,\n+    int64_t query_stride_h,\n+    int64_t query_out_stride_h) {\n+  int64_t HR = rotary_dim;\n+  int64_t HK = rotary_dim;\n   int64_t COFF = HR / 2;\n-  at::parallel_for(0, seq_len * num_head, GRAIN_SIZE / rotary_dim, [&](int64_t begin, int64_t end) {\n+  at::parallel_for(0, num_tokens * num_heads, GRAIN_SIZE / rotary_dim, [&](int64_t begin, int64_t end) {\n     int64_t seq{0}, head_id{0};\n-    data_index_init(begin, seq, seq_len, head_id, num_head);\n+    data_index_init(begin, seq, num_tokens, head_id, num_heads);\n     for (int64_t i = begin; i < end; ++i) {\n-      int64_t in_offset_q = seq * q_pe_stride_s + head_id * q_pe_stride_n;\n-      int64_t out_offset_q = seq * out_stride_qs + head_id * out_stride_qn;\n-      int64_t out_offset_k = seq * out_stride_ks;\n+      int64_t in_offset_q = seq * query_stride_s + head_id * query_stride_h;\n+      int64_t out_offset_q = seq * query_out_stride_s + head_id * query_out_stride_h;\n+      int64_t out_offset_k = seq * key_out_stride_s;\n       int64_t p = 0;\n       scalar_t* sin_start = nullptr;\n       scalar_t* cos_start = nullptr;\n       // step 0) get the rotary position embedding for the current position\n-      p = t_pos[seq];\n-      sin_start = t_emb_pos + p * HR + COFF;\n-      cos_start = t_emb_pos + p * HR;\n+      p = positions[seq];\n+      sin_start = cos_sin_cache + p * HR + COFF;\n+      cos_start = cos_sin_cache + p * HR;\n       // step 1) apply_rotary_pos_emb for the rotary_dim elements in every\n       // head of query/key\n       for (int64_t h = 0; h < rotary_dim; h += 2) {\n         scalar_t cos = cos_start[h >> 1];\n         scalar_t sin = sin_start[h >> 1];\n-        scalar_t in1 = q_pe[in_offset_q + h];\n-        scalar_t in2 = q_pe[in_offset_q + h + 1];\n+        scalar_t in1 = query[in_offset_q + h];\n+        scalar_t in2 = query[in_offset_q + h + 1];\n         scalar_t out1 = in1 * cos - in2 * sin;\n         scalar_t out2 = in2 * cos + in1 * sin;\n-        q_pe_out[out_offset_q + h] = out1;\n-        q_pe_out[out_offset_q + h + 1] = out2;\n+        query_out[out_offset_q + h] = out1;\n+        query_out[out_offset_q + h + 1] = out2;\n       }\n       for (int64_t h = 0; h < HK; h += 2) {\n         scalar_t cos = cos_start[h >> 1];\n         scalar_t sin = sin_start[h >> 1];\n-        int64_t k_pe_offset = seq * k_pe_stride_s;\n-        scalar_t in1_k = k_pe[k_pe_offset + h];\n-        scalar_t in2_k = k_pe[k_pe_offset + h + 1];\n+        int64_t k_pe_offset = seq * key_stride_s;\n+        scalar_t in1_k = key[k_pe_offset + h];\n+        scalar_t in2_k = key[k_pe_offset + h + 1];\n         scalar_t out1_k = in1_k * cos - in2_k * sin;\n         scalar_t out2_k = in2_k * cos + in1_k * sin;\n-        k_pe_out[out_offset_k + h] = out1_k;\n-        k_pe_out[out_offset_k + h + 1] = out2_k;\n+        key_out[out_offset_k + h] = out1_k;\n+        key_out[out_offset_k + h + 1] = out2_k;\n       }\n       // move to the next index\n-      data_index_step(seq, seq_len, head_id, num_head);\n+      data_index_step(seq, num_tokens, head_id, num_heads);\n     }\n   });\n }\n+\n+template <typename scalar_t>\n+void rotary_embedding_neox_2D_kernel_impl(\n+    int64_t* __restrict__ positions,\n+    scalar_t* __restrict__ query,\n+    scalar_t* __restrict__ key,\n+    scalar_t* __restrict__ cos_sin_cache,\n+    int64_t rotary_dim,\n+    int64_t query_stride_s,\n+    int64_t key_stride_s,\n+    int64_t num_heads,\n+    int64_t num_kv_heads,\n+    int64_t head_size,\n+    int64_t num_tokens) {\n+  using bVec = at::vec::Vectorized<scalar_t>;\n+  using fVec = at::vec::Vectorized<float>;\n+  constexpr int64_t bVecSize = bVec::size();\n+\n+  int64_t embed_dim = rotary_dim / 2;\n+  bool flag = (embed_dim % bVecSize == 0);\n+  int64_t loop_upper = flag ? embed_dim : embed_dim - bVecSize;\n+\n+  auto compute_loop = [&](int64_t token_head, scalar_t* cache_ptr, scalar_t* qk) {\n+    int64_t j = 0;\n+    for (; j < loop_upper; j += bVecSize) {\n+      int64_t rot_offset = j;\n+      int64_t x_index = rot_offset;\n+      int64_t y_index = embed_dim + rot_offset;\n+\n+      int64_t out_x = token_head + x_index;\n+      int64_t out_y = token_head + y_index;\n+\n+      bVec _cos = bVec::loadu(cache_ptr + x_index);\n+      bVec _sin = bVec::loadu(cache_ptr + y_index);\n+\n+      bVec _q_x = bVec::loadu(qk + out_x);\n+      bVec _q_y = bVec::loadu(qk + out_y);\n+      fVec _cos_0, _cos_1;\n+      std::tie(_cos_0, _cos_1) = at::vec::convert_to_float(_cos);\n+      fVec _sin_0, _sin_1;\n+      std::tie(_sin_0, _sin_1) = at::vec::convert_to_float(_sin);\n+      fVec _q_x_0, _q_x_1;\n+      std::tie(_q_x_0, _q_x_1) = at::vec::convert_to_float(_q_x);\n+      fVec _q_y_0, _q_y_1;\n+      std::tie(_q_y_0, _q_y_1) = at::vec::convert_to_float(_q_y);\n+\n+      auto out1_0 = _q_x_0 * _cos_0 - _q_y_0 * _sin_0;\n+      auto out1_1 = _q_x_1 * _cos_1 - _q_y_1 * _sin_1;\n+      auto out1 = convert_from_float_ext<scalar_t>(out1_0, out1_1);\n+      out1.store(qk + out_x);\n+\n+      auto out2_0 = _q_y_0 * _cos_0 + _q_x_0 * _sin_0;\n+      auto out2_1 = _q_y_1 * _cos_1 + _q_x_1 * _sin_1;\n+      auto out2 = convert_from_float_ext<scalar_t>(out2_0, out2_1);\n+      out2.store(qk + out_y);\n+    }\n+    if (!flag) {\n+      for (; j < embed_dim; ++j) {\n+        int64_t x_index = j;\n+        int64_t y_index = embed_dim + j;\n+\n+        int64_t out_x = token_head + x_index;\n+        int64_t out_y = token_head + y_index;\n+\n+        float _cos = cache_ptr[x_index];\n+        float _sin = cache_ptr[y_index];\n+\n+        float _q_x = qk[out_x];\n+        float _q_y = qk[out_y];\n+\n+        qk[out_x] = _q_x * _cos - _q_y * _sin;\n+        qk[out_y] = _q_y * _cos + _q_x * _sin;\n+      }\n+    }\n+  };\n+\n+#pragma omp parallel for\n+  for (int64_t token_idx = 0; token_idx < num_tokens; ++token_idx) {\n+    int64_t pos = positions[token_idx];\n+    scalar_t* cache_ptr = cos_sin_cache + pos * rotary_dim;\n+\n+    for (int64_t i = 0; i < num_heads; ++i) {\n+      int64_t head_idx = i;\n+      int64_t token_head = token_idx * query_stride_s + head_idx * head_size;\n+      compute_loop(token_head, cache_ptr, query);\n+    }\n+\n+    for (int64_t i = 0; i < num_kv_heads; ++i) {\n+      int64_t head_idx = i;\n+      int64_t token_head = token_idx * key_stride_s + head_idx * head_size;\n+      compute_loop(token_head, cache_ptr, key);\n+    }\n+  }\n+}\n+\n+template <typename scalar_t>\n+void rotary_embedding_2D_kernel_impl(\n+    int64_t* __restrict__ positions,\n+    scalar_t* __restrict__ query,\n+    scalar_t* __restrict__ key,\n+    scalar_t* __restrict__ cos_sin_cache,\n+    int64_t rotary_dim,\n+    int64_t query_stride_s,\n+    int64_t key_stride_s,\n+    int64_t num_heads,\n+    int64_t num_kv_heads,\n+    int64_t head_size,\n+    int64_t num_tokens) {\n+  int64_t embed_dim = rotary_dim / 2;\n+\n+  at::parallel_for(0, num_tokens * num_heads, GRAIN_SIZE / rotary_dim, [&](int64_t begin, int64_t end) {\n+    int64_t token_idx = {0}, i = {0};\n+    data_index_init(begin, token_idx, num_tokens, i, num_heads);\n+    for ([[maybe_unused]] auto z : c10::irange(begin, end)) {\n+      int64_t pos = positions[token_idx];\n+      scalar_t* cache_ptr = cos_sin_cache + pos * rotary_dim;\n+      scalar_t* cos_cache_ptr = cache_ptr;\n+      scalar_t* sin_cache_ptr = cache_ptr + embed_dim;\n+      int64_t head_idx = i;\n+      int64_t token_head = token_idx * query_stride_s + head_idx * head_size;\n+      scalar_t* head_query = token_head + query;\n+      for (int64_t j = 0; j < embed_dim; j += 1) {\n+        int64_t rot_offset = j;\n+        int64_t x_index = 2 * rot_offset;\n+        int64_t y_index = 2 * rot_offset + 1;\n+\n+        float cos = cos_cache_ptr[rot_offset];\n+        float sin = sin_cache_ptr[rot_offset];\n+\n+        float x = head_query[x_index];\n+        float y = head_query[y_index];\n+\n+        head_query[x_index] = x * cos - y * sin;\n+        head_query[y_index] = y * cos + x * sin;\n+      }\n+      data_index_step(token_idx, num_tokens, i, num_heads);\n+    }\n+  });\n+\n+  at::parallel_for(0, num_tokens * num_kv_heads, GRAIN_SIZE / rotary_dim, [&](int64_t begin, int64_t end) {\n+    int64_t token_idx{0}, i = {0};\n+    data_index_init(begin, token_idx, num_tokens, i, num_kv_heads);\n+    for ([[maybe_unused]] auto z : c10::irange(begin, end)) {\n+      int64_t pos = positions[token_idx];\n+      scalar_t* cache_ptr = cos_sin_cache + pos * rotary_dim;\n+      scalar_t* cos_cache_ptr = cache_ptr;\n+      scalar_t* sin_cache_ptr = cache_ptr + embed_dim;\n+      int64_t head_idx = i;\n+      int64_t token_head = token_idx * key_stride_s + head_idx * head_size;\n+      scalar_t* head_key = key + token_head;\n+      for (int64_t j = 0; j < embed_dim; j += 1) {\n+        int64_t rot_offset = j;\n+        int64_t x_index = 2 * rot_offset;\n+        int64_t y_index = 2 * rot_offset + 1;\n+\n+        float cos = cos_cache_ptr[rot_offset];\n+        float sin = sin_cache_ptr[rot_offset];\n+\n+        float x = head_key[x_index];\n+        float y = head_key[y_index];\n+\n+        head_key[x_index] = x * cos - y * sin;\n+        head_key[y_index] = y * cos + x * sin;\n+      }\n+      data_index_step(token_idx, num_tokens, i, num_kv_heads);\n+    }\n+  });\n+}\n+\n }  // namespace\n \n-std::tuple<at::Tensor, at::Tensor>\n-rotary_position_embedding_cpu(at::Tensor& t_pos, at::Tensor& q_pe, at::Tensor& k_pe, at::Tensor& t_emb_pos) {\n-  RECORD_FUNCTION(\n-      \"sgl-kernel::rotary_position_embedding_cpu\", std::vector<c10::IValue>({t_pos, q_pe, k_pe, t_emb_pos}));\n-  CHECK_INPUT(t_pos);\n-  CHECK_LAST_DIM_CONTIGUOUS_INPUT(q_pe);\n-  CHECK_LAST_DIM_CONTIGUOUS_INPUT(k_pe);\n-  CHECK_INPUT(t_emb_pos);\n-  CHECK_DIM(1, t_pos);\n-  CHECK_DIM(3, q_pe);\n-  CHECK_DIM(3, k_pe);\n-  CHECK_DIM(2, t_emb_pos);\n-\n-  int64_t seq_len = q_pe.size(0);\n-  int64_t num_head = q_pe.size(1);\n-  int64_t rotary_dim = q_pe.size(2);\n-  int64_t HK = k_pe.size(2);\n-  int64_t HR = t_emb_pos.size(1);\n-  CHECK_EQ(HR, rotary_dim);\n-  CHECK_EQ(k_pe.size(0), seq_len);\n-  CHECK_EQ(k_pe.size(1), 1);\n-  CHECK_EQ(t_pos.size(0), seq_len);\n-  CHECK_EQ(HK, rotary_dim);\n-\n-  at::Tensor q_pe_out = at::empty_like(q_pe);\n-  at::Tensor k_pe_out = at::empty_like(k_pe);\n-  int64_t q_pe_stride_s = q_pe.stride(0);\n-  int64_t q_pe_stride_n = q_pe.stride(1);\n-  int64_t k_pe_stride_s = k_pe.stride(0);\n-  int64_t out_stride_qs = q_pe_out.stride(0);\n-  int64_t out_stride_qn = q_pe_out.stride(1);\n-  int64_t out_stride_ks = k_pe_out.stride(0);\n-\n-  const auto input_dtype = q_pe.scalar_type();\n-  TORCH_CHECK(t_pos.scalar_type() == at::kLong, \"expect positions to be int64, got \", t_pos.scalar_type());\n-  TORCH_CHECK(input_dtype == k_pe.scalar_type(), \"q_pe and k_pe must have the same data type\");\n-  TORCH_CHECK(input_dtype == t_emb_pos.scalar_type(), \"q_pe and t_emb_pos must have the same data type\");\n-\n-  AT_DISPATCH_REDUCED_FLOATING_TYPES(input_dtype, \"rotary_position_embedding_cpu\", [&] {\n-    rope_kernel_impl<scalar_t>(\n-        q_pe_out.data_ptr<scalar_t>(),\n-        k_pe_out.data_ptr<scalar_t>(),\n-        t_pos.data_ptr<int64_t>(),\n-        q_pe.data_ptr<scalar_t>(),\n-        k_pe.data_ptr<scalar_t>(),\n-        t_emb_pos.data_ptr<scalar_t>(),\n-        seq_len,\n-        num_head,\n-        rotary_dim,\n-        HR,\n-        q_pe_stride_s,\n-        out_stride_qs,\n-        out_stride_ks,\n-        HK,\n-        k_pe_stride_s,\n-        q_pe_stride_n,\n-        out_stride_qn);\n+std::tuple<at::Tensor, at::Tensor> rotary_embedding_cpu(\n+    at::Tensor& positions,\n+    at::Tensor& query,\n+    at::Tensor& key,\n+    int64_t head_size,\n+    at::Tensor& cos_sin_cache,\n+    bool is_neox) {\n+  RECORD_FUNCTION(\"sgl-kernel::rotary_embedding_cpu\", std::vector<c10::IValue>({query, key}));\n+  CHECK_DIM(1, positions);\n+  const auto input_dim = query.dim();\n+  const auto input_dtype = query.scalar_type();\n+  TORCH_CHECK(\n+      input_dim == 2 || input_dim == 3,\n+      \" Query/Key must be 2D [num_tokens, num_heads*head_size] or 3D [num_tokens, num_heads, head_size] tensor\");\n+  CHECK_DIM(2, cos_sin_cache);\n+  CHECK_LAST_DIM_CONTIGUOUS_INPUT(query);\n+  CHECK_LAST_DIM_CONTIGUOUS_INPUT(key);\n+\n+  int64_t rotary_dim = cos_sin_cache.size(1);\n+  if (input_dim == 3) {\n+    // TODO: add support for head_dim != rotary_dim case when input_dim=3\n+    CHECK_EQ(query.size(-1), rotary_dim);\n+    // TODO: add support for kv_head != 1\n+    CHECK_EQ(key.size(1), 1);\n+  }\n+\n+  int64_t num_tokens = positions.numel();\n+  CHECK_EQ(key.size(0), num_tokens);\n+  CHECK_EQ(query.size(0), num_tokens);\n+\n+  TORCH_CHECK(positions.scalar_type() == at::kLong, \"expect positions to be int64, got \", positions.scalar_type());\n+  TORCH_CHECK(input_dtype == key.scalar_type(), \"query and key must have the same data type\");\n+  TORCH_CHECK(input_dtype == cos_sin_cache.scalar_type(), \"query and cos_sin_cache must have the same data type\");\n+\n+  int64_t num_heads = input_dim == 2 ? query.size(-1) / head_size : query.size(1);\n+  int64_t num_kv_heads = input_dim == 2 ? key.size(-1) / head_size : key.size(1);\n+  int64_t key_stride_s = key.stride(0);\n+  int64_t query_stride_s = query.stride(0);\n+\n+  // input stride of num head dim is meaningful only when input dim = 3\n+  int64_t query_stride_h = input_dim == 3 ? query.stride(1) : -1;\n+  at::Tensor query_out = at::empty_like(query);\n+  at::Tensor key_out = at::empty_like(key);\n+  int64_t query_out_stride_s = query_out.stride(0);\n+  int64_t key_out_stride_s = key_out.stride(0);\n+  // output stride of num head dim is meaningful only when input dim = 3\n+  int64_t query_out_stride_h = input_dim == 3 ? query_out.stride(1) : -1;\n+\n+  AT_DISPATCH_REDUCED_FLOATING_TYPES(input_dtype, \"rotary_embedding_cpu\", [&] {\n+    if (input_dim == 2) {\n+      if (is_neox) {\n+        rotary_embedding_neox_2D_kernel_impl<scalar_t>(\n+            positions.data_ptr<int64_t>(),\n+            query.data_ptr<scalar_t>(),\n+            key.data_ptr<scalar_t>(),\n+            cos_sin_cache.data_ptr<scalar_t>(),\n+            rotary_dim,\n+            query_stride_s,\n+            key_stride_s,\n+            num_heads,\n+            num_kv_heads,\n+            head_size,\n+            num_tokens);\n+      } else {\n+        rotary_embedding_2D_kernel_impl<scalar_t>(\n+            positions.data_ptr<int64_t>(),\n+            query.data_ptr<scalar_t>(),\n+            key.data_ptr<scalar_t>(),\n+            cos_sin_cache.data_ptr<scalar_t>(),\n+            rotary_dim,\n+            query_stride_s,\n+            key_stride_s,\n+            num_heads,\n+            num_kv_heads,\n+            head_size,\n+            num_tokens);\n+      }\n+      query_out = query;\n+      key_out = key;\n+\n+    } else {\n+      TORCH_CHECK(\n+          is_neox == false, \" Query/Key with 3D [num_tokens, num_heads, head_size] does not support neox rope yet\");\n+      // TODO: add neox style support for rope impl with 3D inputs\n+      rotary_embedding_3D_kernel_impl<scalar_t>(\n+          query_out.data_ptr<scalar_t>(),\n+          key_out.data_ptr<scalar_t>(),\n+          positions.data_ptr<int64_t>(),\n+          query.data_ptr<scalar_t>(),\n+          key.data_ptr<scalar_t>(),\n+          cos_sin_cache.data_ptr<scalar_t>(),\n+          num_tokens,\n+          num_heads,\n+          num_kv_heads,\n+          head_size,\n+          rotary_dim,\n+          query_stride_s,\n+          query_out_stride_s,\n+          key_out_stride_s,\n+          key_stride_s,\n+          query_stride_h,\n+          query_out_stride_h);\n+    }\n   });\n-  return std::make_tuple(q_pe_out, k_pe_out);\n+  return std::make_tuple(query_out, key_out);\n }\ndiff --git a/sgl-kernel/csrc/cpu/topk.cpp b/sgl-kernel/csrc/cpu/topk.cpp\nindex 6a6b64d12..da8639a35 100644\n--- a/sgl-kernel/csrc/cpu/topk.cpp\n+++ b/sgl-kernel/csrc/cpu/topk.cpp\n@@ -157,6 +157,101 @@ inline void sigmoid(float* __restrict__ out, const scalar_t* __restrict__ input)\n   }\n }\n \n+template <typename scalar_t, int NUM_EXPERTS>\n+void topk_sigmoid_kernel_impl(\n+    float* __restrict__ topk_weights,\n+    int32_t* __restrict__ topk_ids,\n+    const scalar_t* __restrict__ gating_output,\n+    int64_t num_tokens,\n+    int64_t topk,\n+    bool renormalize) {\n+  using Vec = at::vec::Vectorized<float>;\n+  const int64_t num_experts_per_group = NUM_EXPERTS;\n+  at::parallel_for(0, num_tokens, 0, [&](int64_t begin, int64_t end) {\n+    alignas(64) float scores[NUM_EXPERTS];\n+    using elem_t = std::pair<float, int32_t>;\n+    std::vector<elem_t> queue(num_experts_per_group);\n+\n+    for (int64_t i = begin; i < end; ++i) {\n+      at::vec::convert<scalar_t, float>(gating_output + i * NUM_EXPERTS, scores, NUM_EXPERTS);\n+\n+      float gmax = at::vec::reduce_all<float>(\n+          [](Vec& x, Vec& y) { return at::vec::maximum(x, y); }, scores, num_experts_per_group);\n+\n+      // find position of first max,\n+      // note that we may have multiple max values.\n+      int first_max_idx = -1;\n+      for (int64_t e = 0; e < num_experts_per_group; ++e) {\n+        if (scores[e] == gmax) {\n+          first_max_idx = e;\n+          break;\n+        }\n+      }\n+\n+      // scalar sigmoid\n+      topk_weights[i] = 1.0 / (1.0 + exp(0.0 - gmax));\n+      topk_ids[i] = first_max_idx;\n+\n+      if (renormalize) {\n+        float sum = 0.f;\n+        for (int64_t j = 0; j < topk; ++j) {\n+          sum += topk_weights[i * topk + j];\n+        }\n+        float scale = 1.f / sum;\n+        for (int64_t j = 0; j < topk; ++j) {\n+          topk_weights[i * topk + j] *= scale;\n+        }\n+      }\n+    }\n+  });\n+}\n+\n+template <typename scalar_t, int NUM_EXPERTS>\n+void topk_softmax_kernel_impl(\n+    float* __restrict__ topk_weights,\n+    int32_t* __restrict__ topk_ids,\n+    const scalar_t* __restrict__ gating_output,\n+    int64_t num_tokens,\n+    int64_t topk,\n+    bool renormalize) {\n+  const int64_t num_experts_per_group = NUM_EXPERTS;\n+  at::parallel_for(0, num_tokens, 0, [&](int64_t begin, int64_t end) {\n+    alignas(64) float scores[NUM_EXPERTS];\n+    using elem_t = std::pair<float, int32_t>;\n+    std::vector<elem_t> queue(num_experts_per_group);\n+\n+    for (int64_t i = begin; i < end; ++i) {\n+      softmax<scalar_t, NUM_EXPERTS>(scores, gating_output + i * NUM_EXPERTS);\n+\n+      for (int64_t e = 0; e < num_experts_per_group; ++e) {\n+        queue[e] = {scores[e], e};\n+      }\n+\n+      std::partial_sort(\n+          queue.begin(),\n+          queue.begin() + num_experts_per_group,\n+          queue.end(),\n+          [](const elem_t& x, const elem_t& y) -> bool { return x.first > y.first; });\n+\n+      for (int64_t j = 0; j < topk; ++j) {\n+        topk_weights[i * topk + j] = queue[j].first;\n+        topk_ids[i * topk + j] = queue[j].second;\n+      }\n+\n+      if (renormalize) {\n+        float sum = 0.f;\n+        for (int64_t j = 0; j < topk; ++j) {\n+          sum += topk_weights[i * topk + j];\n+        }\n+        float scale = 1.f / sum;\n+        for (int64_t j = 0; j < topk; ++j) {\n+          topk_weights[i * topk + j] *= scale;\n+        }\n+      }\n+    }\n+  });\n+}\n+\n template <typename scalar_t, int SIZE>\n inline void\n apply_bias(float* __restrict__ scores2, const float* __restrict__ scores, const scalar_t* __restrict__ bias) {\n@@ -293,6 +388,24 @@ void biased_grouped_topk_kernel_impl(\n       topk_group,                         \\\n       renormalize);\n \n+#define LAUNCH_TOPK_SIGMOID_KERNEL(NE)    \\\n+  topk_sigmoid_kernel_impl<scalar_t, NE>( \\\n+      topk_weights.data_ptr<float>(),     \\\n+      topk_ids.data_ptr<int32_t>(),       \\\n+      gating_output.data_ptr<scalar_t>(), \\\n+      num_tokens,                         \\\n+      topk,                               \\\n+      renormalize);\n+\n+#define LAUNCH_TOPK_SOFTMAX_KERNEL(NE)    \\\n+  topk_softmax_kernel_impl<scalar_t, NE>( \\\n+      topk_weights.data_ptr<float>(),     \\\n+      topk_ids.data_ptr<int32_t>(),       \\\n+      gating_output.data_ptr<scalar_t>(), \\\n+      num_tokens,                         \\\n+      topk,                               \\\n+      renormalize);\n+\n #define LAUNCH_BIASED_GROUPED_TOPK_KERNEL(NE, NTOPK)    \\\n   biased_grouped_topk_kernel_impl<scalar_t, NE, NTOPK>( \\\n       topk_weights.data_ptr<float>(),                   \\\n@@ -306,6 +419,114 @@ void biased_grouped_topk_kernel_impl(\n \n }  // anonymous namespace\n \n+std::tuple<at::Tensor, at::Tensor>\n+topk_sigmoid_cpu(at::Tensor& hidden_states, at::Tensor& gating_output, int64_t topk, bool renormalize) {\n+  RECORD_FUNCTION(\"sgl-kernel::topk_sigmoid_cpu\", std::vector<c10::IValue>({hidden_states, gating_output}));\n+  CHECK_INPUT(gating_output);\n+\n+  const auto st = hidden_states.scalar_type();\n+  CHECK_EQ(gating_output.scalar_type(), st);\n+\n+  int64_t num_tokens = hidden_states.size(0);\n+  int64_t num_experts = gating_output.size(1);\n+  TORCH_CHECK(gating_output.size(0) == num_tokens, \"Number of tokens mismatch\");\n+  TORCH_CHECK(topk == 1, \"topk_sigmoid only supports topk=1 case\");\n+  at::Tensor topk_weights = at::empty({num_tokens, topk}, hidden_states.options().dtype(at::kFloat));\n+  at::Tensor topk_ids = at::empty({num_tokens, topk}, hidden_states.options().dtype(at::kInt));\n+\n+  AT_DISPATCH_REDUCED_FLOATING_TYPES(st, \"topk_sigmoid_kernel\", [&] {\n+    switch (num_experts) {\n+      case 1:\n+        LAUNCH_TOPK_SIGMOID_KERNEL(1);\n+        break;\n+      case 2:\n+        LAUNCH_TOPK_SIGMOID_KERNEL(2);\n+        break;\n+      case 4:\n+        LAUNCH_TOPK_SIGMOID_KERNEL(4);\n+        break;\n+      case 8:\n+        LAUNCH_TOPK_SIGMOID_KERNEL(8);\n+        break;\n+      case 16:\n+        LAUNCH_TOPK_SIGMOID_KERNEL(16);\n+        break;\n+      case 32:\n+        LAUNCH_TOPK_SIGMOID_KERNEL(32);\n+        break;\n+      case 64:\n+        LAUNCH_TOPK_SIGMOID_KERNEL(64);\n+        break;\n+      case 128:\n+        LAUNCH_TOPK_SIGMOID_KERNEL(128);\n+        break;\n+      case 160:\n+        LAUNCH_TOPK_SIGMOID_KERNEL(160);\n+        break;\n+      case 256:\n+        LAUNCH_TOPK_SIGMOID_KERNEL(256);\n+        break;\n+      default:\n+        TORCH_CHECK(false, \"Unexpected num_experts: \", num_experts);\n+    }\n+  });\n+  return std::make_tuple(topk_weights, topk_ids);\n+}\n+\n+std::tuple<at::Tensor, at::Tensor>\n+topk_softmax_cpu(at::Tensor& hidden_states, at::Tensor& gating_output, int64_t topk, bool renormalize) {\n+  RECORD_FUNCTION(\"sgl-kernel::topk_softmax_cpu\", std::vector<c10::IValue>({hidden_states, gating_output}));\n+  CHECK_INPUT(gating_output);\n+\n+  const auto st = hidden_states.scalar_type();\n+  CHECK_EQ(gating_output.scalar_type(), st);\n+\n+  int64_t num_tokens = hidden_states.size(0);\n+  int64_t num_experts = gating_output.size(1);\n+  TORCH_CHECK(gating_output.size(0) == num_tokens, \"Number of tokens mismatch\");\n+\n+  at::Tensor topk_weights = at::empty({num_tokens, topk}, hidden_states.options().dtype(at::kFloat));\n+  at::Tensor topk_ids = at::empty({num_tokens, topk}, hidden_states.options().dtype(at::kInt));\n+\n+  AT_DISPATCH_REDUCED_FLOATING_TYPES(st, \"topk_softmax_cpu\", [&] {\n+    switch (num_experts) {\n+      case 1:\n+        LAUNCH_TOPK_SOFTMAX_KERNEL(1);\n+        break;\n+      case 2:\n+        LAUNCH_TOPK_SOFTMAX_KERNEL(2);\n+        break;\n+      case 4:\n+        LAUNCH_TOPK_SOFTMAX_KERNEL(4);\n+        break;\n+      case 8:\n+        LAUNCH_TOPK_SOFTMAX_KERNEL(8);\n+        break;\n+      case 16:\n+        LAUNCH_TOPK_SOFTMAX_KERNEL(16);\n+        break;\n+      case 32:\n+        LAUNCH_TOPK_SOFTMAX_KERNEL(32);\n+        break;\n+      case 64:\n+        LAUNCH_TOPK_SOFTMAX_KERNEL(64);\n+        break;\n+      case 128:\n+        LAUNCH_TOPK_SOFTMAX_KERNEL(128);\n+        break;\n+      case 160:\n+        LAUNCH_TOPK_SOFTMAX_KERNEL(160);\n+        break;\n+      case 256:\n+        LAUNCH_TOPK_SOFTMAX_KERNEL(256);\n+        break;\n+      default:\n+        TORCH_CHECK(false, \"Unexpected num_experts: \", num_experts);\n+    }\n+  });\n+  return std::make_tuple(topk_weights, topk_ids);\n+}\n+\n // grouped topk for DeepSeek V2\n std::tuple<at::Tensor, at::Tensor> grouped_topk_cpu(\n     at::Tensor& hidden_states,\ndiff --git a/sgl-kernel/csrc/cpu/torch_extension_cpu.cpp b/sgl-kernel/csrc/cpu/torch_extension_cpu.cpp\nindex 018f8efb8..b718fc1b1 100644\n--- a/sgl-kernel/csrc/cpu/torch_extension_cpu.cpp\n+++ b/sgl-kernel/csrc/cpu/torch_extension_cpu.cpp\n@@ -23,6 +23,9 @@ limitations under the License.\n // silu_and_mul\n at::Tensor silu_and_mul_cpu(at::Tensor& input);\n \n+// l2norm\n+at::Tensor l2norm_cpu(at::Tensor& input, double eps);\n+\n // rmsnorm\n at::Tensor rmsnorm_cpu(at::Tensor& input, at::Tensor& weight, double eps);\n \n@@ -30,6 +33,11 @@ at::Tensor rmsnorm_cpu(at::Tensor& input, at::Tensor& weight, double eps);\n void fused_add_rmsnorm_cpu(at::Tensor& input, at::Tensor& residual, at::Tensor& weight, double eps);\n \n // topk\n+std::tuple<at::Tensor, at::Tensor>\n+topk_sigmoid_cpu(at::Tensor& hidden_states, at::Tensor& gating_output, int64_t topk, bool renormalize);\n+std::tuple<at::Tensor, at::Tensor>\n+topk_softmax_cpu(at::Tensor& hidden_states, at::Tensor& gating_output, int64_t topk, bool renormalize);\n+\n std::tuple<at::Tensor, at::Tensor> grouped_topk_cpu(\n     at::Tensor& hidden_states,\n     at::Tensor& gating_output,\n@@ -185,8 +193,13 @@ void shm_allreduce(\n at::Tensor shm_allgather(at::Tensor& data, c10::intrusive_ptr<c10d::ProcessGroup> process_group, int64_t dim);\n \n // rope\n-std::tuple<at::Tensor, at::Tensor>\n-rotary_position_embedding_cpu(at::Tensor& t_pos, at::Tensor& q_pe, at::Tensor& k_pe, at::Tensor& t_emb_pos);\n+std::tuple<at::Tensor, at::Tensor> rotary_embedding_cpu(\n+    at::Tensor& positions,\n+    at::Tensor& query,\n+    at::Tensor& key,\n+    int64_t head_size,\n+    at::Tensor& cos_sin_cache,\n+    bool is_neox);\n \n TORCH_LIBRARY_FRAGMENT(sgl_kernel, m) {\n   // activation\n@@ -196,10 +209,16 @@ TORCH_LIBRARY_FRAGMENT(sgl_kernel, m) {\n   // norm\n   m.def(\"rmsnorm_cpu(Tensor input, Tensor weight, float eps) -> Tensor\");\n   m.impl(\"rmsnorm_cpu\", torch::kCPU, &rmsnorm_cpu);\n+  m.def(\"l2norm_cpu(Tensor input, float eps) -> Tensor\");\n+  m.impl(\"l2norm_cpu\", torch::kCPU, &l2norm_cpu);\n   m.def(\"fused_add_rmsnorm_cpu(Tensor input, Tensor residual, Tensor weight, float eps) -> ()\");\n   m.impl(\"fused_add_rmsnorm_cpu\", torch::kCPU, &fused_add_rmsnorm_cpu);\n \n   // topk\n+  m.def(\"topk_sigmoid_cpu(Tensor hidden_states, Tensor gating_output, int topk, bool renormalize) -> (Tensor, Tensor)\");\n+  m.impl(\"topk_sigmoid_cpu\", torch::kCPU, &topk_sigmoid_cpu);\n+  m.def(\"topk_softmax_cpu(Tensor hidden_states, Tensor gating_output, int topk, bool renormalize) -> (Tensor, Tensor)\");\n+  m.impl(\"topk_softmax_cpu\", torch::kCPU, &topk_softmax_cpu);\n   m.def(\n       \"grouped_topk_cpu(Tensor hidden_states, Tensor gating_output, int topk, bool renormalize, int num_expert_group, \"\n       \"int topk_group) -> (Tensor, Tensor)\");\n@@ -294,8 +313,10 @@ TORCH_LIBRARY_FRAGMENT(sgl_kernel, m) {\n   m.impl(\"shm_allgather\", torch::kCPU, &shm_allgather);\n \n   // rope\n-  m.def(\"rotary_position_embedding_cpu(Tensor t_pos, Tensor q_pe, Tensor k_pe, Tensor t_emb_pos) -> (Tensor, Tensor)\");\n-  m.impl(\"rotary_position_embedding_cpu\", torch::kCPU, &rotary_position_embedding_cpu);\n+  m.def(\n+      \"rotary_embedding_cpu(Tensor positions, Tensor query, Tensor key, int head_size, Tensor cos_sin_cache, \"\n+      \"bool is_neox) -> (Tensor, Tensor)\");\n+  m.impl(\"rotary_embedding_cpu\", torch::kCPU, &rotary_embedding_cpu);\n }\n \n REGISTER_EXTENSION(common_ops)\ndiff --git a/test/srt/cpu/test_norm.py b/test/srt/cpu/test_norm.py\nindex 8af46c6a1..b7d139a5b 100644\n--- a/test/srt/cpu/test_norm.py\n+++ b/test/srt/cpu/test_norm.py\n@@ -63,10 +63,24 @@ class TestNorm(CustomTestCase):\n         self.assertTrue(torch.allclose(x, ref_x, atol=atol, rtol=rtol))\n         self.assertTrue(torch.allclose(residual, ref_residual, atol=atol, rtol=rtol))\n \n+    def _l2norm_test(self, m, n, dtype):\n+\n+        x = torch.randn([m, n], dtype=dtype)\n+        hidden_size = x.size(-1)\n+        fake_ones_weight = torch.ones(hidden_size, dtype=dtype)\n+        variance_epsilon = 1e-6\n+\n+        out = torch.ops.sgl_kernel.l2norm_cpu(x, variance_epsilon)\n+        ref_out = self._forward_native(x, fake_ones_weight, variance_epsilon)\n+\n+        atol = rtol = precision[ref_out.dtype]\n+        self.assertTrue(torch.allclose(ref_out, out, atol=atol, rtol=rtol))\n+\n     def test_norm(self):\n         for params in itertools.product(self.M, self.N, self.dtype):\n             with self.subTest(m=params[0], n=params[1], dtype=params[2]):\n                 self._norm_test(*params)\n+                self._l2norm_test(*params)\n \n \n if __name__ == \"__main__\":\ndiff --git a/test/srt/cpu/test_rope.py b/test/srt/cpu/test_rope.py\nindex 33b6fc623..b9c5da42b 100644\n--- a/test/srt/cpu/test_rope.py\n+++ b/test/srt/cpu/test_rope.py\n@@ -4,7 +4,10 @@ import sgl_kernel\n import torch\n from utils import precision\n \n-from sglang.srt.layers.rotary_embedding import DeepseekScalingRotaryEmbedding\n+from sglang.srt.layers.rotary_embedding import (\n+    DeepseekScalingRotaryEmbedding,\n+    RotaryEmbedding,\n+)\n from sglang.test.test_utils import CustomTestCase\n \n \n@@ -62,10 +65,13 @@ class TestROPE(CustomTestCase):\n                 )\n \n                 # fused rope kernel\n-                q_pe_clone, k_pe_clone = (\n-                    torch.ops.sgl_kernel.rotary_position_embedding_cpu(\n-                        positions, q_pe_clone, k_pe_clone, cos_sin_cache\n-                    )\n+                q_pe_clone, k_pe_clone = torch.ops.sgl_kernel.rotary_embedding_cpu(\n+                    positions,\n+                    q_pe_clone,\n+                    k_pe_clone,\n+                    rope.head_size,\n+                    cos_sin_cache,\n+                    False,\n                 )\n \n                 atol = rtol = precision[q_pe.dtype]\n@@ -73,6 +79,98 @@ class TestROPE(CustomTestCase):\n                 self.assertTrue(torch.allclose(k_pe, k_pe_clone, atol=atol, rtol=rtol))\n                 torch.testing.assert_close(k_pe, k_pe_clone)\n \n+    def test_origin_rope(self):\n+        def single_test(\n+            head_size: int,\n+            rotary_dim: int,\n+            max_position_embeddings: int,\n+            base: int,\n+            is_neox_style: bool,\n+            dtype: torch.dtype,\n+            device: str,\n+            batch_size: int,\n+            seq_len: int,\n+            num_q_heads: int,\n+            num_kv_heads: int,\n+        ):\n+            torch.manual_seed(100)\n+            rope_ref = RotaryEmbedding(\n+                head_size,\n+                rotary_dim,\n+                max_position_embeddings,\n+                base,\n+                is_neox_style,\n+                dtype,\n+            ).to(device)\n+            pos_ids = torch.arange(seq_len, device=device).repeat(batch_size)\n+            query = torch.randn(\n+                batch_size * seq_len,\n+                num_q_heads * head_size,\n+                dtype=dtype,\n+                device=device,\n+            )\n+            key = torch.randn(\n+                batch_size * seq_len,\n+                num_kv_heads * head_size,\n+                dtype=dtype,\n+                device=device,\n+            )\n+\n+            query_ref, key_ref = query.clone(), key.clone()\n+            query_cpu, key_cpu = query.clone(), key.clone()\n+\n+            query_ref_out, key_ref_out = rope_ref.forward_native(\n+                pos_ids, query_ref, key_ref\n+            )\n+            query_cpu_out, key_cpu_out = torch.ops.sgl_kernel.rotary_embedding_cpu(\n+                pos_ids,\n+                query_cpu,\n+                key_cpu,\n+                rope_ref.head_size,\n+                rope_ref.cos_sin_cache.to(query.dtype),\n+                rope_ref.is_neox_style,\n+            )\n+            torch.testing.assert_close(\n+                query_ref_out, query_cpu_out, atol=1e-2, rtol=1e-2\n+            )\n+            torch.testing.assert_close(key_ref_out, key_cpu_out, atol=1e-2, rtol=1e-2)\n+\n+        test_config = [\n+            (64, 64, 32, 8000, True, torch.bfloat16, \"cpu\", 32, 32, 1, 1),\n+            (256, 128, 4096, 10000, True, torch.bfloat16, \"cpu\", 2, 512, 32, 8),\n+            (512, 128, 311, 10000, True, torch.bfloat16, \"cpu\", 3, 39, 4, 2),\n+            (128, 128, 2048, 10000, False, torch.bfloat16, \"cpu\", 2, 512, 32, 8),\n+            (128, 128, 2048, 10000, False, torch.bfloat16, \"cpu\", 2, 512, 16, 4),\n+            (512, 128, 311, 10000, False, torch.bfloat16, \"cpu\", 3, 39, 4, 2),\n+        ]\n+\n+        for (\n+            head_size,\n+            rotary_dim,\n+            max_position_embeddings,\n+            base,\n+            is_neox_style,\n+            dtype,\n+            device,\n+            batch_size,\n+            seq_len,\n+            num_q_heads,\n+            num_kv_heads,\n+        ) in test_config:\n+            single_test(\n+                head_size,\n+                rotary_dim,\n+                max_position_embeddings,\n+                base,\n+                is_neox_style,\n+                dtype,\n+                device,\n+                batch_size,\n+                seq_len,\n+                num_q_heads,\n+                num_kv_heads,\n+            )\n+\n \n if __name__ == \"__main__\":\n     unittest.main()\ndiff --git a/test/srt/cpu/test_topk.py b/test/srt/cpu/test_topk.py\nindex 22c9e2784..3d0138d9a 100644\n--- a/test/srt/cpu/test_topk.py\n+++ b/test/srt/cpu/test_topk.py\n@@ -8,7 +8,9 @@ from utils import precision\n from sglang.srt.layers.moe.topk import (\n     biased_grouped_topk_impl as native_biased_grouped_topk,\n )\n+from sglang.srt.layers.moe.topk import fused_topk_native as native_fused_topk\n from sglang.srt.layers.moe.topk import grouped_topk as native_grouped_topk\n+from sglang.srt.models.llama4 import Llama4MoE\n from sglang.test.test_utils import CustomTestCase\n \n \n@@ -94,5 +96,86 @@ class TestBiasedGroupedTopK(CustomTestCase):\n             self._run_single_test(122, 256, 8, 8, 2, renormalize, torch.bfloat16)\n \n \n+class TestTopK(CustomTestCase):\n+    def _run_single_test(self, M, E, topk, renormalize, dtype):\n+        torch.manual_seed(1998)\n+\n+        # expand gating_output by M, otherwise bfloat16 fall into same value aftering truncating\n+        hidden_states = torch.randn(M, 100, dtype=dtype)\n+        gating_output = torch.randn(M, E, dtype=dtype) * 2 * M\n+\n+        ref_topk_weights, ref_topk_ids = native_fused_topk(\n+            hidden_states.float(),\n+            gating_output.float(),\n+            topk,\n+            renormalize,\n+        )\n+\n+        # fused version\n+        topk_weights, topk_ids = torch.ops.sgl_kernel.topk_softmax_cpu(\n+            hidden_states, gating_output, topk, renormalize\n+        )\n+\n+        res = torch.zeros(M, E, dtype=torch.float)\n+        ref = torch.zeros(M, E, dtype=torch.float)\n+        res.scatter_(1, topk_ids.long(), topk_weights)\n+        ref.scatter_(1, ref_topk_ids.long(), ref_topk_weights)\n+        torch.testing.assert_close(res, ref)\n+\n+    def test_topk(self):\n+        for renormalize in [True, False]:\n+            self._run_single_test(123, 8, 2, renormalize, torch.bfloat16)\n+            self._run_single_test(123, 16, 3, renormalize, torch.bfloat16)\n+            self._run_single_test(123, 32, 3, renormalize, torch.bfloat16)\n+            self._run_single_test(123, 32, 3, renormalize, torch.bfloat16)\n+            self._run_single_test(123, 64, 6, renormalize, torch.bfloat16)\n+            self._run_single_test(123, 256, 4, renormalize, torch.bfloat16)\n+            self._run_single_test(123, 160, 6, renormalize, torch.bfloat16)\n+\n+\n+class TestCustomTopK(CustomTestCase):\n+    def _run_single_test(\n+        self, M, E, topk, renormalize, dtype, native_custom_f, fused_custom_f\n+    ):\n+        torch.manual_seed(16)\n+\n+        # expand gating_output by M, otherwise bfloat16 fall into same value aftering truncating\n+        hidden_states = torch.randn(M, 100, dtype=dtype)\n+        gating_output = torch.randn(M, E, dtype=dtype) * 2 * M\n+\n+        ref_topk_weights, ref_topk_ids = native_custom_f(\n+            hidden_states.float(),\n+            gating_output.float(),\n+            topk,\n+            renormalize,\n+        )\n+\n+        # fused version\n+        topk_weights, topk_ids = fused_custom_f(\n+            hidden_states, gating_output, topk, renormalize\n+        )\n+\n+        res = torch.zeros(M, E, dtype=torch.float)\n+        ref = torch.zeros(M, E, dtype=torch.float)\n+        res.scatter_(1, topk_ids.long(), topk_weights)\n+        ref.scatter_(1, ref_topk_ids.long(), ref_topk_weights)\n+        torch.testing.assert_close(res, ref)\n+\n+    def test_custom_topk(self):\n+        test_custom_functions = [\n+            (Llama4MoE.custom_routing_function, torch.ops.sgl_kernel.topk_sigmoid_cpu)\n+        ]\n+        for native_custom_f, fused_custom_f in test_custom_functions:\n+            self._run_single_test(\n+                123, 8, 1, False, torch.bfloat16, native_custom_f, fused_custom_f\n+            )\n+            self._run_single_test(\n+                123, 16, 1, False, torch.bfloat16, native_custom_f, fused_custom_f\n+            )\n+            self._run_single_test(\n+                123, 32, 1, False, torch.bfloat16, native_custom_f, fused_custom_f\n+            )\n+\n+\n if __name__ == \"__main__\":\n     unittest.main()",
  "apis": [
    "torch.ops.sgl_kernel.l2norm_cpu",
    "torch.ops.sgl_kernel.rotary_embedding_cpu",
    "torch.ops.sgl_kernel.topk_sigmoid_cpu",
    "torch.ops.sgl_kernel.topk_softmax_cpu"
  ],
  "affected_paths": [
    "/path/to/repos/sglang/sgl-kernel/csrc/cpu/torch_extension_cpu.cpp",
    "/path/to/repos/sglang/python/sglang/srt/layers/rotary_embedding.py",
    "/path/to/repos/sglang/python/sglang/srt/layers/moe/topk.py"
  ],
  "repo_path": "/path/to/repos/sglang",
  "llm_reason": "The commit adds new CPU kernels and optimizations for routines such as l2norm, rotary embedding (rope fusion), and topk operations. It introduces vectorized implementations, parallelized loops, and unroll directives in non-test source files (e.g., norm.cpp, rope.cpp, topk.cpp) to improve CPU performance. The changes are non-trivial, target inner loops and high-level APIs, and are focused on performance optimization rather than bug fixes, documentation updates, or simple refactoring. Hence, the commit meets the performance/optimization criteria.",
  "llm_api_reason": "This commit adds several new CPU-optimized kernel implementations and updates existing ones. In norm.cpp a new l2norm_kernel_impl is introduced and wrapped into the l2norm_cpu API, which now computes L2 normalization on 2D tensors. In rope.cpp the previous rotary_position_embedding_cpu function has been replaced with a more flexible rotary_embedding_cpu function (supporting both neox and non-neox styles, and additional variants for 2D/3D inputs). In topk.cpp new kernel implementations for topk operations have been added: topk_sigmoid_cpu implements a CPU kernel for sigmoid-based top\u2011k selection and topk_softmax_cpu does the same for softmax-based top\u2011k. These changes are then bound via torch_extension_cpu.cpp so that calling the corresponding torch operator from Python now uses these optimized CPU kernels."
}