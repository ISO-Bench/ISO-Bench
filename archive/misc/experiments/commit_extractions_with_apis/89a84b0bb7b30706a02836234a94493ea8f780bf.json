{
  "commit_hash": "89a84b0bb7b30706a02836234a94493ea8f780bf",
  "parent_hash": "084a01fd3544557990f8af8af6fd3c1185bae848",
  "message": "[Core] Use array to speedup padding (#6779)",
  "author": "Peng Guanwen <pg999w@outlook.com>",
  "date": "2024-07-25 21:31:31 -0700",
  "files_changed": [
    {
      "file_path": "vllm/model_executor/layers/sampler.py",
      "old_content": "\"\"\"A layer that samples the next tokens from the model's outputs.\"\"\"\nimport itertools\nfrom typing import Dict, List, Optional, Tuple\n\nimport torch\nimport torch.nn as nn\n\nfrom vllm.model_executor.layers.ops.sample import sample as sample_triton\nfrom vllm.model_executor.sampling_metadata import (SamplingMetadata,\n                                                   SamplingTensors,\n                                                   SequenceGroupToSample)\nfrom vllm.sampling_params import SamplingType\nfrom vllm.sequence import (CompletionSequenceGroupOutput, Logprob,\n                           PromptLogprobs, SampleLogprobs, SamplerOutput,\n                           SequenceOutput)\n\n# (num_token_ids, num_parent_ids) per sequence group.\nSampleResultType = List[Tuple[List[int], List[int]]]\n\n\nclass Sampler(nn.Module):\n    \"\"\"Samples the next tokens from the model's outputs.\n\n    This layer does the following:\n    1. Discard the hidden states that are not used for sampling (i.e., all\n        tokens except the final one in each prompt).\n    2. Compute the logits for the next tokens.\n    3. Apply presence, frequency and repetition penalties.\n    4. Apply temperature scaling.\n    5. Apply top-p and top-k truncation.\n    6. Sample the next tokens.\n    Here, each sequence group within the batch can have different sampling\n    parameters (e.g., sampling method, temperature, top-p, top-k, etc.).\n\n    The structure of the logits tensor is coupled with the seq_groups in\n    sampling_metadata. Typically, each sequence in each seq_group has one row in\n    logits for the next token to be sampled; however, for a seq_group with a\n    prompt request with the prompt_logprobs sampling parameter, there are rows\n    in logits for each token in the input prompt.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        # Whether or not the SamplerOutput should have on-device tensors\n        # containing the sampled token ids and probabilities. This is used by\n        # speculative decoding.\n        self.include_gpu_probs_tensor = False\n\n    def _init_sampling_tensors(\n        self,\n        logits: torch.Tensor,\n        sampling_metadata: SamplingMetadata,\n    ):\n        \"\"\"The goal here is to reuse sampling tensors between similar decode\n        runs. This is possible because sampling logic does not change between\n        decodes of the same sequences.\n        \"\"\"\n        _, vocab_size = logits.shape\n\n        # First free any existing stored sampling tensors.\n        # This is necessary because some sampling tensors may\n        # have pinned memory.\n        self._sampling_tensors = None\n\n        # Initialize new sampling tensors\n        (sampling_tensors, do_penalties, do_top_p_top_k,\n         do_min_p) = SamplingTensors.from_sampling_metadata(\n             sampling_metadata, vocab_size, logits.device, logits.dtype)\n\n        self._sampling_tensors = sampling_tensors\n        self._do_penalties = do_penalties\n        self._do_top_p_top_k = do_top_p_top_k\n        self._do_min_p = do_min_p\n\n    def forward(\n        self,\n        logits: torch.Tensor,\n        sampling_metadata: SamplingMetadata,\n    ) -> Optional[SamplerOutput]:\n        \"\"\"\n        Args:\n            logits: (num_tokens, vocab_size).\n            sampling_metadata: Metadata for sampling.\n        \"\"\"\n        assert logits is not None\n        _, vocab_size = logits.shape\n\n        # Prepare sampling tensors with pinned memory to avoid blocking.\n        if not sampling_metadata.reuse_sampling_tensors:\n            self._init_sampling_tensors(logits, sampling_metadata)\n        elif self._do_penalties:\n            # In this case, the sampling tensors logic depends on\n            # \"output_tokens\" of a sequence. As a result, we cannot\n            # reuse sampling tensors, since \"output_tokens\" changes\n            # between decode runs.\n            self._init_sampling_tensors(logits, sampling_metadata)\n\n        assert self._sampling_tensors is not None\n        sampling_tensors = self._sampling_tensors\n        do_penalties = self._do_penalties\n        do_top_p_top_k = self._do_top_p_top_k\n        do_min_p = self._do_min_p\n\n        logits = _apply_min_tokens_penalty(logits, sampling_metadata)\n\n        # Apply presence and frequency penalties.\n        if do_penalties:\n            logits = _apply_penalties(logits, sampling_tensors.prompt_tokens,\n                                      sampling_tensors.output_tokens,\n                                      sampling_tensors.presence_penalties,\n                                      sampling_tensors.frequency_penalties,\n                                      sampling_tensors.repetition_penalties)\n\n        # Apply temperature scaling.\n        # Use in-place division to avoid creating a new tensor.\n        logits.div_(sampling_tensors.temperatures.unsqueeze(dim=1))\n\n        if do_top_p_top_k:\n            logits = _apply_top_k_top_p(logits, sampling_tensors.top_ps,\n                                        sampling_tensors.top_ks)\n\n        if do_min_p:\n            logits = _apply_min_p(logits, sampling_tensors.min_ps)\n\n        # We use float32 for probabilities and log probabilities.\n        # Compute the probabilities.\n        probs = torch.softmax(logits, dim=-1, dtype=torch.float)\n        # Compute the log probabilities.\n        logprobs = torch.log_softmax(logits, dim=-1, dtype=torch.float)\n\n        # Sample the next tokens.\n        sample_results, maybe_sampled_tokens_tensor = _sample(\n            probs,\n            logprobs,\n            sampling_metadata,\n            sampling_tensors,\n            include_gpu_probs_tensor=self.include_gpu_probs_tensor,\n            modify_greedy_probs=self._should_modify_greedy_probs_inplace,\n        )\n\n        if self.include_gpu_probs_tensor:\n            assert maybe_sampled_tokens_tensor is not None\n            on_device_tensors = (probs, logprobs, maybe_sampled_tokens_tensor)\n        else:\n            on_device_tensors = None\n\n        # Get the logprobs query results.\n        prompt_logprobs = None\n        sample_logprobs = None\n        if not sampling_metadata.skip_sampler_cpu_output:\n            prompt_logprobs, sample_logprobs = _get_logprobs(\n                logprobs, sampling_metadata, sample_results)\n\n        return _build_sampler_output(\n            sample_results,\n            sampling_metadata,\n            prompt_logprobs,\n            sample_logprobs,\n            on_device_tensors=on_device_tensors,\n            skip_sampler_cpu_output=sampling_metadata.skip_sampler_cpu_output)\n\n    @property\n    def _should_modify_greedy_probs_inplace(self) -> bool:\n        \"\"\"Whether or not the sampler should modify the probability distribution\n        of greedily-sampled tokens such that multinomial sampling would sample\n        the greedily-sampled token.\n\n        In other words, if True then we set the probability of the greedily-\n        sampled token to 1.\n\n        This is used by speculative decoding, which requires that the sampling\n        method be encoded into the probability distribution.\n        \"\"\"\n        # Modify greedy probs if include_gpu_probs_tensor is set.\n        return self.include_gpu_probs_tensor\n\n\ndef _get_bin_counts_and_mask(\n    tokens: torch.Tensor,\n    vocab_size: int,\n    num_seqs: int,\n) -> Tuple[torch.Tensor, torch.Tensor]:\n    # Compute the bin counts for the tokens.\n    # vocab_size + 1 for padding.\n    bin_counts = torch.zeros((num_seqs, vocab_size + 1),\n                             dtype=torch.long,\n                             device=tokens.device)\n    bin_counts.scatter_add_(1, tokens, torch.ones_like(tokens))\n    bin_counts = bin_counts[:, :vocab_size]\n    mask = bin_counts > 0\n\n    return bin_counts, mask\n\n\ndef _apply_min_tokens_penalty(\n    logits: torch.Tensor,\n    sampling_metadata: SamplingMetadata,\n) -> torch.Tensor:\n    \"\"\"Apply min_tokens penalty which sets stop tokens to -inf if min_tokens\n        have not been generated yet\n    \"\"\"\n    # list of indices in logits that will be set to -inf\n    logits_to_penalize: List[Tuple[int, int]] = []\n    logits_applied = 0\n    for seq_group in sampling_metadata.seq_groups:\n        seq_ids = seq_group.seq_ids\n        sampling_params = seq_group.sampling_params\n\n        sample_indices = seq_group.sample_indices\n        logits_applied += len(sample_indices) + len(\n            seq_group.prompt_logprob_indices)\n        if not seq_group.do_sample:\n            continue\n\n        start_idx = sample_indices[0]\n        min_tokens = sampling_params.min_tokens\n        token_ids_to_penalize = sampling_params.all_stop_token_ids\n        if min_tokens > 0 and token_ids_to_penalize:\n            seqs_to_penalize: List[int] = []\n            for j, seq_id in enumerate(seq_ids):\n                seq_data = seq_group.seq_data[seq_id]\n                if len(seq_data.output_token_ids) < min_tokens:\n                    seqs_to_penalize.append(j)\n\n            if seqs_to_penalize:\n                # convert to the index into logits\n                seqs_to_penalize = [start_idx + j for j in seqs_to_penalize]\n                # itertools.product pairs each seq index with every token id\n                logits_to_penalize.extend(\n                    itertools.product(seqs_to_penalize, token_ids_to_penalize))\n\n    if logits_to_penalize:\n        # use zip and * to group indices along each dimension\n        # eg. [ (1,2), (1,3), (5,6) ] -> ( (1,1,5), (2,3,6) )\n        logits[tuple(zip(*logits_to_penalize))] = -float(\"inf\")\n\n    # verifies that no rows in logits were missed unexpectedly\n    assert logits_applied == logits.shape[0]\n    return logits\n\n\ndef _apply_penalties(logits: torch.Tensor, prompt_tokens_tensor: torch.Tensor,\n                     output_tokens_tensor: torch.Tensor,\n                     presence_penalties: torch.Tensor,\n                     frequency_penalties: torch.Tensor,\n                     repetition_penalties: torch.Tensor) -> torch.Tensor:\n    num_seqs, vocab_size = logits.shape\n    _, prompt_mask = _get_bin_counts_and_mask(prompt_tokens_tensor, vocab_size,\n                                              num_seqs)\n    output_bin_counts, output_mask = _get_bin_counts_and_mask(\n        output_tokens_tensor, vocab_size, num_seqs)\n\n    repetition_penalties = repetition_penalties[:, None].repeat(1, vocab_size)\n    repetition_penalties[~(prompt_mask | output_mask)] = 1.0\n    logits = torch.where(logits > 0, logits / repetition_penalties,\n                         logits * repetition_penalties)\n\n    # We follow the definition in OpenAI API.\n    # Refer to https://platform.openai.com/docs/api-reference/parameter-details\n    logits -= frequency_penalties.unsqueeze_(dim=1) * output_bin_counts\n    logits -= presence_penalties.unsqueeze_(dim=1) * output_mask\n    return logits\n\n\ndef _apply_top_k_top_p(\n    logits: torch.Tensor,\n    p: torch.Tensor,\n    k: torch.Tensor,\n) -> torch.Tensor:\n    logits_sort, logits_idx = logits.sort(dim=-1, descending=False)\n\n    # Apply top-k.\n    top_k_mask = logits_sort.size(1) - k.to(torch.long)\n    # Get all the top_k values.\n    top_k_mask = logits_sort.gather(1, top_k_mask.unsqueeze(dim=1))\n    top_k_mask = logits_sort < top_k_mask\n    logits_sort.masked_fill_(top_k_mask, -float(\"inf\"))\n\n    # Apply top-p.\n    probs_sort = logits_sort.softmax(dim=-1)\n    probs_sum = probs_sort.cumsum(dim=-1)\n    top_p_mask = probs_sum <= 1 - p.unsqueeze(dim=1)\n    # at least one\n    top_p_mask[:, -1] = False\n    logits_sort.masked_fill_(top_p_mask, -float(\"inf\"))\n\n    # Re-sort the probabilities.\n    src = torch.arange(logits_idx.shape[-1],\n                       device=logits_idx.device).expand_as(logits_idx)\n    logits_idx_inv = torch.empty_like(logits_idx).scatter_(dim=-1,\n                                                           index=logits_idx,\n                                                           src=src)\n    logits = torch.gather(logits_sort, dim=-1, index=logits_idx_inv)\n    return logits\n\n\ndef _apply_min_p(\n    logits: torch.Tensor,\n    min_p: torch.Tensor,\n) -> torch.Tensor:\n    \"\"\"\n    Adapted from\n    https://github.com/oobabooga/text-generation-webui/blob/3146124ec01f02c8fb1650a6517cf1b60b537aaf/modules/sampler_hijack.py#L16C17-L16C17\n    \"\"\"\n    probs = torch.softmax(logits, dim=-1)\n    top_probs, _ = probs.max(dim=-1, keepdim=True)\n    scaled_min_p = min_p.unsqueeze_(dim=1) * top_probs\n    tokens_to_remove = probs < scaled_min_p\n    logits = logits.masked_fill_(tokens_to_remove, -float(\"inf\"))\n\n    return logits\n\n\ndef _greedy_sample(\n    selected_seq_groups: List[SequenceGroupToSample],\n    samples: torch.Tensor,\n) -> SampleResultType:\n    \"\"\"Run greedy sampling on a given samples.\n\n    Args:\n        selected_seq_groups: A list of sequence groups batched.\n        samples: (num_selected_samples,) A tensor of samples. The length of\n            samples could be smaller than selected_seq_groups if\n            seq_group.do_sample is False.\n    Returns:\n        Tuple of (next_token_ids, parent_ids). The length of returned list is\n        same as the length of selected_seq_groups. If the corresponding\n        seq_group has do_sample=False, tuple contains ([], [])\n    \"\"\"\n    samples_lst = samples.tolist()\n    sample_idx = 0\n    results: SampleResultType = []\n    for seq_group in selected_seq_groups:\n        if not seq_group.do_sample:\n            results.append(([], []))\n            continue\n\n        seq_ids = seq_group.seq_ids\n        num_parent_seqs = len(seq_ids)\n        assert num_parent_seqs == 1, (\n            \"Greedy sampling should have only one seq.\")\n        parent_ids = list(range(num_parent_seqs))\n        next_token_ids = [samples_lst[sample_idx]]\n        results.append((next_token_ids, parent_ids))\n        sample_idx += num_parent_seqs\n    return results\n\n\ndef _random_sample(\n    selected_seq_groups: List[SequenceGroupToSample],\n    random_samples: torch.Tensor,\n) -> SampleResultType:\n    \"\"\"Run random sampling on a given samples.\n\n    Args:\n        selected_seq_groups: A list of sequence groups batched.\n        random_samples: (num_selected_samples,) A tensor of samples. The\n            length of samples could be smaller than selected_seq_groups if\n            seq_group.do_sample is False.\n    Returns:\n        Tuple of (next_token_ids, parent_ids). The length of returned list is\n        same as the length of selected_seq_groups. If the corresponding\n        seq_group has do_sample=False, tuple contains ([], [])\n    \"\"\"\n    # Find the maximum best_of value of the prompt phase requests.\n    random_samples = random_samples.cpu()\n    sample_idx = 0\n    results: SampleResultType = []\n    for seq_group in selected_seq_groups:\n        if not seq_group.do_sample:\n            results.append(([], []))\n            continue\n\n        seq_ids = seq_group.seq_ids\n        sampling_params = seq_group.sampling_params\n        is_prompt = seq_group.is_prompt\n        num_parent_seqs = len(seq_ids)\n        if is_prompt:\n            # Prompt phase.\n            parent_ids = [0] * sampling_params.best_of\n            next_token_ids = random_samples[\n                sample_idx, :sampling_params.best_of].tolist()\n        else:\n            # Generation phase.\n            parent_ids = list(range(num_parent_seqs))\n            next_token_ids = random_samples[sample_idx:sample_idx +\n                                            num_parent_seqs, 0].tolist()\n        results.append((next_token_ids, parent_ids))\n        sample_idx += num_parent_seqs\n    return results\n\n\ndef _beam_search_sample(\n    selected_seq_groups: List[SequenceGroupToSample],\n    logprobs: torch.Tensor,\n) -> SampleResultType:\n    \"\"\"Run beam sampling on a given samples.\n\n    Args:\n        selected_seq_groups: A list of sequence groups batched.\n        logprobs: (num_selected_samples, vocab_size,) A tensor of logprob\n        on selected sample indices.\n    Returns:\n        Tuple of (next_token_ids, parent_ids). The length of returned list is\n        same as the length of selected_seq_groups. If the corresponding\n        seq_group has do_sample=False, tuple contains ([], [])\n    \"\"\"\n    # We sample 2 * beam_width candidates to make sure that with high\n    # probability we can get `beam_width` candidates in addition to\n    # the finished sequences for the next iteration. See\n    # https://github.com/tensorflow/tensor2tensor/blob/bafdc1b67730430d38d6ab802cbd51f9d053ba2e/tensor2tensor/utils/beam_search.py#L557-L563\n    # for details. See also HF reference:\n    # https://github.com/huggingface/transformers/blob/a4dd53d88e4852f023332d284ff07a01afcd5681/src/transformers/generation/utils.py#L3063-L3065\n    #\n    # NOTE: Beam search is not vectorized, so its speed can be slower than\n    # other sampling methods.\n    sample_idx = 0\n    results: SampleResultType = []\n    for seq_group in selected_seq_groups:\n        if not seq_group.do_sample:\n            results.append(([], []))\n            continue\n\n        is_prompt = seq_group.is_prompt\n        seq_ids, sampling_params = seq_group.seq_ids, seq_group.sampling_params\n        num_parent_seqs = len(seq_ids)\n        beam_width = sampling_params.best_of\n        seq_group_logprobs = logprobs[sample_idx:sample_idx + num_parent_seqs]\n        if is_prompt:\n            # Prompt phase.\n            assert num_parent_seqs == 1, (\n                \"Prompt input should have only one seq.\")\n            parent_ids = [0] * (2 * beam_width)\n            _, next_token_ids = torch.topk(seq_group_logprobs[0],\n                                           2 * beam_width)\n            next_token_ids = next_token_ids.tolist()\n        else:\n            # Generation phase.\n            cumulative_logprobs: List[float] = [\n                seq_group.seq_data[seq_id].cumulative_logprob\n                for seq_id in seq_ids\n            ]\n            cumulative_logprobs_tensor = torch.tensor(\n                cumulative_logprobs,\n                dtype=torch.float,\n                device=seq_group_logprobs.device)\n            seq_group_logprobs = (seq_group_logprobs +\n                                  cumulative_logprobs_tensor.unsqueeze(dim=1))\n            _, topk_ids = torch.topk(seq_group_logprobs.flatten(),\n                                     2 * beam_width)\n            topk_ids = topk_ids.tolist()\n            vocab_size = seq_group_logprobs.size(-1)\n            parent_ids = [i // vocab_size for i in topk_ids]\n            next_token_ids = [i % vocab_size for i in topk_ids]\n        results.append((next_token_ids, parent_ids))\n        sample_idx += num_parent_seqs\n    assert sample_idx == logprobs.size(0)\n    return results\n\n\n# torch.multinomial forces a GPU<->CPU sync.\n# Therefore, we use an optimized implementation instead.\n# Note that we always sample with replacement.\n# probs will be modified in place, but this is fine, as we pass\n# in a copy already.\ndef _multinomial(\n    probs: torch.Tensor,\n    num_samples: int,\n    seq_groups: Optional[List[SequenceGroupToSample]] = None,\n) -> torch.Tensor:\n    if num_samples > 1:\n        # This is equivalent to torch.repeat_interleaved (which also\n        # forces a GPU<->CPU sync).\n        # This allows us to do sampling with replacement by creating\n        # num_samples copies of each row in the tensor, and then\n        # batch sampling the resulting tensor.\n        probs = probs[:, None, :].expand(probs.shape[0], num_samples,\n                                         probs.shape[1]).contiguous().view(\n                                             -1, probs.shape[1])\n    q = torch.empty_like(probs)\n    if seq_groups is None:\n        q.exponential_()\n    else:\n        sample_idx = 0\n        for seq_group in seq_groups:\n            seq_ids = seq_group.seq_ids\n            next_sample_idx = sample_idx + len(seq_ids) * num_samples\n            q[sample_idx:next_sample_idx].exponential_(\n                generator=seq_group.generator)\n            sample_idx = next_sample_idx\n    return probs.div_(q).argmax(dim=1).view(-1, num_samples)\n\n\ndef _sample_with_torch(\n    probs: torch.Tensor,\n    logprobs: torch.Tensor,\n    sampling_metadata: SamplingMetadata,\n    include_gpu_probs_tensor: bool,\n    modify_greedy_probs: bool,\n) -> Tuple[SampleResultType, Optional[torch.Tensor]]:\n    categorized_seq_group_ids: Dict[SamplingType,\n                                    List[int]] = {t: []\n                                                  for t in SamplingType}\n    categorized_sample_indices = sampling_metadata.categorized_sample_indices\n    for i, seq_group in enumerate(sampling_metadata.seq_groups):\n        sampling_params = seq_group.sampling_params\n        sampling_type = sampling_params.sampling_type\n        categorized_seq_group_ids[sampling_type].append(i)\n\n    sample_results_dict: Dict[int, Tuple[List[int], List[int]]] = {}\n    sample_metadata: Dict[SamplingType,\n                          Tuple[List[int], List[SequenceGroupToSample]]] = {}\n    multinomial_samples: Dict[SamplingType, torch.Tensor] = {}\n\n    # Create output tensor for sampled token ids.\n    if include_gpu_probs_tensor:\n        sampled_token_ids_tensor = torch.empty(logprobs.shape[0],\n                                               1,\n                                               dtype=torch.long,\n                                               device=logprobs.device)\n    else:\n        sampled_token_ids_tensor = None\n\n    # Counterintiutively, having two loops here is actually faster.\n    # The first loop can run without waiting on GPU<->CPU sync.\n    for sampling_type in SamplingType:\n        sample_indices = categorized_sample_indices[sampling_type][:, 0]\n        num_tokens = len(sample_indices)\n        if num_tokens == 0:\n            continue\n\n        seq_group_id = categorized_seq_group_ids[sampling_type]\n        seq_groups = [sampling_metadata.seq_groups[i] for i in seq_group_id]\n        sample_metadata[sampling_type] = (seq_group_id, seq_groups)\n        long_sample_indices = sample_indices.long()\n        if sampling_type == SamplingType.GREEDY:\n            greedy_samples = torch.argmax(logprobs[long_sample_indices],\n                                          dim=-1)\n\n            if sampled_token_ids_tensor is not None:\n                # Store sampled tokens in output tensor.\n                sampled_token_ids_tensor[\n                    long_sample_indices] = greedy_samples.unsqueeze(-1)\n\n            if modify_greedy_probs:\n                # If required, modify the probabilities such that sampling from\n                # the modified distribution would always sample the argmax\n                # token id.\n                _modify_greedy_probs_inplace(logprobs, probs,\n                                             long_sample_indices,\n                                             greedy_samples)\n\n        elif sampling_type in (SamplingType.RANDOM, SamplingType.RANDOM_SEED):\n            max_best_of_in_batch = 1\n            for seq_group in seq_groups:\n                if seq_group.is_prompt:\n                    sampling_params = seq_group.sampling_params\n                    max_best_of_in_batch = max(max_best_of_in_batch,\n                                               sampling_params.best_of)\n            seeded_args = {} if sampling_type == SamplingType.RANDOM else {\n                \"seq_groups\": seq_groups,\n            }\n\n            multinomial_samples[sampling_type] = _multinomial(\n                probs[long_sample_indices], max_best_of_in_batch,\n                **seeded_args)\n\n            if sampled_token_ids_tensor is not None:\n                # Store sampled tokens in output tensor.\n                sampled_token_ids_tensor[\n                    long_sample_indices] = multinomial_samples[sampling_type]\n\n        elif sampling_type == SamplingType.BEAM:\n            beam_search_logprobs = logprobs[sample_indices]\n        else:\n            raise ValueError(f\"Unsupported sampling type: {sampling_type}\")\n\n    # GPU<->CPU sync happens in the loop below.\n    # This also converts the sample output to Python objects.\n    if not sampling_metadata.skip_sampler_cpu_output:\n        for sampling_type in SamplingType:\n            if sampling_type not in sample_metadata:\n                continue\n            (seq_group_id, seq_groups) = sample_metadata[sampling_type]\n            if sampling_type == SamplingType.GREEDY:\n                sample_results = _greedy_sample(seq_groups, greedy_samples)\n            elif sampling_type in (SamplingType.RANDOM,\n                                   SamplingType.RANDOM_SEED):\n                sample_results = _random_sample(\n                    seq_groups, multinomial_samples[sampling_type])\n            elif sampling_type == SamplingType.BEAM:\n                sample_results = _beam_search_sample(seq_groups,\n                                                     beam_search_logprobs)\n            sample_results_dict.update(zip(seq_group_id, sample_results))\n\n        sample_results = [\n            sample_results_dict.get(i, ([], []))\n            for i in range(len(sampling_metadata.seq_groups))\n        ]\n    else:\n        sample_results = []\n\n    return sample_results, sampled_token_ids_tensor\n\n\ndef _sample_with_triton_kernel(\n    probs: torch.Tensor,\n    logprobs: torch.Tensor,\n    sampling_metadata: SamplingMetadata,\n    sampling_tensors: SamplingTensors,\n) -> SampleResultType:\n    categorized_seq_group_ids: Dict[SamplingType,\n                                    List[int]] = {t: []\n                                                  for t in SamplingType}\n    categorized_sample_indices = sampling_metadata.categorized_sample_indices\n    for i, seq_group in enumerate(sampling_metadata.seq_groups):\n        sampling_params = seq_group.sampling_params\n        sampling_type = sampling_params.sampling_type\n        categorized_seq_group_ids[sampling_type].append(i)\n\n    sample_results_dict: Dict[int, Tuple[List[int], List[int]]] = {}\n    sample_metadata: Dict[SamplingType,\n                          Tuple[List[int], List[SequenceGroupToSample],\n                                torch.Tensor, torch.Tensor]] = {}\n    max_best_of_in_batch = 1\n\n    # Counterintiutively, having two loops here is actually faster.\n    # The first loop can run without waiting on GPU<->CPU sync.\n    for sampling_type in SamplingType:\n        sample_indices = categorized_sample_indices[sampling_type][:, 0]\n        sampled_token_indices = categorized_sample_indices[sampling_type][:, 1]\n        num_tokens = len(sample_indices)\n        if num_tokens == 0:\n            continue\n        seq_group_id = categorized_seq_group_ids[sampling_type]\n        seq_groups = [sampling_metadata.seq_groups[i] for i in seq_group_id]\n        sample_metadata[sampling_type] = (seq_group_id, seq_groups,\n                                          sample_indices,\n                                          sampled_token_indices)\n        if sampling_type in (SamplingType.GREEDY, SamplingType.RANDOM,\n                             SamplingType.RANDOM_SEED):\n            for seq_group in seq_groups:\n                if seq_group.is_prompt:\n                    sampling_params = seq_group.sampling_params\n                    max_best_of_in_batch = max(max_best_of_in_batch,\n                                               sampling_params.best_of)\n        elif sampling_type == SamplingType.BEAM:\n            beam_search_logprobs = logprobs[sample_indices]\n        else:\n            raise ValueError(f\"Unsupported sampling type: {sampling_type}\")\n\n    sampled_tokens, _, _ = sample_triton(\n        probs=probs,\n        seeds=sampling_tensors.sampling_seeds,\n        max_best_of=max_best_of_in_batch,\n        sample_indices=sampling_tensors.sample_indices,\n        logprobs=logprobs,\n        # don't save logprobs because we have logic for that below\n        # TODO: use this instead of the CPU-based logic below\n        save_logprobs=False,\n    )\n\n    # GPU<->CPU sync happens in the loop below.\n\n    for sampling_type in SamplingType:\n        if sampling_type not in sample_metadata:\n            continue\n        (seq_group_id, seq_groups, sample_indices,\n         sampled_token_indices) = sample_metadata[sampling_type]\n        if sampling_type == SamplingType.GREEDY:\n            sample_results = _greedy_sample(\n                seq_groups, sampled_tokens[sampled_token_indices][:, 0])\n        elif sampling_type in (SamplingType.RANDOM, SamplingType.RANDOM_SEED):\n            sample_results = _random_sample(\n                seq_groups, sampled_tokens[sampled_token_indices])\n        elif sampling_type == SamplingType.BEAM:\n            sample_results = _beam_search_sample(seq_groups,\n                                                 beam_search_logprobs)\n        sample_results_dict.update(zip(seq_group_id, sample_results))\n\n    sample_results = [\n        sample_results_dict.get(i, ([], []))\n        for i in range(len(sampling_metadata.seq_groups))\n    ]\n    return sample_results\n\n\ndef _sample(\n    probs: torch.Tensor, logprobs: torch.Tensor,\n    sampling_metadata: SamplingMetadata, sampling_tensors: SamplingTensors,\n    include_gpu_probs_tensor: bool, modify_greedy_probs: bool\n) -> Tuple[SampleResultType, Optional[torch.Tensor]]:\n    \"\"\"\n    Args:\n        probs: (num_query_tokens_in_batch, num_vocab)\n        logprobs: (num_query_tokens_in_batch, num_vocab)\n        sampling_metadata: The metadata for a batch for sampling.\n        sampling_tensors: Tensors that include sampling related metadata.\n\n    Returns:\n        (next_token_ids, parent_seq_ids) for each seq group in a batch.\n            If sampling is skipped, it returns ([], [])\n        sampled_token_ids_tensor: A tensor of sampled token ids.\n    \"\"\"\n    return _sample_with_torch(\n        probs,\n        logprobs,\n        sampling_metadata,\n        include_gpu_probs_tensor=include_gpu_probs_tensor,\n        modify_greedy_probs=modify_greedy_probs,\n    )\n\n    # TODO: Enable once Triton kernel & associated code is faster.\n    # return _sample_with_triton_kernel(probs, logprobs, sampling_metadata,\n    #                                   sampling_tensors)\n\n\ndef _get_ranks(x: torch.Tensor, indices: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    This function calculates the ranks of the chosen tokens in a logprob tensor.\n\n    Args:\n        x (torch.Tensor): 2D logprob tensor of shape (N, M)\n                        where N is the no. of tokens and M is the vocab dim.\n        indices (torch.Tensor): List of chosen token indices.\n\n    Returns:\n        torch.Tensor: 1D tensor of shape (N,) where N is the no. of tokens.\n                    Each element in the returned tensor represents the rank\n                    of the chosen token in the input logprob tensor.\n    \"\"\"\n    vals = x[torch.arange(0, len(x), device=x.device, dtype=indices.dtype),\n             indices]\n    result = (x > vals[:, None])\n    del vals\n    return result.sum(1).add_(1)\n\n\ndef _get_logprobs(\n    logprobs: torch.Tensor,\n    sampling_metadata: SamplingMetadata,\n    sample_results: SampleResultType,\n) -> Tuple[List[Optional[PromptLogprobs]], List[SampleLogprobs]]:\n    \"\"\"Return sample lobprobs and prompt logprobs.\n\n    The logic consists of 3 parts.\n    - Select indices to compute logprob from, ranks of token ids, and\n        the top k token ids from logprobs.\n    - Compute prompt logprobs if required.\n    - Compute sample logprobs if required.\n\n    Args:\n        logprobs: (num_query_tokens_across_batch, num_vocab). Each query token's\n            logprob per vocab. Sequence groups' query tokens are batched in a\n            single flattened tensor. For example, assuming there are N\n            seq groups, it is sorted by prefill tokens for seq_group_1 (if\n            prompt logprob is enabled), decode tokens for seq_group_1 (if\n            sampling is required), prefill tokens for seq_group_2, ...\n        sampling_metadata: The sampling metadata.\n        sample_results: (num_seq_groups) The tuple of (next_token_ids,\n            parent_ids) for each sequence group. When beam search is enabled,\n            sample_results can contain different number of seq_ids from\n            sampling_metadata.seq_groups. It is because beam search creates\n            2 * BEAM_WIDTH number of samples (whereas there are only up to\n            BEAM_WIDTH number of seq_ids).\n\n    Returns:\n        A tuple of prompt and sample logprobs per sequence group in a batch.\n    \"\"\"\n    # The index of query token to calculate logprobs. It includes both\n    # prompt and sample logprob indices.\n    query_indices: List[int] = []\n    # The next token ids to get the logprob value from.\n    next_token_ids: List[int] = []\n    # The largest requested number of logprobs. We find logprobs as many as the\n    # largest num logprobs in this API.\n    largest_num_logprobs = 1\n\n    # Select indices to compute logprob from, ranks of token ids, and the top\n    # k token ids from logprobs.\n    for (seq_group, sample_result) in zip(sampling_metadata.seq_groups,\n                                          sample_results):\n        sampling_params = seq_group.sampling_params\n\n        # Update indices and tokens for prompt logprobs.\n        if (seq_group.is_prompt\n                and sampling_params.prompt_logprobs is not None):\n            largest_num_logprobs = max(largest_num_logprobs,\n                                       sampling_params.prompt_logprobs)\n            next_prompt_tokens = _get_next_prompt_tokens(seq_group)\n            query_indices.extend(seq_group.prompt_logprob_indices)\n            next_token_ids.extend(next_prompt_tokens)\n\n        # Update indices and next tokenes for sample logprob.\n        if seq_group.do_sample:\n            token_ids, parent_seq_ids = sample_result\n            # NOTE: We cannot directly use sample_indices because\n            # sample_indices only contain parent seq_ids of a previous step.\n            # The current step may have different number of seq_ids, and\n            # we can obtain it from `sample_result[1]`.\n            query_idx = seq_group.sample_indices[0]\n            query_indices.extend(\n                [query_idx + parent_id for parent_id in parent_seq_ids])\n            next_token_ids.extend(token_ids)\n\n            if sampling_params.logprobs is not None:\n                largest_num_logprobs = max(largest_num_logprobs,\n                                           sampling_params.logprobs)\n\n        assert len(next_token_ids) == len(query_indices)\n\n    if len(query_indices) == 0:\n        empty_sampled_logprob: SampleLogprobs = []\n        empty_prompt_logprob: Optional[PromptLogprobs] = None\n        return [empty_prompt_logprob], [empty_sampled_logprob]\n\n    query_indices_gpu = torch.tensor(query_indices, device=logprobs.device)\n    next_token_ids_gpu = torch.tensor(next_token_ids, device=logprobs.device)\n\n    # (num_selected_query_tokens, num_logprobs). Note that query_indices can\n    # contain duplicates if beam search is enabled.\n    selected_logprobs = logprobs[[\n        query_indices_gpu,\n        next_token_ids_gpu,\n    ]]\n    ranks = _get_ranks(\n        logprobs[query_indices_gpu],\n        next_token_ids_gpu,\n    )\n    assert selected_logprobs.shape[0] == ranks.shape[0]\n\n    # Logprobs of topk tokens for a batch of sequence groups.\n    # (num_query_tokens_across_batch).\n    if largest_num_logprobs > 0:\n        top_logprobs, top_token_ids = torch.topk(logprobs,\n                                                 largest_num_logprobs,\n                                                 dim=-1)\n    else:\n        top_logprobs, top_token_ids = None, None\n\n    selected_logprobs = selected_logprobs.to('cpu')\n    ranks = ranks.to('cpu')\n    if top_logprobs is not None and top_token_ids is not None:\n        top_logprobs = top_logprobs.to('cpu')\n        top_token_ids = top_token_ids.to('cpu')\n\n    # Find prompt/sample logprobs.\n    prompt_logprobs_per_seq_group: List[Optional[PromptLogprobs]] = []\n    sample_logprobs_per_seq_group: List[SampleLogprobs] = []\n    top_logprob_idx = 0\n    selected_logprobs_idx = 0\n\n    for seq_group, sample_result in zip(sampling_metadata.seq_groups,\n                                        sample_results):\n        (prompt_logprobs, top_logprob_idx,\n         selected_logprobs_idx) = _get_prompt_logprob_if_needed(\n             seq_group, selected_logprobs, ranks, top_token_ids, top_logprobs,\n             selected_logprobs_idx, top_logprob_idx)\n        prompt_logprobs_per_seq_group.append(prompt_logprobs)\n\n        (sampled_logprobs, top_logprob_idx,\n         selected_logprobs_idx) = _get_sampled_logprob_if_needed(\n             seq_group, sample_result, selected_logprobs, ranks, top_token_ids,\n             top_logprobs, selected_logprobs_idx, top_logprob_idx)\n        sample_logprobs_per_seq_group.append(sampled_logprobs)\n\n    return prompt_logprobs_per_seq_group, sample_logprobs_per_seq_group\n\n\ndef _get_prompt_logprob_if_needed(\n    seq_group: SequenceGroupToSample,\n    selected_logprobs: torch.Tensor,\n    ranks: torch.Tensor,\n    top_token_ids: torch.Tensor,\n    top_logprobs: torch.Tensor,\n    selected_logprobs_idx: int,\n    top_logprob_idx: int,\n):\n    \"\"\"Compute the prompt logprob from a sequence group if needed.\"\"\"\n    sampling_params = seq_group.sampling_params\n    is_prompt = seq_group.is_prompt\n\n    # Find prompt logprobs\n    prompt_logprobs: Optional[PromptLogprobs] = None\n    if is_prompt and sampling_params.prompt_logprobs is not None:\n        prompt_logprobs = []\n        num_logprobs = sampling_params.prompt_logprobs\n        next_prompt_tokens = _get_next_prompt_tokens(seq_group)\n        # Pre-select indexes and create a list. It is faster than calling .item\n        # repetitively.\n        selected_logprob_items = selected_logprobs[\n            selected_logprobs_idx:selected_logprobs_idx +\n            len(next_prompt_tokens)].tolist()\n        rank_items = ranks[selected_logprobs_idx:selected_logprobs_idx +\n                           len(next_prompt_tokens)].tolist()\n\n        for idx, token_id in enumerate(next_prompt_tokens):\n            # Calculate the prompt logprob of the real prompt tokens.\n            # {token_id: (logprob, rank_from_vocab)}\n            prompt_logprobs_dict: Dict[int, Tuple[float, int]] = {\n                token_id: (selected_logprob_items[idx], rank_items[idx])\n            }\n\n            # Add top K prompt logprobs along with its rank.\n            if num_logprobs > 0:\n                top_ids = top_token_ids[\n                    top_logprob_idx, :num_logprobs].tolist()\n                top_probs = top_logprobs[\n                    top_logprob_idx, :num_logprobs].tolist()\n                # Top K is already sorted by rank, so we can use 1 ~\n                # num_logprobs + 1 for rank.\n                top_ranks = range(1, num_logprobs + 1)\n                prompt_logprobs_dict.update({\n                    top_id: (top_prob, rank)\n                    for top_id, top_prob, rank in zip(top_ids, top_probs,\n                                                      top_ranks)\n                })\n            prompt_logprobs.append({\n                token_id: Logprob(*logprob_and_rank)\n                for token_id, logprob_and_rank in prompt_logprobs_dict.items()\n            })\n            # + 1 to go to the next prompt token.\n            top_logprob_idx += 1\n\n        # + len(next_prompt_tokens) to go to the next prompt.\n        selected_logprobs_idx += len(next_prompt_tokens)\n    return prompt_logprobs, top_logprob_idx, selected_logprobs_idx\n\n\ndef _get_sampled_logprob_if_needed(\n    seq_group: SequenceGroupToSample,\n    sample_result: Tuple[List[int], List[int]],\n    selected_logprobs: torch.Tensor,\n    ranks: torch.Tensor,\n    top_token_ids: torch.Tensor,\n    top_logprobs: torch.Tensor,\n    selected_logprobs_idx: int,\n    top_logprob_idx: int,\n):\n    \"\"\"Compute the sample logprob if needed.\"\"\"\n    seq_ids = seq_group.seq_ids\n    num_logprobs = seq_group.sampling_params.logprobs or 0\n    sampled_logprobs: SampleLogprobs = []\n    next_token_ids, parent_seq_ids = sample_result\n\n    if seq_group.do_sample:\n        assert len(next_token_ids) > 0\n        # Pre-select items from tensor. tolist() is faster than repetitive\n        # `.item()` calls.\n        selected_logprob_items = selected_logprobs[\n            selected_logprobs_idx:selected_logprobs_idx +\n            len(next_token_ids)].tolist()\n        rank_items = ranks[selected_logprobs_idx:selected_logprobs_idx +\n                           len(next_token_ids)].tolist()\n        for idx, (next_token_id,\n                  parent_id) in enumerate(zip(next_token_ids, parent_seq_ids)):\n            # Get the logprob of a sampled token.\n            sampled_logprobs_dict = {\n                next_token_id: (selected_logprob_items[idx], rank_items[idx])\n            }\n            # Get top K logprobs.\n            if num_logprobs > 0:\n                top_ids = top_token_ids[top_logprob_idx +\n                                        parent_id, :num_logprobs].tolist()\n                top_probs = top_logprobs[top_logprob_idx +\n                                         parent_id, :num_logprobs].tolist()\n                # Top K is already sorted by rank, so we can use 1 ~\n                # num_logprobs + 1 for rank.\n                top_ranks = range(1, num_logprobs + 1)\n                sampled_logprobs_dict.update({\n                    top_id: (top_prob, rank)\n                    for top_id, top_prob, rank in zip(top_ids, top_probs,\n                                                      top_ranks)\n                })\n\n            sampled_logprobs.append({\n                token_id: Logprob(*logprob_and_rank)\n                for token_id, logprob_and_rank in\n                sampled_logprobs_dict.items()\n            })\n\n        # NOTE: This part of code is not intuitive. `selected_logprobs` include\n        # logprobs for the current step, which has len(next_token_ids) tokens\n        # per sequence group. `logprobs` includes logprobs from the previous\n        # steps, which has len(seq_ids) tokens per sequence group.\n\n        # Iterate to the next sequence group in a batch.\n        selected_logprobs_idx += len(next_token_ids)\n        # Iterate to the next sequence group in a batch.\n        top_logprob_idx += len(seq_ids)\n    return sampled_logprobs, top_logprob_idx, selected_logprobs_idx\n\n\ndef _modify_greedy_probs_inplace(logprobs: torch.Tensor, probs: torch.Tensor,\n                                 sample_indices: torch.Tensor,\n                                 greedy_samples: torch.Tensor) -> None:\n    \"\"\"Modify the probability distributions of the greedily-sampled tokens such\n    that each sampled token has a \"probability\" of 1.0. This is required by\n    speculative decoding, which depends on the sampling method being encoded\n    within the probability distribution for correctness.\n\n    # Why do we only need to do this for greedy sampling?\n\n    vLLM's sampler performs the following steps for greedy or multinomial\n    (random) sampling:\n        1. Get logits from model.\n        2. Modify logits according to per-sequence sampling parameters.\n            - Multiply by temperature, top-k and top-p masking, penalize tokens\n                according to their frequency, etc.\n        3. Sample a token.\n            - Random sampling simply samples from the modified probability\n                distribution.\n            - Greedy sampling performs `argmax` to obtain the token with the\n                highest likelihood.\n\n    Ignoring greedy sampling for a moment, we find that the computed probability\n    distribution has the following property: we can sample from it independently\n    and find that the token sampled by the Sampler has a frequency corresponding\n    to how often we see it in our sampling. In other words, for tokens sampled\n    with vLLM's random SamplingType, the computed probability distribution\n    encodes the sampling methodology completely.\n\n    Greedy sampling does not normally have this property. vLLM modifies logits\n    according to sampling params, then performs `argmax`, then returns the\n    sampled token and the computed probability distribution. If we sample from\n    the distribution, we'll find the likelihood of the greedily-sampled token\n    is not always 1.0.\n\n    Since lossless speculative decoding requires that the sampling methodology\n    be encoded within the probability distribution, we are motivated to modify\n    the probability distribution such that the sampled token has probability 1\n    when speculative decoding is used.\n\n    NOTE: Alternatively, we could use an extremely low temperature to achieve\n    greedy sampling using multinomial computation and unite the codepaths. This\n    has implications on the overall design of the sampler, e.g. how to record\n    accurate logprobs for the user, so this improvement is deferred to later.\n    \"\"\"\n    # NOTE: logprobs are not modified so they can be returned to the user.\n    probs[sample_indices, :] = 0\n    probs[sample_indices, greedy_samples] = 1.0\n\n\ndef _build_sampler_output(\n    sample_results: SampleResultType,\n    sampling_metadata: SamplingMetadata,\n    prompt_logprobs: Optional[List[Optional[PromptLogprobs]]],\n    sample_logprobs: Optional[List[SampleLogprobs]],\n    on_device_tensors: Optional[Tuple[torch.Tensor, torch.Tensor,\n                                      torch.Tensor]],\n    skip_sampler_cpu_output: bool = False,\n) -> SamplerOutput:\n    \"\"\"Construct Python objects with the output of sampling.\n\n    Args:\n        on_device_tensors: Tuple containing on-device tensors with the\n            probabilities used in sampling and the sampled token ids. This\n            allows post-processing without copies to CPU/serialization, e.g. in\n            speculative decoding rejection sampling.\n    \"\"\"\n    sampler_output: List[CompletionSequenceGroupOutput] = []\n    if not skip_sampler_cpu_output:\n        assert prompt_logprobs is not None\n        assert sample_logprobs is not None\n\n        for (seq_group, sample_result, group_prompt_logprobs,\n             group_sample_logprobs) in zip(sampling_metadata.seq_groups,\n                                           sample_results, prompt_logprobs,\n                                           sample_logprobs):\n            seq_ids = seq_group.seq_ids\n            next_token_ids, parent_ids = sample_result\n            seq_outputs: List[SequenceOutput] = []\n            for parent_id, next_token_id, logprobs in zip(\n                    parent_ids, next_token_ids, group_sample_logprobs):\n                seq_outputs.append(\n                    SequenceOutput(seq_ids[parent_id], next_token_id,\n                                   logprobs))\n            sampler_output.append(\n                CompletionSequenceGroupOutput(seq_outputs,\n                                              group_prompt_logprobs))\n\n    # If not specified, store None values in SamplerOutput.\n    if on_device_tensors is not None:\n        (sampled_token_probs, logprobs_tensor,\n         sampled_token_ids) = on_device_tensors\n    else:\n        sampled_token_probs, logprobs_tensor, sampled_token_ids = (None, None,\n                                                                   None)\n\n    return SamplerOutput(\n        outputs=sampler_output,\n        sampled_token_probs=sampled_token_probs,\n        sampled_token_ids=sampled_token_ids,\n        logprobs=logprobs_tensor,\n    )\n\n\ndef _get_next_prompt_tokens(seq_group: SequenceGroupToSample) -> List[int]:\n    \"\"\"Get a list of next prompt tokens to compute logprob from a\n        given sequence group.\n\n    It is used to compute prompt logprob. Imagine you have logprob for each\n    query token. Query token needs to know the next prompt token id to compute\n    prompt logprob. This is a helper to obtain next prompt token ids.\n\n    This API has to be used only when the caller knows seq_group is in prefill\n    stage.\n\n    Returns:\n        A list of next prompt tokens to compute logprob.\n    \"\"\"\n    assert seq_group.is_prompt, (\n        \"Caller should ensure the sequence group is in a prefill stage.\")\n    seq_ids = seq_group.seq_ids\n    query_len = seq_group.query_len\n    assert query_len is not None\n    # prompt has only 1 seq id.\n    assert len(seq_ids) == 1\n    seq_data = seq_group.seq_data[seq_ids[0]]\n    computed_len = seq_data.get_num_computed_tokens()\n    prompt_tokens = seq_data.prompt_token_ids\n    # +1 because we are looking for a next prompt token.\n    next_token_index_start = computed_len + 1\n    next_token_index_end = min(computed_len + query_len + 1,\n                               len(prompt_tokens))\n    next_prompt_tokens = prompt_tokens[\n        next_token_index_start:next_token_index_end]\n    return next_prompt_tokens\n",
      "diff": "diff --git a/vllm/model_executor/layers/sampler.py b/vllm/model_executor/layers/sampler.py\nindex 5c376797a..121458f81 100644\n--- a/vllm/model_executor/layers/sampler.py\n+++ b/vllm/model_executor/layers/sampler.py\n@@ -220,7 +220,7 @@ def _apply_min_tokens_penalty(\n             seqs_to_penalize: List[int] = []\n             for j, seq_id in enumerate(seq_ids):\n                 seq_data = seq_group.seq_data[seq_id]\n-                if len(seq_data.output_token_ids) < min_tokens:\n+                if len(seq_data.output_token_ids_array) < min_tokens:\n                     seqs_to_penalize.append(j)\n \n             if seqs_to_penalize:",
      "change_type": "modified",
      "lines_added": 2,
      "lines_removed": 2
    },
    {
      "file_path": "vllm/model_executor/sampling_metadata.py",
      "old_content": "import random\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional, Tuple\n\nimport torch\n\nfrom vllm.model_executor.layers.ops.sample import get_num_triton_sampler_splits\nfrom vllm.sampling_params import SamplingParams, SamplingType\nfrom vllm.sequence import SequenceData, SequenceGroupMetadata\nfrom vllm.utils import (async_tensor_h2d, is_pin_memory_available,\n                        make_tensor_with_pad, maybe_expand_dim)\n\n_SAMPLING_EPS = 1e-5\n_SEED_0_REPLACEMENT = 3403598558\n\n\n@dataclass\nclass SequenceGroupToSample:\n    # |---------- N-1 iteration --------|\n    # |---------------- N iteration ---------------------|\n    # |- tokenA -|......................|-- newTokens ---|\n    # |---------- context_len ----------|\n    # |-------------------- seq_len ----------------------|\n    #                                   |-- query_len ---|\n\n    # Sequence ids for the sequence group in a previous step.\n    seq_ids: List[int]\n    sampling_params: SamplingParams\n    # seq_id -> sequence data.\n    seq_data: Dict[int, SequenceData]\n    # The length of the sequence (all tokens seen in the past + new token to\n    # compute attention) of the sequence group. None if it is in a decode\n    # stage.\n    seq_len: Optional[int]\n    # The length of new query tokens to compute in the current step. None if it\n    # is in a decode stage. The length of query_len <= seq_len if chunked\n    # prefill is enabled.\n    query_len: Optional[int]\n    # A random number generator for sampling.\n    generator: Optional[torch.Generator]\n    # True if the sequence group is in prefill stage. False if it is in a\n    # decode stage.\n    is_prompt: bool\n    # Query token indices from logits. to compute prompt logprob. Empty if\n    # prompt logprob is not required.\n    prompt_logprob_indices: List[int]\n    # Sample token indices from logits. Empty if sampling is not required.\n    sample_indices: List[int]\n\n    @property\n    def do_sample(self):\n        return len(self.sample_indices) > 0\n\n    def __post_init__(self):\n        if len(self.prompt_logprob_indices) > 0:\n            assert self.sampling_params.prompt_logprobs is not None\n        if self.is_prompt:\n            assert self.seq_len is not None\n            assert self.query_len is not None\n\n\nclass SamplingMetadata:\n    \"\"\"Metadata for input sequences. Used in sampler.\n\n    The usage is as follow;\n    ```\n    hidden_states = execute_model(...)\n    logits = hidden_states[sampling_metadata.selected_token_indices]\n    sample(logits)\n\n    def sample(logits):\n        # Use categorized_sample_indices for sampling....\n    ```\n\n    Args:\n        seq_groups: List of batched sequence groups.\n        selected_token_indices: (num_query_tokens_to_logprob). Indices to find\n            logits from the initial model output hidden states.\n        categorized_sample_indices: SamplingType -> token indices to sample.\n            Each token indices is 2D tensor of (num_indices, num_indices) where\n            the first item means the sample index within the returned logit\n            (before pruning padding), and the second item means the sample\n            index after pruning using selected_token_indices.\n            For example, if the returned logit is [1, 2, 3], and we select\n            [1, 2] for sampling, the pruned logit will be [2, 3]. In this case,\n            The first tuple is [1, 2] (sampled index within original logit),\n            and the second tuple is [0, 1] (sampled index within pruned logit).\n        num_prompts: Number of prompt sequence groups in seq_groups.\n        skip_sampler_cpu_output: Indicates if we want to skip the GPU=>CPU \n            serialization of token outputs.\n        reuse_sampling_tensors: Indicates if we want to reuse sampling \n            tensors that are part of the sampler forward pass. Currently,\n            it is mainly used for multi-step decode.\n            \n    \"\"\"\n\n    def __init__(\n        self,\n        seq_groups: List[SequenceGroupToSample],\n        selected_token_indices: torch.Tensor,\n        categorized_sample_indices: Dict[SamplingType, torch.Tensor],\n        num_prompts: int,\n        skip_sampler_cpu_output: bool = False,\n        reuse_sampling_tensors: bool = False,\n    ) -> None:\n        self.seq_groups = seq_groups\n        self.selected_token_indices = selected_token_indices\n        self.categorized_sample_indices = categorized_sample_indices\n        self.num_prompts = num_prompts\n        self.skip_sampler_cpu_output = skip_sampler_cpu_output\n        self.reuse_sampling_tensors = reuse_sampling_tensors\n\n    @staticmethod\n    def prepare(\n        seq_group_metadata_list: List[SequenceGroupMetadata],\n        seq_lens: List[int],\n        query_lens: Optional[List[int]],\n        device: str,\n        pin_memory: bool,\n    ) -> \"SamplingMetadata\":\n        (\n            seq_groups,\n            selected_token_indices,\n            categorized_sample_indices,\n            num_prompts,\n        ) = _prepare_seq_groups(seq_group_metadata_list, seq_lens, query_lens,\n                                device)\n        selected_token_indices = async_tensor_h2d(selected_token_indices,\n                                                  dtype=torch.long,\n                                                  target_device=device,\n                                                  pin_memory=pin_memory)\n        categorized_sample_indices = {\n            t: maybe_expand_dim(\n                async_tensor_h2d(seq_ids,\n                                 dtype=torch.int,\n                                 target_device=device,\n                                 pin_memory=pin_memory), 2, 2)\n            for t, seq_ids in categorized_sample_indices.items()\n        }\n\n        sampling_metadata = SamplingMetadata(\n            seq_groups=seq_groups,\n            selected_token_indices=selected_token_indices,\n            categorized_sample_indices=categorized_sample_indices,\n            num_prompts=num_prompts,\n        )\n        return sampling_metadata\n\n    def __repr__(self) -> str:\n        return (\n            \"SamplingMetadata(\"\n            f\"seq_groups={self.seq_groups}, \"\n            f\"selected_token_indices={self.selected_token_indices}, \"\n            f\"categorized_sample_indices={self.categorized_sample_indices}), \")\n\n\ndef _prepare_seq_groups(\n    seq_group_metadata_list: List[SequenceGroupMetadata],\n    seq_lens: List[int],\n    query_lens: Optional[List[int]],\n    device: str,\n) -> Tuple[List[SequenceGroupToSample], List[int], Dict[\n        SamplingType, List[Tuple[int, int]]], int]:\n    \"\"\"Prepare sequence groups and indices for sampling.\n\n    Args:\n        seq_group_metadata_list: A list of sequence group to batch.\n        seq_lens: A list of sequence lens per sequence group.\n            Index of prompt len should match with seq_group_metadata_list.\n        query_lens: A list of query lengths. Prompt lens include the length\n            of entire prompt tokens, and it could be shorter.\n        device: A device to use for random number generator,\n            `SequenceGroupToSample.generator`.\n\n    Returns:\n        seq_groups: A list of sequence group to sample.\n        selected_token_indices: See the definition from `SamplingMetadata`.\n        categorized_sample_indices: See the definition from `SamplingMetadata`.\n        num_prompts: Total number of prompts from `seq_group_metadata_list`.\n    \"\"\"\n    # Batched sequence groups for the current model forward stsep.\n    seq_groups: List[SequenceGroupToSample] = []\n    # A list of token indices to sample/compute logprob. It is used to\n    # prune the outcome logits from the model for the performance.\n    selected_token_indices: List[int] = []\n    # Used for selected_token_indices.\n    model_output_idx = 0\n\n    # Sampling type -> (\n    # indices to sample/prompt logprob within pruned output logits,\n    # indices to sample within pruned logits)\n    categorized_sample_indices: Dict[SamplingType, List[Tuple[int, int]]] = {\n        t: []\n        for t in SamplingType\n    }\n    # Index of logits to compute logprob. Logits include both prompt logprob\n    # and sample logprob indices.\n    logit_idx = 0\n    # Index to sample from a sample tensor. It is used by triton sample kernel.\n    # See `_sample_with_triton_kernel` for more details.\n    sample_idx = 0\n    # Total number of prompts from given sequence groups.\n    num_prompts = 0\n\n    for i, seq_group_metadata in enumerate(seq_group_metadata_list):\n        seq_ids = list(seq_group_metadata.seq_data.keys())\n        sampling_params = seq_group_metadata.sampling_params\n        is_prompt = seq_group_metadata.is_prompt\n        generator: Optional[torch.Generator] = None\n        # If the current seq group is in decode stage, it is None.\n        seq_len: Optional[int] = None\n        query_len: Optional[int] = None\n        prompt_logprob_indices: List[int] = []\n        sample_indices: List[int] = []\n        do_sample = seq_group_metadata.do_sample\n\n        if seq_group_metadata.is_prompt:\n            if sampling_params.seed is not None:\n                seq_group_metadata.state.generator = torch.Generator(\n                    device=device).manual_seed(sampling_params.seed)\n\n            num_prompts += 1\n            num_prefill_sample = len(seq_ids)\n            assert num_prefill_sample == 1\n            assert query_lens is not None and seq_lens is not None\n            query_len, seq_len = query_lens[i], seq_lens[i]\n            # If we need sampling, exclude num_prefill_sample tokens from\n            # prompt logprob.\n            prompt_logprob_len = (query_len - num_prefill_sample\n                                  if do_sample else query_len)\n            sample_len = num_prefill_sample if do_sample else 0\n        else:\n            # Decode\n            prompt_logprob_len = 0\n            sample_len = len(seq_ids) if do_sample else 0\n\n        # Update indices to select from the model output.\n        \"\"\"\n        This blocks computes selected_token_indices which is used in the\n        following way.\n\n        hidden_states = model(...)\n        logits = hidden_states[selected_token_indices]\n        \"\"\"\n\n        if sampling_params.prompt_logprobs is not None:\n            selected_token_indices.extend(\n                range(model_output_idx, model_output_idx + prompt_logprob_len))\n        model_output_idx += prompt_logprob_len\n        if do_sample:\n            selected_token_indices.extend(\n                range(model_output_idx, model_output_idx + sample_len))\n        model_output_idx += sample_len\n\n        # We now find indices for logprob computation and sampling.\n        \"\"\"\n        This block computes categorized_sample_indices which is used in the\n        following way.\n\n        hidden_states = model(...)\n        logits = hidden_states[selected_token_indices]\n        def sample(logits):\n           # Use categorized_sample_indices for sampling.\n           # prompt_logprob_indices to find prompt logprob indices.\n           # sample_indices to find sample indices.\n        \"\"\"\n\n        if sampling_params.prompt_logprobs is not None:\n            prompt_logprob_indices.extend(\n                range(logit_idx, logit_idx + prompt_logprob_len))\n            logit_idx += prompt_logprob_len\n        if do_sample:\n            sample_indices.extend(range(logit_idx, logit_idx + sample_len))\n            categorized_sample_indices[sampling_params.sampling_type].extend(\n                list(\n                    zip(range(logit_idx, logit_idx + sample_len),\n                        range(sample_idx, sample_idx + sample_len))))\n            logit_idx += sample_len\n            sample_idx += sample_len\n\n        if sampling_params.seed is not None:\n            generator = seq_group_metadata.state.generator\n\n        seq_groups.append(\n            SequenceGroupToSample(\n                seq_ids=seq_ids,\n                sampling_params=sampling_params,\n                seq_data=seq_group_metadata.seq_data,\n                seq_len=seq_len,\n                query_len=query_len,\n                generator=generator,\n                is_prompt=is_prompt,\n                prompt_logprob_indices=list(prompt_logprob_indices),\n                sample_indices=list(sample_indices)))\n    return (seq_groups, selected_token_indices, categorized_sample_indices,\n            num_prompts)\n\n\n@dataclass\nclass SamplingTensors:\n    \"\"\"Tensors for sampling.\"\"\"\n\n    temperatures: torch.Tensor\n    top_ps: torch.Tensor\n    top_ks: torch.Tensor\n    min_ps: torch.Tensor\n    presence_penalties: torch.Tensor\n    frequency_penalties: torch.Tensor\n    repetition_penalties: torch.Tensor\n    sampling_seeds: torch.Tensor\n    sample_indices: torch.Tensor\n    extra_seeds: Optional[torch.Tensor]\n    prompt_tokens: torch.Tensor\n    output_tokens: torch.Tensor\n\n    @classmethod\n    def from_sampling_metadata(\n        cls,\n        sampling_metadata: \"SamplingMetadata\",\n        vocab_size: int,\n        device: torch.device,\n        dtype: torch.dtype,\n        *,\n        extra_seeds_to_generate: int = 0,\n        extra_entropy: Optional[Tuple[int, ...]] = None\n    ) -> Tuple[\"SamplingTensors\", bool, bool, bool]:\n        \"\"\"\n        extra_seeds_to_generate: extra seeds to generate using the\n            user-defined seed for each sequence.\n        extra_entropy: extra entropy to use when generating seeds.\n        \"\"\"\n        prompt_tokens: List[List[int]] = []\n        output_tokens: List[List[int]] = []\n        top_ks: List[int] = []\n        temperatures: List[float] = []\n        top_ps: List[float] = []\n        min_ps: List[float] = []\n        presence_penalties: List[float] = []\n        frequency_penalties: List[float] = []\n        repetition_penalties: List[float] = []\n        sampling_seeds: List[int] = []\n        sample_indices: List[int] = []\n        prompt_best_of: List[int] = []\n        do_penalties = False\n        do_top_p_top_k = False\n        do_min_p = False\n\n        # We need one base seed per Triton slice.\n        seeds_to_generate = (extra_seeds_to_generate +\n                             get_num_triton_sampler_splits(vocab_size))\n\n        assert sampling_metadata.seq_groups is not None\n        for seq_group in sampling_metadata.seq_groups:\n            seq_ids = seq_group.seq_ids\n            sampling_params = seq_group.sampling_params\n            temperature = sampling_params.temperature\n            p = sampling_params.presence_penalty\n            f = sampling_params.frequency_penalty\n            r = sampling_params.repetition_penalty\n            top_p = sampling_params.top_p\n            min_p = sampling_params.min_p\n            seed = sampling_params.seed\n\n            is_greedy = sampling_params.sampling_type == SamplingType.GREEDY\n\n            # k should not be greater than the vocab size.\n            top_k = min(sampling_params.top_k, vocab_size)\n            top_k = vocab_size if top_k == -1 else top_k\n            if temperature < _SAMPLING_EPS:\n                # NOTE: Zero temperature means deterministic sampling\n                # (i.e., greedy sampling or beam search).\n                # Set the temperature to 1 to avoid division by zero.\n                temperature = 1.0\n            if not do_top_p_top_k and (top_p < 1.0 - _SAMPLING_EPS\n                                       or top_k != vocab_size):\n                do_top_p_top_k = True\n            if not do_min_p and min_p > _SAMPLING_EPS:\n                do_min_p = True\n            if not do_penalties and (abs(p) >= _SAMPLING_EPS\n                                     or abs(f) >= _SAMPLING_EPS\n                                     or abs(r - 1.0) >= _SAMPLING_EPS):\n                do_penalties = True\n\n            is_prompt = seq_group.is_prompt\n            if (seq_group.is_prompt\n                    and sampling_params.prompt_logprobs is not None):\n                # For tokens in the prompt that we only need to get\n                # their logprobs\n                query_len = seq_group.query_len\n                assert query_len is not None\n                prefill_len = len(seq_group.prompt_logprob_indices)\n                temperatures += [temperature] * prefill_len\n                top_ps += [top_p] * prefill_len\n                top_ks += [top_k] * prefill_len\n                min_ps += [min_p] * prefill_len\n                presence_penalties += [0] * prefill_len\n                frequency_penalties += [0] * prefill_len\n                repetition_penalties += [1] * prefill_len\n\n            if seq_group.do_sample:\n                sample_lens = len(seq_group.sample_indices)\n                assert sample_lens == len(seq_ids)\n                temperatures += [temperature] * len(seq_ids)\n                top_ps += [top_p] * len(seq_ids)\n                top_ks += [top_k] * len(seq_ids)\n                min_ps += [min_p] * len(seq_ids)\n                presence_penalties += [p] * len(seq_ids)\n                frequency_penalties += [f] * len(seq_ids)\n                repetition_penalties += [r] * len(seq_ids)\n\n            if is_prompt:\n                prompt_best_of.append(sampling_params.best_of)\n                query_len = seq_group.query_len\n                assert query_len is not None\n\n            for seq_id in seq_ids:\n                seq_data = seq_group.seq_data[seq_id]\n                extra_entropy = extra_entropy or ()\n                seq_seeds = cls._get_sequence_seeds(\n                    seed,\n                    seq_data.get_len(),\n                    *extra_entropy,\n                    seq_id,\n                    seeds_to_generate=seeds_to_generate,\n                    is_greedy=is_greedy)\n                sampling_seeds.append(seq_seeds)\n            sample_indices.extend(seq_group.sample_indices)\n\n        if do_penalties:\n            for seq_group in sampling_metadata.seq_groups:\n                seq_ids = seq_group.seq_ids\n                if (seq_group.is_prompt\n                        and sampling_params.prompt_logprobs is not None):\n                    prefill_len = len(seq_group.prompt_logprob_indices)\n                    prompt_tokens.extend([] for _ in range(prefill_len))\n                    output_tokens.extend([] for _ in range(prefill_len))\n                if seq_group.do_sample:\n                    for seq_id in seq_ids:\n                        seq_data = seq_group.seq_data[seq_id]\n                        prompt_tokens.append(list(seq_data.prompt_token_ids))\n                        output_tokens.append(list(seq_data.output_token_ids))\n\n        sampling_tensors = SamplingTensors.from_lists(\n            temperatures, top_ps, top_ks, min_ps, presence_penalties,\n            frequency_penalties, repetition_penalties, sampling_seeds,\n            sample_indices, prompt_tokens, output_tokens, vocab_size,\n            extra_seeds_to_generate, device, dtype)\n        return (sampling_tensors, do_penalties, do_top_p_top_k, do_min_p)\n\n    @classmethod\n    def from_lists(cls, temperatures: List[float], top_ps: List[float],\n                   top_ks: List[int], min_ps: List[float],\n                   presence_penalties: List[float],\n                   frequency_penalties: List[float],\n                   repetition_penalties: List[float],\n                   sampling_seeds: List[int], sample_indices: List[int],\n                   prompt_tokens: List[List[int]],\n                   output_tokens: List[List[int]], vocab_size: int,\n                   extra_seeds_to_generate: int, device: torch.device,\n                   dtype: torch.dtype) -> \"SamplingTensors\":\n        # Note that the performance will be very bad without\n        # pinned memory.\n        pin_memory = is_pin_memory_available()\n\n        do_penalties = prompt_tokens or output_tokens\n\n        if do_penalties:\n            prompt_t = make_tensor_with_pad(\n                prompt_tokens,\n                vocab_size,\n                device=\"cpu\",\n                dtype=torch.int64,\n                pin_memory=pin_memory,\n            )\n            output_t = make_tensor_with_pad(\n                output_tokens,\n                vocab_size,\n                device=\"cpu\",\n                dtype=torch.int64,\n                pin_memory=pin_memory,\n            )\n        else:\n            empty_tensor = torch.empty(0, device=device, dtype=torch.long)\n            prompt_t = empty_tensor\n            output_t = empty_tensor\n\n        temperatures_t = torch.tensor(\n            temperatures,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        top_ps_t = torch.tensor(\n            top_ps,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        min_ps_t = torch.tensor(\n            min_ps,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        presence_penalties_t = torch.tensor(\n            presence_penalties,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        frequency_penalties_t = torch.tensor(\n            frequency_penalties,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        repetition_penalties_t = torch.tensor(\n            repetition_penalties,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        top_ks_t = torch.tensor(\n            top_ks,\n            device=\"cpu\",\n            dtype=torch.int,\n            pin_memory=pin_memory,\n        )\n        sample_indices_t = torch.tensor(\n            sample_indices,\n            device=\"cpu\",\n            dtype=torch.long,\n            pin_memory=pin_memory,\n        )\n        # need to transpose and make contiguous to\n        # copy the tensor correctly.\n        # [batch_size, n_seeds] -> [n_seeds, batch_size]\n        sampling_seeds_t = torch.tensor(\n            sampling_seeds,\n            device=\"cpu\",\n            dtype=torch.long,\n            pin_memory=pin_memory,\n        ).T.contiguous()\n\n        # Because the memory is pinned, we can do non-blocking\n        # transfer to device.\n\n        # How many seeds the sample operation itself will need.\n        num_base_seeds = sampling_seeds_t.shape[0] - extra_seeds_to_generate\n        sampling_seeds_gpu = sampling_seeds_t.to(device=device,\n                                                 non_blocking=True)\n        extra_seeds_gpu = sampling_seeds_gpu[num_base_seeds:]\n        if not extra_seeds_gpu.numel():\n            extra_seeds_gpu = None\n        sampling_seeds_gpu = sampling_seeds_gpu[:num_base_seeds]\n\n        return cls(\n            temperatures=temperatures_t.to(device=device, non_blocking=True),\n            top_ps=top_ps_t.to(device=device, non_blocking=True),\n            top_ks=top_ks_t.to(device=device, non_blocking=True),\n            min_ps=min_ps_t.to(device=device, non_blocking=True),\n            presence_penalties=presence_penalties_t.to(device=device,\n                                                       non_blocking=True),\n            frequency_penalties=frequency_penalties_t.to(device=device,\n                                                         non_blocking=True),\n            repetition_penalties=repetition_penalties_t.to(device=device,\n                                                           non_blocking=True),\n            prompt_tokens=prompt_t.to(device=device, non_blocking=True),\n            output_tokens=output_t.to(device=device, non_blocking=True),\n            sampling_seeds=sampling_seeds_gpu,\n            sample_indices=sample_indices_t.to(device=device,\n                                               non_blocking=True),\n            extra_seeds=extra_seeds_gpu,\n        )\n\n    @staticmethod\n    def _get_sequence_seeds(\n        seed: int,\n        *extra_entropy: int,\n        seeds_to_generate: int,\n        is_greedy: bool,\n    ):\n        \"\"\"Get `seeds_to_generate` child seeds from `seed` and extra entropy.\"\"\"\n        if not is_greedy:\n            if seed is None:\n                randint_fn = random.randint\n            else:\n                generator = random.Random(str((seed, ) + extra_entropy))\n                randint_fn = generator.randint\n            lo, hi = torch.iinfo(torch.long).min, torch.iinfo(torch.long).max\n            # If the user/random sets seed = 0 but request should\n            # have sampling, we need to change it to something\n            # else. We use a constant in that case.\n            # This way we don't need to create and load a bool\n            # matrix in the sampling kernel, which reduces CPU\n            # overhead and latency.\n            seq_seeds = [\n                randint_fn(lo, hi) or _SEED_0_REPLACEMENT\n                for _ in range(seeds_to_generate)\n            ]\n        else:\n            # For the kernel, seed == 0 means greedy decoding.\n            seq_seeds = [0] * seeds_to_generate\n        return seq_seeds\n",
      "diff": "diff --git a/vllm/model_executor/sampling_metadata.py b/vllm/model_executor/sampling_metadata.py\nindex 390b5d173..27b37a9d5 100644\n--- a/vllm/model_executor/sampling_metadata.py\n+++ b/vllm/model_executor/sampling_metadata.py\n@@ -1,4 +1,5 @@\n import random\n+from array import array\n from dataclasses import dataclass\n from typing import Dict, List, Optional, Tuple\n \n@@ -329,8 +330,8 @@ class SamplingTensors:\n             user-defined seed for each sequence.\n         extra_entropy: extra entropy to use when generating seeds.\n         \"\"\"\n-        prompt_tokens: List[List[int]] = []\n-        output_tokens: List[List[int]] = []\n+        prompt_tokens: List[array] = []\n+        output_tokens: List[array] = []\n         top_ks: List[int] = []\n         temperatures: List[float] = []\n         top_ps: List[float] = []\n@@ -432,13 +433,15 @@ class SamplingTensors:\n                 if (seq_group.is_prompt\n                         and sampling_params.prompt_logprobs is not None):\n                     prefill_len = len(seq_group.prompt_logprob_indices)\n-                    prompt_tokens.extend([] for _ in range(prefill_len))\n-                    output_tokens.extend([] for _ in range(prefill_len))\n+                    prompt_tokens.extend(\n+                        array('l') for _ in range(prefill_len))\n+                    output_tokens.extend(\n+                        array('l') for _ in range(prefill_len))\n                 if seq_group.do_sample:\n                     for seq_id in seq_ids:\n                         seq_data = seq_group.seq_data[seq_id]\n-                        prompt_tokens.append(list(seq_data.prompt_token_ids))\n-                        output_tokens.append(list(seq_data.output_token_ids))\n+                        prompt_tokens.append(seq_data.prompt_token_ids_array)\n+                        output_tokens.append(seq_data.output_token_ids_array)\n \n         sampling_tensors = SamplingTensors.from_lists(\n             temperatures, top_ps, top_ks, min_ps, presence_penalties,\n@@ -454,9 +457,9 @@ class SamplingTensors:\n                    frequency_penalties: List[float],\n                    repetition_penalties: List[float],\n                    sampling_seeds: List[int], sample_indices: List[int],\n-                   prompt_tokens: List[List[int]],\n-                   output_tokens: List[List[int]], vocab_size: int,\n-                   extra_seeds_to_generate: int, device: torch.device,\n+                   prompt_tokens: List[array], output_tokens: List[array],\n+                   vocab_size: int, extra_seeds_to_generate: int,\n+                   device: torch.device,\n                    dtype: torch.dtype) -> \"SamplingTensors\":\n         # Note that the performance will be very bad without\n         # pinned memory.",
      "change_type": "modified",
      "lines_added": 13,
      "lines_removed": 10
    },
    {
      "file_path": "vllm/sequence.py",
      "old_content": "\"\"\"Sequence and its related classes.\"\"\"\nimport copy\nimport enum\nimport math\nfrom abc import ABC, abstractmethod\nfrom collections import defaultdict\nfrom dataclasses import dataclass, field\nfrom typing import (TYPE_CHECKING, Dict, List, Mapping, Optional, Set, Tuple,\n                    Union)\n\nimport torch\n\nfrom vllm.lora.request import LoRARequest\nfrom vllm.pooling_params import PoolingParams\nfrom vllm.prompt_adapter.request import PromptAdapterRequest\nfrom vllm.sampling_params import SamplingParams\n\nif TYPE_CHECKING:\n    from vllm.inputs import LLMInputs\n    from vllm.multimodal import MultiModalDataDict\n    from vllm.spec_decode.metrics import SpecDecodeWorkerMetrics\n\n\n@dataclass\nclass Logprob:\n    \"\"\"Infos for supporting OpenAI compatible logprobs and token ranks.\n\n    Attributes:\n        logprob: The logprob of chosen token\n        rank: The vocab rank of chosen token (>=1)\n        decoded_token: The decoded chosen token index\n    \"\"\"\n    logprob: float\n    rank: Optional[int] = None\n    decoded_token: Optional[str] = None\n\n\n# {token_id -> logprob} per each sequence group. None if the corresponding\n# sequence group doesn't require prompt logprob.\nPromptLogprobs = List[Optional[Dict[int, Logprob]]]\n# {token_id -> logprob} for each sequence group.\nSampleLogprobs = List[Dict[int, Logprob]]\n\n\nclass SequenceStatus(enum.IntEnum):\n    \"\"\"Status of a sequence.\"\"\"\n    WAITING = 0\n    RUNNING = 1\n    SWAPPED = 2\n    # Note: anything after SWAPPED (2) will be considered\n    # as a finished status.\n    FINISHED_STOPPED = 3\n    FINISHED_LENGTH_CAPPED = 4\n    FINISHED_ABORTED = 5\n    FINISHED_IGNORED = 6\n\n    @staticmethod\n    def is_finished(status: \"SequenceStatus\") -> bool:\n        return status > SequenceStatus.SWAPPED\n\n    @staticmethod\n    def get_finished_reason(status: \"SequenceStatus\") -> Union[str, None]:\n        if status == SequenceStatus.FINISHED_STOPPED:\n            finish_reason = \"stop\"\n        elif status == SequenceStatus.FINISHED_LENGTH_CAPPED:\n            finish_reason = \"length\"\n        elif status == SequenceStatus.FINISHED_ABORTED:\n            finish_reason = \"abort\"\n        elif status == SequenceStatus.FINISHED_IGNORED:\n            # The ignored sequences are the sequences whose prompt lengths\n            # are longer than the model's length cap. Therefore, the stop\n            # reason should also be \"length\" as in OpenAI API.\n            finish_reason = \"length\"\n        else:\n            finish_reason = None\n        return finish_reason\n\n\nclass SequenceStage(enum.Enum):\n    PREFILL = enum.auto()\n    DECODE = enum.auto()\n\n\n@dataclass\nclass RequestMetrics:\n    \"\"\"Metrics associated with a request.\n\n    Attributes:\n        arrival_time: The time when the request arrived.\n        first_scheduled_time: The time when the request was first scheduled.\n        first_token_time: The time when the first token was generated.\n        time_in_queue: The time the request spent in the queue.\n        finished_time: The time when the request was finished.\n    \"\"\"\n    arrival_time: float\n    last_token_time: float\n    first_scheduled_time: Optional[float]\n    first_token_time: Optional[float]\n    time_in_queue: Optional[float]\n    finished_time: Optional[float] = None\n\n\nclass SequenceData:\n    \"\"\"Data associated with a sequence.\n\n    Args:\n        prompt_token_ids: The token IDs of the prompt.\n        output_token_ids: The token IDs of the output. Set to an empty list if\n            None.\n\n    Attributes:\n        prompt_token_ids: The token IDs of the prompt.\n        output_token_ids: The token IDs of the output.\n        cumulative_logprob: The cumulative log probability of the output.\n    \"\"\"\n\n    def __init__(\n        self,\n        prompt_token_ids: List[int],\n        output_token_ids: Optional[List[int]] = None,\n    ) -> None:\n        self._prompt_token_ids: List[int] = list(prompt_token_ids)\n        self._prompt_token_ids_tuple: Tuple[int, ...] = tuple(prompt_token_ids)\n        self._output_token_ids: List[int] = (\n            list(output_token_ids) if output_token_ids is not None else [])\n\n        self.cumulative_logprob = 0.0\n        # The number of tokens that are computed (that run against the model).\n        self._num_computed_tokens = 0\n        self._stage: SequenceStage = SequenceStage.PREFILL\n\n        self._update_cached_all_tokens()\n\n    def _update_cached_all_tokens(self):\n        self._cached_all_token_ids: List[int] = (self._prompt_token_ids +\n                                                 self._output_token_ids)\n\n    @property\n    def prompt_token_ids(self) -> Tuple[int, ...]:\n        return self._prompt_token_ids_tuple\n\n    @prompt_token_ids.setter\n    def prompt_token_ids(self, new_prompt_token_ids) -> None:\n        self._prompt_token_ids = list(new_prompt_token_ids)\n        self._prompt_token_ids_tuple = tuple(new_prompt_token_ids)\n        self._update_cached_all_tokens()\n\n    @property\n    def output_token_ids(self) -> Tuple[int, ...]:\n        return tuple(self._output_token_ids)\n\n    @output_token_ids.setter\n    def output_token_ids(self, new_output_token_ids) -> None:\n        self._output_token_ids = list(new_output_token_ids)\n        self._update_cached_all_tokens()\n\n    def append_token_id(self, token_id: int, logprob: float) -> None:\n        self._output_token_ids.append(token_id)\n        self._cached_all_token_ids.append(token_id)\n        self.cumulative_logprob += logprob\n\n    def get_len(self) -> int:\n        return len(self._output_token_ids) + len(self._prompt_token_ids)\n\n    def get_prompt_len(self) -> int:\n        return len(self._prompt_token_ids)\n\n    def get_output_len(self) -> int:\n        return len(self._output_token_ids)\n\n    def get_token_ids(self) -> List[int]:\n        return self._cached_all_token_ids\n\n    def get_prefix_token_ids(\n            self, num_tokens: int\n    ) -> Tuple[Tuple[int, ...], Optional[Tuple[int, ...]]]:\n        \"\"\"Get prefix tokens, and make the return value hashable\"\"\"\n        prompt_length = self.get_prompt_len()\n        if num_tokens > prompt_length:\n            return (self._prompt_token_ids_tuple,\n                    tuple(self._output_token_ids[:num_tokens - prompt_length]))\n        else:\n            return (self._prompt_token_ids_tuple[:num_tokens], None)\n\n    def get_num_computed_tokens(self) -> int:\n        \"\"\"Return the number of prefill tokens that are already computed.\"\"\"\n        return self._num_computed_tokens\n\n    def update_num_computed_tokens(self, num_new_computed_tokens: int):\n        \"\"\"Update number of tokens computed so far.\"\"\"\n        self._num_computed_tokens += num_new_computed_tokens\n        assert self._num_computed_tokens <= self.get_len(), (\n            self._num_computed_tokens, self.get_len())\n        # If all tokens are computed, it means it is in decoding phase.\n        if self.get_num_uncomputed_tokens() == 0:\n            self._stage = SequenceStage.DECODE\n\n    def reset_state_for_recompute(self) -> None:\n        \"\"\"Reset the number of computed tokens from this sequence. It is\n        supposed to be called when a sequence needs to be started from\n        the beginning again (e.g., sequence is preempted).\n        \"\"\"\n        self._num_computed_tokens = 0\n        self._stage = SequenceStage.PREFILL\n\n    def get_num_uncomputed_tokens(self) -> int:\n        \"\"\"Return the number of prefill tokens that are not computed.\"\"\"\n        # we use `get_len()` which includes prompt_len + output_len instead\n        # of prompt_len here. This is because during recompute we need to\n        # prefill for both prompt and output.\n        return self.get_len() - self.get_num_computed_tokens()\n\n    def get_last_token_id(self) -> int:\n        if not self._output_token_ids:\n            return self._prompt_token_ids[-1]\n        return self._output_token_ids[-1]\n\n    def get_prompt_token_ids(self) -> Tuple[int, ...]:\n        return self.prompt_token_ids\n\n    def get_output_token_ids(self) -> Tuple[int, ...]:\n        return self.output_token_ids\n\n    @property\n    def stage(self) -> SequenceStage:\n        return self._stage\n\n    def __repr__(self) -> str:\n        return (f\"SequenceData(\"\n                f\"prompt_token_ids={self._prompt_token_ids}, \"\n                f\"output_token_ids={self._output_token_ids}, \"\n                f\"cumulative_logprob={self.cumulative_logprob})\")\n\n\nclass Sequence:\n    \"\"\"Stores the data, status, and block information of a sequence.\n\n    Args:\n        seq_id: The ID of the sequence.\n        inputs: The inputs of the sequence.\n        block_size: The block size of the sequence. Should be the same as the\n            block size used by the block manager and cache engine.\n        lora_request: LoRA request.\n        prompt_adapter_request: Prompt Adapter request.\n\n    \"\"\"\n\n    def __init__(\n            self,\n            seq_id: int,\n            inputs: \"LLMInputs\",\n            block_size: int,\n            eos_token_id: Optional[int] = None,\n            lora_request: Optional[LoRARequest] = None,\n            prompt_adapter_request: Optional[PromptAdapterRequest] = None\n    ) -> None:\n        self.seq_id = seq_id\n        self.inputs = inputs\n        self.block_size = block_size\n        self.eos_token_id = eos_token_id\n        self.lora_request = lora_request\n        self.prompt_adapter_request = prompt_adapter_request\n\n        self.data = SequenceData(self.prompt_token_ids)\n        self.output_logprobs: SampleLogprobs = []\n        self.output_text = \"\"\n\n        self.status = SequenceStatus.WAITING\n        self.stop_reason: Union[int, str, None] = None\n\n        # Used for incremental detokenization\n        self.prefix_offset = 0\n        self.read_offset = 0\n        # Input + output tokens\n        self.tokens: Optional[List[str]] = None\n\n    @property\n    def n_blocks(self) -> int:\n        return math.ceil(self.get_len() / self.block_size)\n\n    @property\n    def prompt(self) -> Optional[str]:\n        return self.inputs.get(\"prompt\")\n\n    @property\n    def prompt_token_ids(self) -> List[int]:\n        return self.inputs[\"prompt_token_ids\"]\n\n    @property\n    def multi_modal_data(self) -> \"MultiModalDataDict\":\n        return self.inputs.get(\"multi_modal_data\") or {}\n\n    @property\n    def lora_int_id(self) -> int:\n        return self.lora_request.lora_int_id if self.lora_request else 0\n\n    @property\n    def prompt_adapter_id(self) -> int:\n        return self.prompt_adapter_request.prompt_adapter_id \\\n                        if self.prompt_adapter_request else 0\n\n    def get_output_text_to_return(self, buffer_length: int):\n        # We return the full output text if the sequence is finished.\n        truncate = buffer_length and not self.is_finished()\n        return self.output_text[:-buffer_length] if truncate else (\n            self.output_text)\n\n    def hash_of_block(self, logical_idx: int) -> int:\n        # TODO This can produce incorrect hash when block size > prompt size\n\n        # Compute the number of tokens in the sequence\n        # TODO: The current hashing function is O(L^2). We should optimize\n        # this in the future.\n        num_tokens = self.num_hashed_tokens_of_block(logical_idx)\n        hashed_tokens = self.data.get_prefix_token_ids(num_tokens)\n        return hash((hashed_tokens, self.lora_int_id))\n\n    def num_hashed_tokens_of_block(self, logical_idx: int):\n        return logical_idx * self.block_size + self.block_size\n\n    def reset_state_for_recompute(self):\n        \"\"\"Reset the sequence states for recomputation.\"\"\"\n        self.data.reset_state_for_recompute()\n\n    def append_token_id(\n        self,\n        token_id: int,\n        logprobs: Dict[int, Logprob],\n    ) -> None:\n        assert token_id in logprobs\n        self.output_logprobs.append(logprobs)\n        self.data.append_token_id(token_id, logprobs[token_id].logprob)\n\n    def get_len(self) -> int:\n        return self.data.get_len()\n\n    def get_prompt_len(self) -> int:\n        return self.data.get_prompt_len()\n\n    def get_output_len(self) -> int:\n        return self.data.get_output_len()\n\n    def get_token_ids(self) -> List[int]:\n        return self.data.get_token_ids()\n\n    def get_prompt_token_ids(self) -> Tuple[int, ...]:\n        return self.data.get_prompt_token_ids()\n\n    def get_last_token_id(self) -> int:\n        return self.data.get_last_token_id()\n\n    def get_output_token_ids(self) -> Tuple[int, ...]:\n        return self.data.get_output_token_ids()\n\n    def get_cumulative_logprob(self) -> float:\n        return self.data.cumulative_logprob\n\n    def get_beam_search_score(self,\n                              length_penalty: float = 1.0,\n                              seq_len: Optional[int] = None,\n                              eos_token_id: Optional[int] = None) -> float:\n        \"\"\"Calculate the beam search score with length penalty.\n\n        Adapted from\n\n        https://github.com/huggingface/transformers/blob/ccb92be23def445f2afdea94c31286f84b89eb5b/src/transformers/generation/beam_search.py#L938\n        \"\"\"\n        if seq_len is None:\n            seq_len = self.get_len()\n            # NOTE: HF implementation does not count the EOS token\n            # towards the length, we align with that here for testing.\n            if (eos_token_id is not None\n                    and self.get_last_token_id() == eos_token_id):\n                seq_len -= 1\n        return self.get_cumulative_logprob() / (seq_len**length_penalty)\n\n    def is_finished(self) -> bool:\n        return SequenceStatus.is_finished(self.status)\n\n    def fork(self, new_seq_id: int) -> \"Sequence\":\n        new_seq = copy.deepcopy(self)\n        new_seq.seq_id = new_seq_id\n        return new_seq\n\n    def get_num_new_tokens(self) -> int:\n        \"\"\"Get the number of new tokens to be computed.\n\n        Returns:\n            The new number of tokens to be computed. I.e., 1 for decode, or\n            the remaining prompt size for prefill.\n        \"\"\"\n        if self.data.stage == SequenceStage.DECODE:\n            return 1\n        return self.data.get_num_uncomputed_tokens()\n\n    def is_prefill(self) -> bool:\n        return self.data.stage == SequenceStage.PREFILL\n\n    def __repr__(self) -> str:\n        return (f\"Sequence(seq_id={self.seq_id}, \"\n                f\"status={self.status.name}, \"\n                f\"num_blocks={self.n_blocks}, \")\n\n\n@dataclass\nclass SequenceGroupState:\n    \"\"\"Mutable state tied to a specific sequence group\"\"\"\n\n    # torch.Generator used in seeded sampling\n    generator: Optional = None  # type: ignore\n\n\nclass SequenceGroup:\n    \"\"\"A group of sequences that are generated from the same prompt.\n\n    Args:\n        request_id: The ID of the request.\n        seqs: The list of sequences.\n        sampling_params: The sampling parameters used to generate the outputs.\n        arrival_time: The arrival time of the request.\n        lora_request: LoRA request.\n        embeddings: The embeddings vectors of the prompt of the sequence group\n            for an embedding model.\n        pooling_params: The pooling parameters used to generate the pooling\n            for an embedding model.\n        encoder_seq: Optional, the single encoder sequence. Should be None\n                     unless you are working with an encoder/decoder model.\n        trace_headers: OpenTelemetry trace headers.\n        prompt_adapter_request: Prompt Adapter request.\n    \"\"\"\n\n    def __init__(\n        self,\n        request_id: str,\n        seqs: List[Sequence],\n        arrival_time: float,\n        sampling_params: Optional[SamplingParams] = None,\n        lora_request: Optional[LoRARequest] = None,\n        embeddings: Optional[List[float]] = None,\n        pooling_params: Optional[PoolingParams] = None,\n        encoder_seq: Optional[Sequence] = None,\n        trace_headers: Optional[Mapping[str, str]] = None,\n        prompt_adapter_request: Optional[PromptAdapterRequest] = None,\n    ) -> None:\n        self.request_id = request_id\n        self.seqs_dict = {seq.seq_id: seq for seq in seqs}\n        self.sampling_params = sampling_params\n        self.metrics = RequestMetrics(arrival_time=arrival_time,\n                                      last_token_time=arrival_time,\n                                      first_scheduled_time=None,\n                                      first_token_time=None,\n                                      time_in_queue=None)\n        self.lora_request = lora_request\n        self.prompt_logprobs: Optional[PromptLogprobs] = None\n        self.state = SequenceGroupState()\n        self.embeddings = embeddings\n        self.pooling_params = pooling_params\n        self.prompt_adapter_request = prompt_adapter_request\n        self.encoder_seq = encoder_seq\n        self.trace_headers = trace_headers\n        self._first_seq = next(iter(self.seqs_dict.values()))\n\n    @property\n    def prompt(self) -> Optional[str]:\n        # All sequences in the group should have the same prompt.\n        # We use the prompt of an arbitrary sequence.\n        return self._first_seq.prompt\n\n    @property\n    def prompt_token_ids(self) -> List[int]:\n        # All sequences in the group should have the same prompt.\n        # We use the prompt of an arbitrary sequence.\n        return self._first_seq.prompt_token_ids\n\n    @property\n    def multi_modal_data(self) -> \"MultiModalDataDict\":\n        # All sequences in the group should have the same multi-modal data.\n        # We use the multi-modal data of an arbitrary sequence.\n        return self._first_seq.multi_modal_data\n\n    @property\n    def lora_int_id(self) -> int:\n        return self.lora_request.lora_int_id if self.lora_request else 0\n\n    @property\n    def prompt_adapter_id(self) -> int:\n        return self.prompt_adapter_request.prompt_adapter_id \\\n                        if self.prompt_adapter_request else 0\n\n    @property\n    def prompt_adapter_num_virtual_tokens(self) -> int:\n        return self.prompt_adapter_request.prompt_adapter_num_virtual_tokens\\\n                         if self.prompt_adapter_request else 0\n\n    def get_last_latency(self, now: float) -> Optional[float]:\n        \"\"\"Sets the last token time for Request level timings.\"\"\"\n        # If still in prefill phase, raise Error.\n        if self.is_prefill():\n            raise ValueError(\n                \"seq_group.get_last_latency() should not be called \"\n                \"if the seq_group is in prefill phase.\")\n\n        # Otherwise return token latency.\n        latency = now - self.metrics.last_token_time\n        self.metrics.last_token_time = now\n        return latency\n\n    def maybe_set_first_token_time(self, time: float) -> None:\n        \"\"\"Sets the first token time for Request level timings.\"\"\"\n        # Note: in a case where a sequence_group is swapped and\n        #   recomputed, the time between iterations is counted\n        #   in TPOT, rather than recalculating TTFT (since from the )\n        #   POV of the user, there is simply a long generation delay.\n        if (self.metrics.first_token_time is None\n                and self.get_seqs()[0].get_output_len() == 1):\n            self.metrics.first_token_time = time\n\n    def maybe_set_first_scheduled_time(self, time: float) -> None:\n        \"\"\"Sets the first scheduled time and time in queue for Request\n        level timings.\"\"\"\n        if self.metrics.first_scheduled_time is None:\n            self.metrics.first_scheduled_time = time\n            self.metrics.time_in_queue = time - self.metrics.arrival_time\n\n    def set_finished_time(self, time: Optional[float]) -> None:\n        \"\"\"Sets the finished time for Request level timings.\"\"\"\n        self.metrics.finished_time = time\n\n    def get_max_num_running_seqs(self) -> int:\n        \"\"\"The maximum number of sequences running in parallel in the remaining\n        lifetime of the request.\"\"\"\n        if self.sampling_params and self.sampling_params.use_beam_search:\n            # For beam search, maximally there will always be `best_of` beam\n            # candidates running in the future.\n            return self.sampling_params.best_of\n        else:\n            if (self.sampling_params\n                    and self.sampling_params.best_of > self.num_seqs()):\n                # At prompt stage, the sequence group is not yet filled up\n                # and only have one sequence running. However, in the\n                # generation stage, we will have `best_of` sequences running.\n                return self.sampling_params.best_of\n            # At sampling stages, return the number of actual sequences\n            # that are not finished yet.\n            return self.num_unfinished_seqs()\n\n    def get_seqs(\n        self,\n        status: Optional[SequenceStatus] = None,\n    ) -> List[Sequence]:\n        return list(self.seqs_dict.values()) if status is None else [\n            seq for seq in self.seqs_dict.values() if seq.status == status\n        ]\n\n    def is_encoder_decoder(self) -> bool:\n        return self.encoder_seq is not None\n\n    def get_encoder_seq(self) -> Optional[Sequence]:\n        return self.encoder_seq\n\n    def get_unfinished_seqs(self) -> List[Sequence]:\n        return [\n            seq for seq in self.seqs_dict.values() if not seq.is_finished()\n        ]\n\n    def get_finished_seqs(self) -> List[Sequence]:\n        return [seq for seq in self.seqs_dict.values() if seq.is_finished()]\n\n    def update_num_computed_tokens(self, num_new_computed_tokens: int):\n        \"\"\"Update number of tokens computed so far.\"\"\"\n        for seq in self.seqs_dict.values():\n            if not seq.is_finished():\n                seq.data.update_num_computed_tokens(num_new_computed_tokens)\n\n    def get_num_uncomputed_tokens(self) -> int:\n        num_uncomputed_tokens = 0\n        for seq in self.get_seqs():\n            if not seq.is_finished():\n                num_uncomputed_tokens += seq.data.get_num_uncomputed_tokens()\n        return num_uncomputed_tokens\n\n    def num_seqs(self, status: Optional[SequenceStatus] = None) -> int:\n        # Optimization. We don't need to call get_seqs if we don't need to\n        # filter by states.\n        if status is None:\n            return len(self.seqs_dict)\n\n        return len(self.get_seqs(status))\n\n    def num_unfinished_seqs(self) -> int:\n        return len(self.get_unfinished_seqs())\n\n    def num_finished_seqs(self) -> int:\n        return len(self.get_finished_seqs())\n\n    def find(self, seq_id: int) -> Sequence:\n        if seq_id not in self.seqs_dict:\n            raise ValueError(f\"Sequence {seq_id} not found.\")\n        return self.seqs_dict[seq_id]\n\n    def add(self, seq: Sequence) -> None:\n        if seq.seq_id in self.seqs_dict:\n            raise ValueError(f\"Sequence {seq.seq_id} already exists.\")\n        self.seqs_dict[seq.seq_id] = seq\n\n    def remove(self, seq_id: int) -> None:\n        if seq_id not in self.seqs_dict:\n            raise ValueError(f\"Sequence {seq_id} not found.\")\n        del self.seqs_dict[seq_id]\n\n    def is_finished(self) -> bool:\n        return all(seq.is_finished() for seq in self.get_seqs())\n\n    def is_prefill(self) -> bool:\n        # Every sequence should be in the same stage.\n        return self.get_seqs()[0].is_prefill()\n\n    def __repr__(self) -> str:\n        return (f\"SequenceGroup(request_id={self.request_id}, \"\n                f\"sampling_params={self.sampling_params}, \"\n                f\"num_seqs={len(self.seqs_dict)})\")\n\n\nclass SequenceGroupMetadata:\n    \"\"\"Metadata for a sequence group. Used to create `AttentionMetadata`.\n\n    Args:\n        request_id: The ID of the request.\n        is_prompt: Whether the request is at prompt stage.\n        seq_data: The sequence data. (Seq id -> sequence data)\n        sampling_params: The sampling parameters used to generate the outputs.\n        block_tables: The block tables. (Seq id -> list of physical block\n            numbers)\n        do_sample: True if sampling is required. Sampling is not required when\n            e.g., prefill is chunked, and the current iteration only computes\n            query tokens for prefill, we don't need sampling.\n        token_chunk_size: The number of tokens to be processed (per sequence).\n            None if chunking is not required.\n        lora_request: LoRA request.\n        computed_block_nums: The block numbers that are already computed,\n            used in prefix caching.\n        state: Internal state tied to this sequence group.\n        multi_modal_data: Multi modal data.\n        encoder_seq_data: Optional sequence data for encoder prompt\n                          (SequenceGroup.encoder_seq). Should be None \n                          unless you are working with an encoder/decoder\n                          model.\n        cross_block_table: Optional cross-attention block table associated\n                           with the encoder prompt\n                           (SequenceGroup.encoder_seq). Should be None\n                           unless you are working with an encoder/decoder\n                           model.\n        prompt_adapter_request: Prompt Adapter request.\n    \"\"\"\n\n    def __init__(\n        self,\n        request_id: str,\n        is_prompt: bool,\n        seq_data: Dict[int, SequenceData],\n        sampling_params: SamplingParams,\n        block_tables: Dict[int, List[int]],\n        do_sample: bool = True,\n        pooling_params: Optional[PoolingParams] = None,\n        token_chunk_size: Optional[int] = None,\n        lora_request: Optional[LoRARequest] = None,\n        computed_block_nums: Optional[List[int]] = None,\n        state: Optional[SequenceGroupState] = None,\n        multi_modal_data: Optional[\"MultiModalDataDict\"] = None,\n        encoder_seq_data: Optional[SequenceData] = None,\n        cross_block_table: Optional[List[int]] = None,\n        prompt_adapter_request: Optional[PromptAdapterRequest] = None,\n    ) -> None:\n        self.request_id = request_id\n        self.is_prompt = is_prompt\n        self.seq_data = seq_data\n        self.sampling_params = sampling_params\n        self.block_tables = block_tables\n        self.pooling_params = pooling_params\n        self.lora_request = lora_request\n        self.prompt_adapter_request = prompt_adapter_request\n        self.computed_block_nums = computed_block_nums\n        self.multi_modal_data = multi_modal_data\n        self.state = SequenceGroupState() if state is None else state\n        self.encoder_seq_data = encoder_seq_data\n        self.cross_block_table = cross_block_table\n        self._token_chunk_size = token_chunk_size\n        self.do_sample = do_sample\n\n        # The number of speculative tokens adopted in this request.\n        # None means specuative decoding is not used.\n        # Zero means speculative decoding is disabled for some reasons.\n        # TODO: We should maintain this states out of the sequence group.\n        self.num_speculative_tokens = None\n\n        if self._token_chunk_size is None:\n            if is_prompt:\n                self._token_chunk_size = list(seq_data.values())[0].get_len()\n            else:\n                self._token_chunk_size = 1\n\n    @property\n    def lora_int_id(self) -> int:\n        return self.lora_request.lora_int_id if self.lora_request else 0\n\n    @property\n    def prompt_adapter_id(self) -> int:\n        return self.prompt_adapter_request.prompt_adapter_id \\\n                        if self.prompt_adapter_request else 0\n\n    @property\n    def prompt_adapter_num_virtual_tokens(self) -> int:\n        return self.prompt_adapter_request.prompt_adapter_num_virtual_tokens \\\n                        if self.prompt_adapter_request else 0\n\n    @property\n    def token_chunk_size(self) -> int:\n        \"\"\"Return the number of tokens to be processed (chunk size).\"\"\"\n        assert self._token_chunk_size is not None\n        return self._token_chunk_size\n\n\nclass SequenceOutput:\n    \"\"\"The model output associated with a sequence.\n\n    Args:\n        parent_seq_id: The ID of the parent sequence (for forking in beam\n            search).\n        output_token: The output token ID.\n        logprobs: The logprobs of the output token.\n            (Token id -> logP(x_i+1 | x_0, ..., x_i))\n    \"\"\"\n\n    def __init__(\n        self,\n        parent_seq_id: int,\n        output_token: int,\n        logprobs: Dict[int, Logprob],\n    ) -> None:\n        self.parent_seq_id = parent_seq_id\n        self.output_token = output_token\n        self.logprobs = logprobs\n\n    def __repr__(self) -> str:\n        return (f\"SequenceOutput(parent_seq_id={self.parent_seq_id}, \"\n                f\"output_token={self.output_token}, \"\n                f\"logprobs={self.logprobs})\")\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SequenceOutput):\n            raise NotImplementedError()\n        equal = (self.parent_seq_id == other.parent_seq_id\n                 and self.output_token == other.output_token)\n        log_probs_equal = other.logprobs == self.logprobs\n        return equal and log_probs_equal\n\n\nclass SequenceGroupOutput(ABC):\n    \"\"\"The base class for model outputs associated with a sequence group.\"\"\"\n\n    @abstractmethod\n    def __repr__(self) -> str:\n        pass\n\n    @abstractmethod\n    def __eq__(self, other: object) -> bool:\n        pass\n\n\nclass CompletionSequenceGroupOutput(SequenceGroupOutput):\n    \"\"\"The model output associated with a completion sequence group.\"\"\"\n\n    def __init__(\n        self,\n        samples: List[SequenceOutput],\n        prompt_logprobs: Optional[PromptLogprobs],\n    ) -> None:\n        self.samples = samples\n        # Prompt logprob for each prompt query token.\n        self.prompt_logprobs = prompt_logprobs\n\n    def __repr__(self) -> str:\n        return (f\"CompletionSequenceGroupOutput(samples={self.samples}, \"\n                f\"prompt_logprobs={self.prompt_logprobs})\")\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CompletionSequenceGroupOutput):\n            raise NotImplementedError()\n        return (self.samples == other.samples\n                and self.prompt_logprobs == other.prompt_logprobs)\n\n\nclass EmbeddingSequenceGroupOutput(SequenceGroupOutput):\n    \"\"\"The model output associated with an embedding sequence group.\"\"\"\n\n    def __init__(\n        self,\n        embeddings: List[float],\n    ) -> None:\n        self.embeddings = embeddings\n\n    def __repr__(self) -> str:\n        return (f\"EmbeddingSequenceGroupOutput(\"\n                f\"embeddings_shape={len(self.embeddings)})\")\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, EmbeddingSequenceGroupOutput):\n            raise NotImplementedError()\n        return self.embeddings == other.embeddings\n\n\n@dataclass\nclass IntermediateTensors:\n    \"\"\"For all pipeline stages except the last, we need to return the hidden\n    states and residuals to be sent to the next stage. This data structure\n    contains the hidden states and residuals for a request.\n    \"\"\"\n\n    tensors: Dict[str, torch.Tensor]\n\n    def __getitem__(self, key: Union[str, slice]):\n        if isinstance(key, str):\n            return self.tensors[key]\n        elif isinstance(key, slice):\n            return self.__class__({k: v[key] for k, v in self.tensors.items()})\n\n    def __setitem__(self, key: str, value):\n        self.tensors[key] = value\n\n    def __len__(self):\n        return len(self.tensors)\n\n    def __eq__(self, other: object):\n        return isinstance(other, self.__class__) and self\n\n    def __repr__(self) -> str:\n        return f\"IntermediateTensors(tensors={self.tensors})\"\n\n\n@dataclass\nclass SamplerOutput:\n    \"\"\"For each sequence group, we generate a list of SequenceOutput object,\n    each of which contains one possible candidate for the next token.\n\n    This data structure implements methods, so it can be used like a list, but\n    also has optional fields for device tensors.\n    \"\"\"\n\n    outputs: List[CompletionSequenceGroupOutput]\n\n    # On-device tensor containing probabilities of each token.\n    sampled_token_probs: Optional[torch.Tensor] = None\n\n    # On-device tensor containing the logprobs of each token.\n    logprobs: Optional[\"torch.Tensor\"] = None\n\n    # On-device tensor containing the sampled token ids.\n    sampled_token_ids: Optional[torch.Tensor] = None\n\n    # Spec decode metrics populated by workers.\n    spec_decode_worker_metrics: Optional[\"SpecDecodeWorkerMetrics\"] = None\n\n    # Optional last hidden states from the model.\n    hidden_states: Optional[torch.Tensor] = None\n\n    def __getitem__(self, idx: int):\n        return self.outputs[idx]\n\n    def __setitem__(self, idx: int, value):\n        self.outputs[idx] = value\n\n    def __len__(self):\n        return len(self.outputs)\n\n    def __eq__(self, other: object):\n        return isinstance(other,\n                          self.__class__) and self.outputs == other.outputs\n\n    def __repr__(self) -> str:\n        \"\"\"Show the shape of a tensor instead of its values to reduce noise.\n        \"\"\"\n        sampled_token_probs_repr = (\"None\" if self.sampled_token_probs is None\n                                    else self.sampled_token_probs.shape)\n        sampled_token_ids_repr = (\"None\" if self.sampled_token_ids is None else\n                                  self.sampled_token_ids.shape)\n        return (\n            f\"SamplerOutput(outputs={self.outputs}, \"\n            f\"sampled_token_probs={sampled_token_probs_repr}, \"\n            f\"sampled_token_ids={sampled_token_ids_repr}, \"\n            f\"spec_decode_worker_metrics={self.spec_decode_worker_metrics})\")\n\n\n@dataclass\nclass PoolerOutput:\n    \"\"\"The output from a pooling operation in the embedding model.\"\"\"\n    outputs: List[EmbeddingSequenceGroupOutput]\n\n    spec_decode_worker_metrics: Optional[\"SpecDecodeWorkerMetrics\"] = None\n\n    def __getitem__(self, idx: int):\n        return self.outputs[idx]\n\n    def __setitem__(self, idx: int, value):\n        self.outputs[idx] = value\n\n    def __len__(self):\n        return len(self.outputs)\n\n    def __eq__(self, other: object):\n        return isinstance(other,\n                          self.__class__) and self.outputs == other.outputs\n\n\ndef get_all_seq_ids(\n        seq_group_metadata_list: List[SequenceGroupMetadata]) -> List[int]:\n    \"\"\"Given a list of SequenceGroupMetadata, create a list of all\n    sequence ids.\n    \"\"\"\n    return [seq_id for sg in seq_group_metadata_list for seq_id in sg.seq_data]\n\n\ndef get_all_seq_ids_and_request_ids(\n    seq_group_metadata_list: List[SequenceGroupMetadata]\n) -> Tuple[List[int], Dict[str, Set[int]]]:\n    \"\"\"Given a list of SequenceGroupMetadata, create a list of all\n    sequence ids.\n    \"\"\"\n    seq_ids: List[int] = []\n    request_id_seq_ids_mapping: Dict[str, Set[int]] = defaultdict(set)\n    for sg in seq_group_metadata_list:\n        for seq_id in sg.seq_data:\n            seq_ids.append(seq_id)\n            request_id_seq_ids_mapping[sg.request_id].add(seq_id)\n    return seq_ids, request_id_seq_ids_mapping\n\n\nclass HiddenStates:\n    \"\"\"Hidden states corresponding to in-progress sequences.\n    Used in speculative decoding to pass hidden states from\n    the target model to the proposer model in the subsequent step.\n\n    seq_ids are the sequence ids of each entry of the batch\n    dimension of the hidden_states tensor\"\"\"\n\n    def __init__(self, seq_group_metadata_list: List[SequenceGroupMetadata],\n                 hidden_states: torch.Tensor):\n        assert len(seq_group_metadata_list) == len(hidden_states)\n        self.seq_ids: List[int] = get_all_seq_ids(seq_group_metadata_list)\n        self.hidden_states: torch.Tensor = hidden_states\n\n    def update(self, seq_group_metadata_list: List[SequenceGroupMetadata],\n               hidden_states: torch.Tensor) -> None:\n        \"\"\"Update hidden states from target model invocation.\"\"\"\n        assert len(seq_group_metadata_list) == len(hidden_states)\n        self.seq_ids.extend(get_all_seq_ids(seq_group_metadata_list))\n        self.hidden_states = torch.cat([self.hidden_states, hidden_states])\n\n    def prune(self,\n              seq_group_metadata_list: List[SequenceGroupMetadata]) -> None:\n        \"\"\"Prune to provided list of sequence ids.\"\"\"\n        seq_ids = get_all_seq_ids(seq_group_metadata_list)\n        if seq_ids != self.seq_ids:\n            # Batch contents changed - prune removed sequences.\n            index = [self.seq_ids.index(seq_id) for seq_id in seq_ids]\n            self.hidden_states = self.hidden_states[index]\n            self.seq_ids = seq_ids\n\n\n@dataclass\nclass ExecuteModelRequest:\n    \"\"\"The model execution request, containing CPU metadata only. The LLM\n    engine should create an instance of this class for each request batch.\"\"\"\n    # The sequence group metadata list.\n    seq_group_metadata_list: List[SequenceGroupMetadata]\n    # Blocks to swap in. List of CPU -> GPU block number.\n    blocks_to_swap_in: List[Tuple[int, int]] = field(default_factory=list)\n    # Blocks to swap out. List of GPU -> CPU block number.\n    blocks_to_swap_out: List[Tuple[int, int]] = field(default_factory=list)\n    # Blocks to copy. Source to dest block.\n    blocks_to_copy: List[Tuple[int, int]] = field(default_factory=list)\n    # Virtual engine ID for pipeline parallel.\n    virtual_engine: int = 0\n    # The number of slots for lookahead decoding.\n    num_lookahead_slots: int = 0\n    # The number of requests in the running queue.\n    running_queue_size: int = 0\n    # Optional hidden states from prior step.\n    previous_hidden_states: Optional[HiddenStates] = None\n    # The number of forward steps to run.\n    num_steps: int = 1\n    # Finished request ids since last step.\n    finished_requests_ids: List[str] = field(default_factory=list)\n\n    def clone(\n        self, seq_group_metadata_list: List[SequenceGroupMetadata]\n    ) -> \"ExecuteModelRequest\":\n        \"\"\"Clone the request with a new sequence group metadata list.\"\"\"\n        return ExecuteModelRequest(\n            seq_group_metadata_list=seq_group_metadata_list,\n            blocks_to_swap_in=self.blocks_to_swap_in.copy(),\n            blocks_to_swap_out=self.blocks_to_swap_out.copy(),\n            blocks_to_copy=self.blocks_to_copy.copy(),\n            virtual_engine=self.virtual_engine,\n            num_lookahead_slots=self.num_lookahead_slots,\n            running_queue_size=self.running_queue_size,\n            previous_hidden_states=self.previous_hidden_states,\n            num_steps=self.num_steps,\n            finished_requests_ids=self.finished_requests_ids)\n",
      "diff": "diff --git a/vllm/sequence.py b/vllm/sequence.py\nindex 0cd4c7e71..72821ecea 100644\n--- a/vllm/sequence.py\n+++ b/vllm/sequence.py\n@@ -3,6 +3,7 @@ import copy\n import enum\n import math\n from abc import ABC, abstractmethod\n+from array import array\n from collections import defaultdict\n from dataclasses import dataclass, field\n from typing import (TYPE_CHECKING, Dict, List, Mapping, Optional, Set, Tuple,\n@@ -119,10 +120,10 @@ class SequenceData:\n         prompt_token_ids: List[int],\n         output_token_ids: Optional[List[int]] = None,\n     ) -> None:\n-        self._prompt_token_ids: List[int] = list(prompt_token_ids)\n+        self._prompt_token_ids = array('l', prompt_token_ids)\n         self._prompt_token_ids_tuple: Tuple[int, ...] = tuple(prompt_token_ids)\n-        self._output_token_ids: List[int] = (\n-            list(output_token_ids) if output_token_ids is not None else [])\n+        self._output_token_ids = array(\n+            'l', output_token_ids if output_token_ids is not None else [])\n \n         self.cumulative_logprob = 0.0\n         # The number of tokens that are computed (that run against the model).\n@@ -132,8 +133,8 @@ class SequenceData:\n         self._update_cached_all_tokens()\n \n     def _update_cached_all_tokens(self):\n-        self._cached_all_token_ids: List[int] = (self._prompt_token_ids +\n-                                                 self._output_token_ids)\n+        self._cached_all_token_ids: List[int] = list(self._prompt_token_ids +\n+                                                     self._output_token_ids)\n \n     @property\n     def prompt_token_ids(self) -> Tuple[int, ...]:\n@@ -141,19 +142,27 @@ class SequenceData:\n \n     @prompt_token_ids.setter\n     def prompt_token_ids(self, new_prompt_token_ids) -> None:\n-        self._prompt_token_ids = list(new_prompt_token_ids)\n+        self._prompt_token_ids = array('l', new_prompt_token_ids)\n         self._prompt_token_ids_tuple = tuple(new_prompt_token_ids)\n         self._update_cached_all_tokens()\n \n+    @property\n+    def prompt_token_ids_array(self) -> array:\n+        return self._prompt_token_ids\n+\n     @property\n     def output_token_ids(self) -> Tuple[int, ...]:\n         return tuple(self._output_token_ids)\n \n     @output_token_ids.setter\n     def output_token_ids(self, new_output_token_ids) -> None:\n-        self._output_token_ids = list(new_output_token_ids)\n+        self._output_token_ids = array('l', new_output_token_ids)\n         self._update_cached_all_tokens()\n \n+    @property\n+    def output_token_ids_array(self) -> array:\n+        return self._output_token_ids\n+\n     def append_token_id(self, token_id: int, logprob: float) -> None:\n         self._output_token_ids.append(token_id)\n         self._cached_all_token_ids.append(token_id)",
      "change_type": "modified",
      "lines_added": 17,
      "lines_removed": 8
    }
  ],
  "affected_apis": [
    "SequenceData.prompt_token_ids_array",
    "SequenceData.output_token_ids_array",
    "SamplingTensors.from_lists"
  ],
  "summary": {
    "total_files": 3,
    "files_added": 0,
    "files_deleted": 0,
    "files_modified": 3
  },
  "csv_metadata": {
    "category": "model-based",
    "json_has_tests": "FALSE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "Yes (test_sampler, test_sequence)",
    "is_benchmark_actually_there": "",
    "sample_clues": "array, executor, from"
  }
}