{
  "commit_hash": "6dd94dbe94c1820a1e224cba65efcf0befa97995",
  "parent_hash": "0e74d797ce8618fdb685126e0ff8576fb966e6ad",
  "message": "[perf] fix perf regression from #12253 (#12380)\n\nSigned-off-by: youkaichao <youkaichao@gmail.com>",
  "author": "youkaichao <youkaichao@gmail.com>",
  "date": "2025-01-24 11:34:27 +0800",
  "files_changed": [
    {
      "file_path": "vllm/worker/model_runner.py",
      "old_content": "import dataclasses\nimport gc\nimport inspect\nimport itertools\nimport time\nimport weakref\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass\nfrom typing import (TYPE_CHECKING, Any, Callable, Dict, List, Optional, Set,\n                    Tuple, Type, TypeVar, Union)\n\nimport numpy as np\nimport torch\nimport torch.distributed\nimport torch.nn as nn\nfrom tqdm import tqdm\n\nimport vllm.envs as envs\nfrom vllm.attention import AttentionMetadata, get_attn_backend\nfrom vllm.attention.backends.abstract import AttentionState\nfrom vllm.attention.backends.utils import CommonAttentionState\nfrom vllm.config import CompilationLevel, VllmConfig\nfrom vllm.core.scheduler import SchedulerOutputs\nfrom vllm.distributed import get_kv_transfer_group, get_pp_group\nfrom vllm.distributed.parallel_state import (get_tensor_model_parallel_rank,\n                                             graph_capture)\nfrom vllm.forward_context import set_forward_context\nfrom vllm.inputs import INPUT_REGISTRY, InputRegistry\nfrom vllm.logger import init_logger\nfrom vllm.lora.layers import LoRAMapping\nfrom vllm.lora.request import LoRARequest\nfrom vllm.lora.worker_manager import LRUCacheWorkerLoRAManager\nfrom vllm.model_executor import SamplingMetadata, SamplingMetadataCache\nfrom vllm.model_executor.layers.rotary_embedding import MRotaryEmbedding\nfrom vllm.model_executor.layers.sampler import SamplerOutput\nfrom vllm.model_executor.model_loader import get_model\nfrom vllm.model_executor.model_loader.tensorizer import TensorizerConfig\nfrom vllm.model_executor.models import supports_lora, supports_multimodal\nfrom vllm.model_executor.models.utils import set_cpu_offload_max_bytes\nfrom vllm.multimodal import (MULTIMODAL_REGISTRY, BatchedTensorInputs,\n                             MultiModalKwargs, MultiModalPlaceholderMap,\n                             MultiModalRegistry)\nfrom vllm.prompt_adapter.layers import PromptAdapterMapping\nfrom vllm.prompt_adapter.request import PromptAdapterRequest\nfrom vllm.prompt_adapter.worker_manager import (\n    LRUCacheWorkerPromptAdapterManager)\nfrom vllm.sampling_params import SamplingParams\nfrom vllm.sequence import IntermediateTensors, SequenceGroupMetadata\nfrom vllm.utils import (DeviceMemoryProfiler, GiB_bytes, PyObjectCache,\n                        async_tensor_h2d, flatten_2d_lists,\n                        is_pin_memory_available, supports_dynamo,\n                        weak_ref_tensor)\nfrom vllm.worker.model_runner_base import (\n    ModelRunnerBase, ModelRunnerInputBase, ModelRunnerInputBuilderBase,\n    _add_attn_metadata_broadcastable_dict,\n    _add_sampling_metadata_broadcastable_dict,\n    _init_attn_metadata_from_tensor_dict,\n    _init_sampling_metadata_from_tensor_dict, dump_input_when_exception)\n\nif TYPE_CHECKING:\n    from vllm.attention.backends.abstract import AttentionBackend\n\nlogger = init_logger(__name__)\n\nLORA_WARMUP_RANK = 8\n\n_NUM_WARMUP_ITERS = 2\n\nTModelInputForGPU = TypeVar('TModelInputForGPU', bound=\"ModelInputForGPU\")\n\n# For now, bump up cache limits for recompilations during CUDA graph warmups.\ntorch._dynamo.config.cache_size_limit = 128\ntorch._dynamo.config.accumulated_cache_size_limit = 128\n\n\n@dataclass(frozen=True)\nclass ModelInputForGPU(ModelRunnerInputBase):\n    \"\"\"\n    This base class contains metadata needed for the base model forward pass\n    but not metadata for possible additional steps, e.g., sampling. Model\n    runners that run additional steps should subclass this method to add\n    additional fields.\n    \"\"\"\n    input_tokens: Optional[torch.Tensor] = None\n    input_positions: Optional[torch.Tensor] = None\n    token_types: Optional[torch.Tensor] = None\n    seq_lens: Optional[List[int]] = None\n    query_lens: Optional[List[int]] = None\n    lora_mapping: Optional[\"LoRAMapping\"] = None\n    lora_requests: Optional[Set[LoRARequest]] = None\n    attn_metadata: Optional[\"AttentionMetadata\"] = None\n    prompt_adapter_mapping: Optional[PromptAdapterMapping] = None\n    prompt_adapter_requests: Optional[Set[PromptAdapterRequest]] = None\n    multi_modal_kwargs: Optional[BatchedTensorInputs] = None\n    request_ids_to_seq_ids: Optional[Dict[str, List[int]]] = None\n    finished_requests_ids: Optional[List[str]] = None\n    virtual_engine: int = 0\n    async_callback: Optional[Callable] = None\n    seq_group_metadata_list: Optional[List[SequenceGroupMetadata]] = None\n    scheduler_outputs: Optional[SchedulerOutputs] = None\n\n    def as_broadcastable_tensor_dict(self) -> Dict[str, Any]:\n        tensor_dict = {\n            \"input_tokens\": self.input_tokens,\n            \"input_positions\": self.input_positions,\n            \"lora_requests\": self.lora_requests,\n            \"lora_mapping\": self.lora_mapping,\n            \"multi_modal_kwargs\": self.multi_modal_kwargs,\n            \"prompt_adapter_mapping\": self.prompt_adapter_mapping,\n            \"prompt_adapter_requests\": self.prompt_adapter_requests,\n            \"virtual_engine\": self.virtual_engine,\n            \"request_ids_to_seq_ids\": self.request_ids_to_seq_ids,\n            \"finished_requests_ids\": self.finished_requests_ids,\n        }\n        _add_attn_metadata_broadcastable_dict(tensor_dict, self.attn_metadata)\n        return tensor_dict\n\n    @classmethod\n    def from_broadcasted_tensor_dict(\n        cls: Type[TModelInputForGPU],\n        tensor_dict: Dict[str, Any],\n        attn_backend: Optional[\"AttentionBackend\"] = None,\n    ) -> TModelInputForGPU:\n        if attn_backend is not None:\n            tensor_dict = _init_attn_metadata_from_tensor_dict(\n                attn_backend, tensor_dict)\n        return cls(**tensor_dict)\n\n    # Exclude `async_callback` to be able to pickle this object\n    def __getstate__(self):\n        state = self.__dict__.copy()\n        del state[\"async_callback\"]\n        return state\n\n    # TODO: What happens when we depickle this object?\n    # How can we update this callback to properly pass it to the engine?\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n        self.__dict__.update({'async_callback': None})\n\n\n@dataclass(frozen=True)\nclass ModelInputForGPUWithSamplingMetadata(ModelInputForGPU):\n    \"\"\"\n    Used by the ModelRunner.\n    \"\"\"\n    sampling_metadata: Optional[\"SamplingMetadata\"] = None\n    # Used for speculative decoding. We do not broadcast it because it is only\n    # used by the driver worker.\n    is_prompt: Optional[bool] = None\n\n    def as_broadcastable_tensor_dict(self) -> Dict[str, Any]:\n        tensor_dict = {\n            \"input_tokens\": self.input_tokens,\n            \"input_positions\": self.input_positions,\n            \"lora_requests\": self.lora_requests,\n            \"lora_mapping\": self.lora_mapping,\n            \"multi_modal_kwargs\": self.multi_modal_kwargs,\n            \"prompt_adapter_mapping\": self.prompt_adapter_mapping,\n            \"prompt_adapter_requests\": self.prompt_adapter_requests,\n            \"virtual_engine\": self.virtual_engine,\n            \"request_ids_to_seq_ids\": self.request_ids_to_seq_ids,\n            \"finished_requests_ids\": self.finished_requests_ids,\n        }\n        _add_attn_metadata_broadcastable_dict(tensor_dict, self.attn_metadata)\n        _add_sampling_metadata_broadcastable_dict(tensor_dict,\n                                                  self.sampling_metadata)\n        return tensor_dict\n\n    @classmethod\n    def from_broadcasted_tensor_dict(\n        cls,\n        tensor_dict: Dict[str, Any],\n        attn_backend: Optional[\"AttentionBackend\"] = None,\n    ) -> \"ModelInputForGPUWithSamplingMetadata\":\n        tensor_dict = _init_sampling_metadata_from_tensor_dict(tensor_dict)\n        if attn_backend is not None:\n            tensor_dict = _init_attn_metadata_from_tensor_dict(\n                attn_backend, tensor_dict)\n        return cls(**tensor_dict)\n\n\nclass ModelInputForGPUBuilder(ModelRunnerInputBuilderBase[ModelInputForGPU]):\n    \"\"\"Build ModelInputForGPU from SequenceGroupMetadata.\"\"\"\n\n    # Note: ideally we would be using a dataclass(kw_only=True)\n    # here, so that this can be subclassed easily,\n    # but kw_only is not supported in python<3.10.\n    class InterDataForSeqGroup:\n        \"\"\"Intermediate data for the current sequence group.\"\"\"\n\n        def simple_reinit(self):\n            self.input_tokens[0].clear()  # type: ignore\n            self.input_positions[0].clear()  # type: ignore\n            self.token_types[0].clear()  # type: ignore\n            self.mrope_input_positions = None  # type: ignore\n            self.seq_lens[0] = 0  # type: ignore\n            self.orig_seq_lens[0] = 0  # type: ignore\n            self.query_lens[0] = 0  # type: ignore\n            self.context_lens[0] = 0  # type: ignore\n            self.curr_sliding_window_blocks[0] = 0  # type: ignore\n            self.lora_index_mapping.clear()  # type: ignore\n            self.lora_prompt_mapping.clear()  # type: ignore\n            self.lora_requests.clear()  # type: ignore\n            self.prompt_adapter_index_mapping.clear()  # type: ignore\n            self.prompt_adapter_prompt_mapping.clear()  # type: ignore\n\n        def __init__(\n            self,\n            *,\n            # From sequence group metadata.\n            request_id: str,\n            seq_ids: List[int],\n            is_prompt: bool,\n            block_tables: Optional[Dict[int, List[int]]],\n            computed_block_nums: List[int],\n            n_seqs: int = 0,\n\n            # Input tokens and positions.\n            input_tokens: Optional[List[List[int]]] = None,\n            input_positions: Optional[List[List[int]]] = None,\n            token_types: Optional[List[List[int]]] = None,\n            mrope_input_positions: Optional[List[List[List[int]]]] = None,\n\n            # The sequence length (may be capped to the sliding window).\n            seq_lens: Optional[List[int]] = None,\n            # The original sequence length (before applying sliding window).\n            # This is used to compute slot mapping.\n            orig_seq_lens: Optional[List[int]] = None,\n            # The query length.\n            query_lens: Optional[List[int]] = None,\n            # The number of tokens that are already computed.\n            context_lens: Optional[List[int]] = None,\n            # The current sliding window block.\n            curr_sliding_window_blocks: Optional[List[int]] = None,\n\n            # LoRA inputs.\n            lora_index_mapping: Optional[List[List[int]]] = None,\n            lora_prompt_mapping: Optional[List[List[int]]] = None,\n            lora_requests: Optional[Set[LoRARequest]] = None,\n\n            # Prompt adapter inputs.\n            prompt_adapter_index_mapping: Optional[List[int]] = None,\n            prompt_adapter_prompt_mapping: Optional[List[int]] = None,\n            prompt_adapter_request: Optional[PromptAdapterRequest] = None,\n\n            # Multi-modal inputs.\n            multi_modal_kwargs: Optional[MultiModalKwargs] = None,\n            multi_modal_placeholder_maps: Optional[Dict[\n                str, MultiModalPlaceholderMap]] = None,\n\n            # Whether the prefix cache is hit (prefill only).\n            prefix_cache_hit: bool = False,\n            reinit: bool = False,\n            reinit_use_defaults: bool = False,\n            encoder_seq_len: int = 0,\n        ):\n            if reinit:\n                assert len(self.seq_ids) == len(seq_ids)  # type: ignore\n                for i, seq_id in enumerate(seq_ids):\n                    self.seq_ids[i] = seq_id  # type: ignore\n            else:\n                self.seq_ids = seq_ids\n\n            self.request_id = request_id\n            self.is_prompt = is_prompt\n            self.block_tables = block_tables\n            self.computed_block_nums = computed_block_nums\n            self.n_seqs = n_seqs\n            self.encoder_seq_len = encoder_seq_len\n\n            if reinit:\n                if len(self.seq_ids) == 1 and reinit_use_defaults:\n                    self.simple_reinit()\n                else:\n                    if input_tokens:\n                        self.input_tokens = input_tokens\n                    else:\n                        for seq_id in range(len(self.seq_ids)):\n                            self.input_tokens[seq_id].clear()\n\n                    if input_positions:\n                        self.input_positions = input_positions\n                    else:\n                        for seq_id in range(len(self.seq_ids)):\n                            self.input_positions[seq_id].clear()\n\n                    if token_types:\n                        self.token_types = token_types\n                    else:\n                        for seq_id in range(len(self.seq_ids)):\n                            self.token_types[seq_id].clear()\n\n                    self.mrope_input_positions = None\n\n                    if seq_lens:\n                        self.seq_lens = seq_lens\n                    else:\n                        for seq_id in range(len(self.seq_ids)):\n                            self.seq_lens[seq_id] = 0\n\n                    if orig_seq_lens:\n                        self.orig_seq_lens = orig_seq_lens\n                    else:\n                        for seq_id in range(len(self.seq_ids)):\n                            self.orig_seq_lens[seq_id] = 0\n\n                    if query_lens:\n                        self.query_lens = query_lens\n                    else:\n                        for seq_id in range(len(self.seq_ids)):\n                            self.query_lens[seq_id] = 0\n\n                    if context_lens:\n                        self.context_lens = context_lens\n                    else:\n                        for seq_id in range(len(self.seq_ids)):\n                            self.context_lens[seq_id] = 0\n\n                    if curr_sliding_window_blocks:\n                        self.curr_sliding_window_blocks = \\\n                            curr_sliding_window_blocks\n                    else:\n                        for seq_id in range(len(self.seq_ids)):\n                            self.curr_sliding_window_blocks[seq_id] = 0\n\n                    if lora_index_mapping:\n                        self.lora_index_mapping = lora_index_mapping\n                    else:\n                        self.lora_index_mapping.clear()\n\n                    if lora_prompt_mapping:\n                        self.lora_prompt_mapping = lora_prompt_mapping\n                    else:\n                        self.lora_prompt_mapping.clear()\n\n                    if lora_requests:\n                        self.lora_requests = lora_requests\n                    else:\n                        self.lora_requests.clear()\n\n                    if prompt_adapter_index_mapping:\n                        self.prompt_adapter_index_mapping = \\\n                            prompt_adapter_index_mapping\n                    else:\n                        self.prompt_adapter_index_mapping.clear()\n\n                    if prompt_adapter_prompt_mapping:\n                        self.prompt_adapter_prompt_mapping = \\\n                            prompt_adapter_prompt_mapping\n                    else:\n                        self.prompt_adapter_prompt_mapping.clear()\n\n            else:\n                self.input_tokens = input_tokens or []\n                self.input_positions = input_positions or []\n                self.token_types = token_types or []\n                self.mrope_input_positions = mrope_input_positions or None\n                self.seq_lens = seq_lens or []\n                self.orig_seq_lens = orig_seq_lens or []\n                self.query_lens = query_lens or []\n                self.context_lens = context_lens or []\n                self.curr_sliding_window_blocks = \\\n                    curr_sliding_window_blocks or []\n\n                self.lora_index_mapping = lora_index_mapping or []\n                self.lora_prompt_mapping = lora_prompt_mapping or []\n                self.lora_requests = lora_requests or set()\n\n                self.prompt_adapter_index_mapping = (\n                    prompt_adapter_index_mapping or [])\n                self.prompt_adapter_prompt_mapping = (\n                    prompt_adapter_prompt_mapping or [])\n\n            self.prompt_adapter_request = prompt_adapter_request\n            self.multi_modal_kwargs = multi_modal_kwargs\n            self.multi_modal_placeholder_maps = multi_modal_placeholder_maps\n            self.prefix_cache_hit = prefix_cache_hit\n\n            self.n_seqs = len(self.seq_ids)\n\n            if not reinit:\n                self.__post_init__()\n\n        def __post_init__(self):\n            self.n_seqs = len(self.seq_ids)\n\n            self.input_tokens = [[] for _ in range(self.n_seqs)]\n            self.input_positions = [[] for _ in range(self.n_seqs)]\n            self.token_types = [[] for _ in range(self.n_seqs)]\n            self.mrope_input_positions = None\n            self.seq_lens = [0] * self.n_seqs\n            self.orig_seq_lens = [0] * self.n_seqs\n            self.query_lens = [0] * self.n_seqs\n            self.context_lens = [0] * self.n_seqs\n            self.curr_sliding_window_blocks = [0] * self.n_seqs\n\n            self.lora_index_mapping = []\n            self.lora_prompt_mapping = []\n\n    def gen_inter_data_builder(self, num_seqs: int):\n        return lambda: ModelInputForGPUBuilder.InterDataForSeqGroup(\n            request_id=\"\",\n            seq_ids=[0] * num_seqs,\n            is_prompt=True,\n            block_tables=None,\n            computed_block_nums=[])\n\n    def init_cached_inter_data(self, *args, **kwargs):\n        assert len(args) == 0\n        assert \"seq_ids\" in kwargs\n        seq_ids = kwargs[\"seq_ids\"]\n        num_seqs = len(seq_ids)\n\n        # The inter-data cache is per model_runner\n        inter_data_cache = self.runner.inter_data_cache\n        if num_seqs not in inter_data_cache:\n            inter_data_cache[num_seqs] = PyObjectCache(\n                self.gen_inter_data_builder(num_seqs))\n\n        obj = inter_data_cache[num_seqs].get_object()\n        obj.__init__(*args, **kwargs)\n        return obj\n\n    def reset_cached_inter_data(self):\n        for cache in self.runner.inter_data_cache.values():\n            cache.reset()\n\n    def __init__(self,\n                 runner: \"GPUModelRunnerBase\",\n                 finished_requests_ids: Optional[List[str]] = None):\n        super().__init__()\n        # Compute functions for each sequence in a sequence group.\n        # WARNING: The order of the functions matters!\n        self.per_seq_compute_fns = [\n            self._compute_lens,\n            self._compute_for_prefix_cache_hit,\n            self._compute_for_sliding_window,\n            self._compute_lora_input,\n        ]\n        # Compute functions for each sequence group.\n        # WARNING: The order of the functions matters!\n        self.per_seq_group_compute_fns = [\n            self._compute_prompt_adapter_input,\n            self._compute_multi_modal_input,\n        ]\n\n        self.runner = runner\n        self.model_input_cls = self.runner._model_input_cls\n        self.attn_backend = self.runner.attn_backend\n        self.scheduler_config = self.runner.scheduler_config\n        self.sliding_window = self.runner.sliding_window\n        self.block_size = self.runner.block_size\n        self.enable_lora = self.runner.lora_config is not None\n        self.enable_prompt_adapter = (self.runner.prompt_adapter_config\n                                      is not None)\n        self.multi_modal_input_mapper = self.runner.multi_modal_input_mapper\n        self.decode_only = True\n\n        # Attention metadata inputs.\n        if self.attn_backend is not None:\n            # spec decode (e.g. Medusa) does not have atten backend\n            self.attn_metadata_builder = self.attn_backend.get_builder_cls()(\n                weakref.proxy(self))\n\n        # Engine/Model configurations.\n        self.chunked_prefill_enabled = (\n            self.scheduler_config is not None\n            and self.scheduler_config.chunked_prefill_enabled)\n        if self.sliding_window is not None:\n            self.sliding_window_blocks = (\n                self.sliding_window + self.block_size - 1) // self.block_size\n            self.block_aligned_sliding_window = \\\n                self.sliding_window_blocks * self.block_size\n\n    def prepare(self,\n                finished_requests_ids: Optional[List[str]] = None) -> None:\n        self.finished_requests_ids = finished_requests_ids\n\n        # Intermediate data (data in CPU before going to GPU) for\n        # the current sequence group.\n        self.inter_data_list: List[\n            ModelInputForGPUBuilder.InterDataForSeqGroup] = []\n\n        self.attn_metadata_builder.prepare()\n\n    def _compute_lens(self, inter_data: InterDataForSeqGroup, seq_idx: int,\n                      seq_group_metadata: SequenceGroupMetadata):\n        \"\"\"Compute context length, sequence length and tokens\n        for the given sequence data.\n        \"\"\"\n        seq_data = seq_group_metadata.seq_data[inter_data.seq_ids[seq_idx]]\n        token_chunk_size = seq_group_metadata.token_chunk_size\n\n        # Compute context length (the number of tokens that are\n        # already computed) and sequence length (total number of tokens).\n\n        seq_len = seq_data.get_len()\n        if inter_data.is_prompt:\n            context_len = seq_data.get_num_computed_tokens()\n            seq_len = min(seq_len, context_len + token_chunk_size)\n        elif self.runner.scheduler_config.is_multi_step or \\\n            self.runner.model_config.is_encoder_decoder:\n            context_len = seq_len - 1\n        else:\n            context_len = seq_data.get_num_computed_tokens()\n\n        # Compute tokens.\n        tokens = seq_data.get_token_ids()[context_len:seq_len]\n        token_types = seq_group_metadata.token_type_ids\n\n        inter_data.seq_lens[seq_idx] = seq_len\n        inter_data.orig_seq_lens[seq_idx] = seq_len\n        inter_data.context_lens[seq_idx] = context_len\n        inter_data.input_tokens[seq_idx].extend(tokens)\n        inter_data.input_positions[seq_idx].extend(range(context_len, seq_len))\n        inter_data.token_types[seq_idx].extend(\n            token_types if token_types else [])\n        inter_data.query_lens[seq_idx] = seq_len - context_len\n\n        if seq_data.mrope_position_delta is not None:\n            if inter_data.mrope_input_positions is None:\n                inter_data.mrope_input_positions = [None] * inter_data.n_seqs\n\n            inter_data.mrope_input_positions[\n                seq_idx] = MRotaryEmbedding.get_next_input_positions(\n                    seq_data.mrope_position_delta,\n                    context_len,\n                    seq_len,\n                )\n\n    def _compute_for_prefix_cache_hit(\n            self, inter_data: InterDataForSeqGroup, seq_idx: int,\n            seq_group_metadata: SequenceGroupMetadata):\n        \"\"\"Check if hit prefix cache (i.e., some blocks are already computed).\n        If hit, update input tokens and positions to only compute the\n        remaining blocks.\n        \"\"\"\n        computed_block_nums = inter_data.computed_block_nums\n\n        # Note that prefix caching does not support sliding window.\n        prefix_cache_hit = (computed_block_nums is not None\n                            and len(computed_block_nums) > 0\n                            and self.sliding_window is None\n                            and inter_data.is_prompt)\n        inter_data.prefix_cache_hit = prefix_cache_hit\n\n        if not prefix_cache_hit:\n            return\n\n        assert computed_block_nums is not None\n        # The cache hit prompt tokens in this sequence. Note that\n        # this may be larger than the sequence length if chunked\n        # prefill is enabled.\n        prefix_cache_len = len(computed_block_nums) * self.block_size\n        seq_group_metadata.seq_data[inter_data.seq_ids[\n            seq_idx]].update_num_cached_tokens(prefix_cache_len)\n\n        # The number of so far computed prompt tokens in this sequence.\n        context_len = inter_data.context_lens[seq_idx]\n        # The total number of prompt tokens in this sequence.\n        # When chunked prefill is enabled, this is the token number of\n        # computed chunks + current chunk.\n        seq_len = inter_data.seq_lens[seq_idx]\n        if prefix_cache_len <= context_len:\n            # We already passed the cache hit region,\n            # so do normal computation.\n            pass\n        elif context_len < prefix_cache_len < seq_len:\n            # Partial hit. Compute the missing part.\n            uncomputed_start = prefix_cache_len - context_len\n            inter_data.input_tokens[seq_idx] = inter_data.input_tokens[\n                seq_idx][uncomputed_start:]\n            inter_data.input_positions[seq_idx] = inter_data.input_positions[\n                seq_idx][uncomputed_start:]\n            inter_data.token_types[seq_idx] = inter_data.token_types[seq_idx][\n                uncomputed_start:]\n            context_len = prefix_cache_len\n\n            inter_data.context_lens[seq_idx] = context_len\n            inter_data.query_lens[\n                seq_idx] = inter_data.seq_lens[seq_idx] - context_len\n        elif seq_len <= prefix_cache_len:\n            # Full hit. Only compute the last token to avoid\n            # erroneous behavior. FIXME: Ideally we should directly\n            # mark all tokens as computed in the scheduler and do not\n            # schedule this sequence, so this case should not happen.\n            inter_data.input_tokens[seq_idx] = inter_data.input_tokens[\n                seq_idx][-1:]\n            inter_data.input_positions[seq_idx] = inter_data.input_positions[\n                seq_idx][-1:]\n            inter_data.token_types[seq_idx] = inter_data.token_types[seq_idx][\n                -1:]\n            inter_data.query_lens[seq_idx] = 1\n            inter_data.context_lens[seq_idx] = inter_data.seq_lens[seq_idx] - 1\n\n    def _compute_for_sliding_window(self, inter_data: InterDataForSeqGroup,\n                                    seq_idx: int,\n                                    seq_group_metadata: SequenceGroupMetadata):\n        \"\"\"Update seq_len and curr_sliding_window_block for the given\n        sequence data (only required by decoding) if sliding window is enabled.\n        \"\"\"\n        curr_sliding_window_block = 0\n        sliding_seq_len = inter_data.seq_lens[seq_idx]\n        if not inter_data.is_prompt and self.sliding_window is not None:\n            # TODO(sang): This is a hack to make sliding window work with\n            # paged attn. We can remove it if we make paged attn kernel\n            # to properly handle slinding window attn.\n            curr_sliding_window_block = self.sliding_window_blocks\n            # number of elements in last block\n            suff_len = inter_data.seq_lens[seq_idx] % self.block_size\n            sliding_seq_len = min(inter_data.seq_lens[seq_idx],\n                                  self.block_aligned_sliding_window + suff_len)\n            if suff_len > 0:\n                curr_sliding_window_block += 1\n\n        inter_data.curr_sliding_window_blocks[\n            seq_idx] = curr_sliding_window_block\n        inter_data.seq_lens[seq_idx] = sliding_seq_len\n\n    def _compute_lora_input(self, inter_data: InterDataForSeqGroup,\n                            seq_idx: int,\n                            seq_group_metadata: SequenceGroupMetadata):\n        \"\"\"If LoRA is enabled, compute LoRA index and prompt mapping.\"\"\"\n        if not self.enable_lora:\n            return\n\n        lora_id = seq_group_metadata.lora_int_id\n        if lora_id > 0:\n            inter_data.lora_requests.add(seq_group_metadata.lora_request)\n        query_len = inter_data.query_lens[seq_idx]\n        inter_data.lora_index_mapping.append([lora_id] * query_len)\n        sampling_params = seq_group_metadata.sampling_params\n        if sampling_params and sampling_params.prompt_logprobs is not None:\n            inter_data.lora_prompt_mapping.append([lora_id] * query_len)\n        elif not self.chunked_prefill_enabled or seq_group_metadata.do_sample:\n            inter_data.lora_prompt_mapping.append([lora_id])\n        else:\n            inter_data.lora_prompt_mapping.append([])\n\n    def _compute_prompt_adapter_input(\n            self, inter_data: InterDataForSeqGroup,\n            seq_group_metadata: SequenceGroupMetadata):\n        \"\"\"If prompt adapter is enabled, compute index and prompt mapping.\n        \"\"\"\n        # Note that when is_prompt=True, we expect only one sequence\n        # in the group.\n        if not self.enable_prompt_adapter:\n            return\n\n        prompt_adapter_id = seq_group_metadata.prompt_adapter_id\n        if prompt_adapter_id <= 0 or not inter_data.is_prompt:\n            return\n\n        # We expect only one sequence in the group when is_prompt=True.\n        assert inter_data.n_seqs == 1\n        query_len = inter_data.query_lens[0]\n        inter_data.prompt_adapter_request = (\n            seq_group_metadata.prompt_adapter_request)\n\n        num_tokens = seq_group_metadata.prompt_adapter_num_virtual_tokens\n        inter_data.prompt_adapter_index_mapping = [\n            prompt_adapter_id\n        ] * num_tokens + [0] * (query_len - num_tokens)\n        inter_data.prompt_adapter_prompt_mapping = [prompt_adapter_id] * (\n            query_len if seq_group_metadata.sampling_params\n            and seq_group_metadata.sampling_params.prompt_logprobs else 1)\n\n    def _compute_multi_modal_input(self, inter_data: InterDataForSeqGroup,\n                                   seq_group_metadata: SequenceGroupMetadata):\n        \"\"\"If multi-modal data is given, add it to the input.\"\"\"\n        # NOTE: mm_data only includes the subset of multi-modal items that\n        # intersect with the current prefill positions.\n        positions = inter_data.input_positions[0]\n        mm_data, placeholder_maps = MultiModalPlaceholderMap.from_seq_group(\n            seq_group_metadata,\n            range(positions[0], positions[0] + len(positions)))\n        if not mm_data:\n            return\n\n        if self.runner.mm_registry.has_processor(self.runner.model_config):\n            mm_kwargs = mm_data\n        else:\n            mm_kwargs = self.multi_modal_input_mapper(\n                mm_data,\n                seq_group_metadata.mm_processor_kwargs,\n            )\n\n        inter_data.multi_modal_kwargs = mm_kwargs\n        inter_data.multi_modal_placeholder_maps = placeholder_maps\n\n        # special processing for mrope position deltas.\n        if self.runner.model_config.uses_mrope:\n            image_grid_thw = mm_kwargs.get(\"image_grid_thw\", None)\n            video_grid_thw = mm_kwargs.get(\"video_grid_thw\", None)\n            assert image_grid_thw is not None or video_grid_thw is not None, (\n                \"mrope embedding type requires multi-modal input mapper \"\n                \"returns 'image_grid_thw' or 'video_grid_thw'.\")\n\n            hf_config = self.runner.model_config.hf_config\n\n            inter_data.mrope_input_positions = [None] * inter_data.n_seqs\n            for seq_idx in range(inter_data.n_seqs):\n                seq_data = seq_group_metadata.seq_data[\n                    inter_data.seq_ids[seq_idx]]\n                token_ids = seq_data.get_token_ids()\n\n                mrope_input_positions, mrope_position_delta = \\\n                    MRotaryEmbedding.get_input_positions(\n                        token_ids,\n                        image_grid_thw=image_grid_thw,\n                        video_grid_thw=video_grid_thw,\n                        image_token_id=hf_config.image_token_id,\n                        video_token_id=hf_config.video_token_id,\n                        vision_start_token_id=hf_config.vision_start_token_id,\n                        vision_end_token_id=hf_config.vision_end_token_id,\n                        spatial_merge_size=hf_config.vision_config.\n                        spatial_merge_size,\n                        context_len=inter_data.context_lens[seq_idx],\n                        seq_len=inter_data.seq_lens[seq_idx],\n                    )\n\n                seq_data.mrope_position_delta = mrope_position_delta\n                inter_data.mrope_input_positions[\n                    seq_idx] = mrope_input_positions\n\n    def add_seq_group(self, seq_group_metadata: SequenceGroupMetadata):\n        \"\"\"Add a sequence group to the builder.\"\"\"\n        seq_ids = seq_group_metadata.seq_data.keys()\n        n_seqs = len(seq_ids)\n        is_prompt = seq_group_metadata.is_prompt\n\n        if is_prompt:\n            assert n_seqs == 1\n            self.decode_only = False\n\n        encoder_seq_len = 0\n\n        if self.runner.model_config.is_encoder_decoder:\n            encoder_seq_len = seq_group_metadata.encoder_seq_data.get_len()\n\n        inter_data = self.init_cached_inter_data(\n            request_id=seq_group_metadata.request_id,\n            seq_ids=seq_ids,\n            is_prompt=is_prompt,\n            block_tables=seq_group_metadata.block_tables,\n            computed_block_nums=seq_group_metadata.computed_block_nums,\n            reinit=True,\n            reinit_use_defaults=True,\n            encoder_seq_len=encoder_seq_len)\n\n        self.inter_data_list.append(inter_data)\n\n        for seq_idx in range(n_seqs):\n            for per_seq_fn in self.per_seq_compute_fns:\n                per_seq_fn(inter_data, seq_idx, seq_group_metadata)\n        for per_seq_group_fn in self.per_seq_group_compute_fns:\n            per_seq_group_fn(inter_data, seq_group_metadata)\n\n    def _use_captured_graph(self,\n                            batch_size: int,\n                            decode_only: bool,\n                            max_decode_seq_len: int,\n                            max_encoder_seq_len: int = 0) -> bool:\n        return (decode_only and not self.runner.model_config.enforce_eager\n                and max_decode_seq_len <= self.runner.max_seq_len_to_capture\n                and max_encoder_seq_len <= self.runner.max_seq_len_to_capture\n                and batch_size <= self.runner.max_batchsize_to_capture)\n\n    def _get_cuda_graph_pad_size(self,\n                                 num_seqs: int,\n                                 max_decode_seq_len: int,\n                                 max_encoder_seq_len: int = 0) -> int:\n        \"\"\"\n        Determine the number of padding sequences required for running in\n        CUDA graph mode. Returns -1 if CUDA graphs cannot be used.\n\n        In the multi-step + chunked-prefill case, only the first step\n        has Prefills (if any). The rest of the steps are guaranteed to be all\n        decodes. In this case, we set up the padding as if all the sequences\n        are decodes so we may run all steps except the first step in CUDA graph\n        mode. The padding is accounted for in the multi-step `advance_step`\n        family of functions.\n\n        Args:\n            num_seqs (int): Number of sequences scheduled to run.\n            max_decode_seq_len (int): Greatest of all the decode sequence\n                lengths. Used only in checking the viablility of using\n                CUDA graphs.\n            max_encoder_seq_len (int, optional): Greatest of all the encode\n                sequence lengths. Defaults to 0. Used only in checking the\n                viability of using CUDA graphs.\n        Returns:\n            int: Returns the determined number of padding sequences. If\n                CUDA graphs is not viable, returns -1.\n        \"\"\"\n        is_mscp: bool = self.runner.scheduler_config.is_multi_step and \\\n                    self.runner.scheduler_config.chunked_prefill_enabled\n        decode_only = self.decode_only or is_mscp\n        if not decode_only:\n            # Early exit so we can treat num_seqs as the batch_size below.\n            return -1\n\n        # batch_size out of this function refers to the number of input\n        # tokens being scheduled. This conflation of num_seqs as batch_size\n        # is valid as this is a decode-only case.\n        batch_size = num_seqs\n        if not self._use_captured_graph(batch_size, decode_only,\n                                        max_decode_seq_len,\n                                        max_encoder_seq_len):\n            return -1\n\n        graph_batch_size = self.runner.vllm_config.pad_for_cudagraph(\n            batch_size)\n        assert graph_batch_size >= batch_size\n        return graph_batch_size - batch_size\n\n    def build(self) -> ModelInputForGPU:\n        \"\"\"Finalize the builder intermediate data and\n        create on-device tensors.\n        \"\"\"\n        # Combine and flatten intermediate data.\n        input_tokens = []\n        token_types = []\n        for inter_data in self.inter_data_list:\n            for cur_input_tokens in inter_data.input_tokens:\n                input_tokens.extend(cur_input_tokens)\n            for cur_token_types in inter_data.token_types:\n                token_types.extend(cur_token_types)\n\n        if not input_tokens:\n            # This may happen when all prefill requests hit\n            # prefix caching and there is no decode request.\n            return self.model_input_cls()\n\n        mrope_input_positions: Optional[List[List[int]]] = None\n        if any(inter_data.mrope_input_positions is not None\n               for inter_data in self.inter_data_list):\n            mrope_input_positions = [[] for _ in range(3)]\n            for idx in range(3):\n                for inter_data in self.inter_data_list:\n                    msections = inter_data.mrope_input_positions\n                    if msections is None:\n                        for _seq_input_positions in inter_data.input_positions:\n                            mrope_input_positions[idx].extend(\n                                _seq_input_positions)\n                    else:\n                        for _seq_mrope_input_positions in msections:\n                            mrope_input_positions[idx].extend(\n                                _seq_mrope_input_positions[idx])\n            input_positions = None\n        else:\n            input_positions = []\n            for inter_data in self.inter_data_list:\n                for cur_input_positions in inter_data.input_positions:\n                    input_positions.extend(cur_input_positions)\n\n        seq_lens = []\n        query_lens = []\n        max_decode_seq_len = 0\n        max_encoder_seq_len = 0\n        for inter_data in self.inter_data_list:\n            seq_lens.extend(inter_data.seq_lens)\n            query_lens.extend(inter_data.query_lens)\n            if not inter_data.is_prompt:\n                max_decode_seq_len = max(max_decode_seq_len,\n                                         max(inter_data.seq_lens))\n                if self.runner.model_config.is_encoder_decoder:\n                    max_encoder_seq_len = max(max_encoder_seq_len,\n                                              inter_data.encoder_seq_len)\n\n        # Mapping from request IDs to sequence IDs. Used for Jamba models\n        # that manages the cache by itself.\n        request_ids_to_seq_ids = {\n            data.request_id: data.seq_ids\n            for data in self.inter_data_list\n        }\n\n        cuda_graph_pad_size = self._get_cuda_graph_pad_size(\n            num_seqs=len(seq_lens),\n            max_decode_seq_len=max_decode_seq_len,\n            max_encoder_seq_len=max_encoder_seq_len)\n\n        batch_size = len(input_tokens)\n        if cuda_graph_pad_size != -1:\n            # If cuda graph can be used, pad tensors accordingly.\n            # See `capture_model` API for more details.\n            # vLLM uses cuda graph only for decoding requests.\n            batch_size += cuda_graph_pad_size\n\n        # Tokens and positions.\n        if cuda_graph_pad_size:\n            input_tokens.extend(itertools.repeat(0, cuda_graph_pad_size))\n        assert self.runner.device is not None\n        input_tokens_tensor = async_tensor_h2d(input_tokens, torch.long,\n                                               self.runner.device,\n                                               self.runner.pin_memory)\n\n        token_types_tensor = async_tensor_h2d(token_types, torch.long,\n                                               self.runner.device,\n                                               self.runner.pin_memory) \\\n                                                if token_types else None\n\n        if mrope_input_positions is not None:\n            for idx in range(3):\n                mrope_input_positions[idx].extend(\n                    itertools.repeat(0, cuda_graph_pad_size))\n            input_positions_tensor = async_tensor_h2d(mrope_input_positions,\n                                                      torch.long,\n                                                      self.runner.device,\n                                                      self.runner.pin_memory)\n        else:\n            input_positions.extend(itertools.repeat(0, cuda_graph_pad_size))\n            input_positions_tensor = async_tensor_h2d(input_positions,\n                                                      torch.long,\n                                                      self.runner.device,\n                                                      self.runner.pin_memory)\n        # Sequence and query lengths.\n        if cuda_graph_pad_size:\n            seq_lens.extend(itertools.repeat(1, cuda_graph_pad_size))\n\n        # Attention metadata.\n        attn_metadata = self.attn_metadata_builder.build(\n            seq_lens, query_lens, cuda_graph_pad_size, batch_size)\n\n        # LoRA data.\n        lora_requests = set()\n        lora_mapping = None\n        if self.enable_lora:\n            lora_requests = set(r for data in self.inter_data_list\n                                for r in data.lora_requests)\n            lora_index_mapping = flatten_2d_lists([\n                flatten_2d_lists(inter_data.lora_index_mapping)\n                for inter_data in self.inter_data_list\n            ])\n            if cuda_graph_pad_size:\n                lora_index_mapping.extend(\n                    itertools.repeat(0, cuda_graph_pad_size))\n            lora_prompt_mapping = flatten_2d_lists([\n                flatten_2d_lists(inter_data.lora_prompt_mapping)\n                for inter_data in self.inter_data_list\n            ])\n\n            lora_mapping = LoRAMapping(\n                **dict(index_mapping=lora_index_mapping,\n                       prompt_mapping=lora_prompt_mapping,\n                       is_prefill=not self.decode_only))\n\n        # Prompt adapter data.\n        prompt_adapter_requests: Set[PromptAdapterRequest] = set()\n        prompt_adapter_mapping = None\n        if self.enable_prompt_adapter:\n            prompt_adapter_requests = set(\n                data.prompt_adapter_request for data in self.inter_data_list\n                if data.prompt_adapter_request is not None)\n            prompt_adapter_index_mapping = flatten_2d_lists([\n                inter_data.prompt_adapter_index_mapping\n                for inter_data in self.inter_data_list\n            ])\n            if cuda_graph_pad_size:\n                prompt_adapter_index_mapping.extend(\n                    itertools.repeat(0, cuda_graph_pad_size))\n            prompt_adapter_prompt_mapping = flatten_2d_lists([\n                inter_data.prompt_adapter_prompt_mapping\n                for inter_data in self.inter_data_list\n            ])\n            prompt_adapter_mapping = PromptAdapterMapping(\n                prompt_adapter_index_mapping,\n                prompt_adapter_prompt_mapping,\n            )\n\n        # Multi-modal data.\n        multi_modal_kwargs_list = [\n            data.multi_modal_kwargs for data in self.inter_data_list\n            if data.multi_modal_kwargs is not None\n        ]\n        multi_modal_kwargs = MultiModalKwargs.batch(multi_modal_kwargs_list)\n\n        return self.model_input_cls(\n            input_tokens=input_tokens_tensor,\n            input_positions=input_positions_tensor,\n            token_types=token_types_tensor,\n            attn_metadata=attn_metadata,\n            seq_lens=seq_lens,\n            query_lens=query_lens,\n            lora_mapping=lora_mapping,\n            lora_requests=lora_requests,\n            multi_modal_kwargs=multi_modal_kwargs,\n            request_ids_to_seq_ids=request_ids_to_seq_ids,\n            finished_requests_ids=self.finished_requests_ids,\n            prompt_adapter_mapping=prompt_adapter_mapping,\n            prompt_adapter_requests=prompt_adapter_requests)\n\n\nclass GPUModelRunnerBase(ModelRunnerBase[TModelInputForGPU]):\n    \"\"\"\n    Helper class for shared methods between GPU model runners.\n    \"\"\"\n    _model_input_cls: Type[TModelInputForGPU]\n    _builder_cls: Type[ModelInputForGPUBuilder]\n    builder: ModelInputForGPUBuilder\n\n    def __init__(\n        self,\n        vllm_config: VllmConfig,\n        kv_cache_dtype: Optional[str] = \"auto\",\n        is_driver_worker: bool = False,\n        return_hidden_states: bool = False,\n        input_registry: InputRegistry = INPUT_REGISTRY,\n        mm_registry: MultiModalRegistry = MULTIMODAL_REGISTRY,\n    ):\n\n        ModelRunnerBase.__init__(self, vllm_config)\n        model_config = self.model_config\n        cache_config = self.cache_config\n\n        self.is_driver_worker = is_driver_worker\n        self.return_hidden_states = return_hidden_states\n\n        self.device = self.device_config.device\n        self.pin_memory = is_pin_memory_available()\n\n        self.kv_cache_dtype = kv_cache_dtype\n        self.sliding_window = model_config.get_sliding_window()\n        self.block_size = cache_config.block_size\n        self.max_seq_len_to_capture = self.model_config.max_seq_len_to_capture\n        self.max_batchsize_to_capture = \\\n            self.vllm_config.compilation_config.max_capture_size\n\n        self.graph_runners: List[Dict[int, CUDAGraphRunner]] = [\n            {} for _ in range(self.parallel_config.pipeline_parallel_size)\n        ]\n        self.graph_memory_pool: Optional[Tuple[\n            int, int]] = None  # Set during graph capture.\n\n        self.has_inner_state = model_config.has_inner_state\n\n        self.in_profile_run = False\n\n        # When using CUDA graph, the input block tables must be padded to\n        # max_seq_len_to_capture. However, creating the block table in\n        # Python can be expensive. To optimize this, we cache the block table\n        # in numpy and only copy the actual input content at every iteration.\n        # The shape of the cached block table will be\n        # (max batch size to capture, max seq len to capture / block size).\n        self.graph_block_tables = np.zeros(\n            (self.max_batchsize_to_capture, self.get_max_block_per_batch()),\n            dtype=np.int32)\n\n        # Attention-free but stateful models like Mamba need a placeholder attn\n        # backend, as the attention metadata is needed to manage internal state.\n        # However we must bypass attention selection altogether for some models\n        # used for speculative decoding to avoid a divide-by-zero in\n        # model_config.get_head_size()\n        num_attn_heads = self.model_config.get_num_attention_heads(\n            self.parallel_config)\n        needs_attn_backend = (num_attn_heads != 0\n                              or self.model_config.is_attention_free)\n\n        self.attn_backend = get_attn_backend(\n            self.model_config.get_head_size(),\n            self.model_config.dtype,\n            self.kv_cache_dtype,\n            self.block_size,\n            self.model_config.is_attention_free,\n        ) if needs_attn_backend else None\n        if self.attn_backend:\n            self.attn_state = self.attn_backend.get_state_cls()(\n                weakref.proxy(self))\n        else:\n            self.attn_state = CommonAttentionState(weakref.proxy(self))\n\n        # Multi-modal data support\n        self.input_registry = input_registry\n        self.mm_registry = mm_registry\n        self.multi_modal_input_mapper = mm_registry \\\n            .create_input_mapper(model_config)\n        self.mm_registry.init_mm_limits_per_prompt(self.model_config)\n\n        # Lazy initialization\n        self.model: nn.Module  # Set after load_model\n        # Set after load_model.\n        self.lora_manager: Optional[LRUCacheWorkerLoRAManager] = None\n        self.prompt_adapter_manager: LRUCacheWorkerPromptAdapterManager = None\n\n        set_cpu_offload_max_bytes(\n            int(self.cache_config.cpu_offload_gb * 1024**3))\n\n        # Used to cache python objects\n        self.inter_data_cache: Dict[int, PyObjectCache] = {}\n\n        # Using the PythonizationCache in Pipeline-Parallel clobbers the\n        # SequenceGroupToSample object. In Pipeline-Parallel, we have\n        # more than 1 Scheduler, resulting in a potential back-to-back\n        # prepare_model_inputs() call. This clobbers the cached\n        # SequenceGroupToSample objects, as we reset the cache during\n        # every prepare_model_inputs() call.\n        self.sampling_metadata_cache: SamplingMetadataCache = \\\n              SamplingMetadataCache() \\\n                if self.parallel_config.pipeline_parallel_size == 1 else None\n\n        if hasattr(self, \"_builder_cls\"):\n            # multi-step model runner does not have `_builder_cls`\n            self.builder = self._builder_cls(weakref.proxy(self))\n\n    def load_model(self) -> None:\n        logger.info(\"Starting to load model %s...\", self.model_config.model)\n        with DeviceMemoryProfiler() as m:\n            self.model = get_model(vllm_config=self.vllm_config)\n\n        self.model_memory_usage = m.consumed_memory\n        logger.info(\"Loading model weights took %.4f GB\",\n                    self.model_memory_usage / float(2**30))\n\n        if self.lora_config:\n            assert supports_lora(\n                self.model\n            ), f\"{self.model.__class__.__name__} does not support LoRA yet.\"\n\n            if supports_multimodal(self.model):\n                logger.warning(\"Regarding multimodal models, vLLM currently \"\n                               \"only supports adding LoRA to language model.\")\n            # It's necessary to distinguish between the max_position_embeddings\n            # of VLMs and LLMs.\n            if hasattr(self.model.config, \"max_position_embeddings\"):\n                max_pos_embeddings = self.model.config.max_position_embeddings\n            else:\n                max_pos_embeddings = (\n                    self.model.config.text_config.max_position_embeddings)\n\n            self.lora_manager = LRUCacheWorkerLoRAManager(\n                self.scheduler_config.max_num_seqs,\n                self.scheduler_config.max_num_batched_tokens,\n                self.vocab_size,\n                self.lora_config,\n                self.device,\n                self.model.embedding_modules,\n                self.model.embedding_padding_modules,\n                max_position_embeddings=max_pos_embeddings,\n            )\n            self.model = self.lora_manager.create_lora_manager(self.model)\n\n        if self.prompt_adapter_config:\n            self.prompt_adapter_manager = LRUCacheWorkerPromptAdapterManager(\n                self.scheduler_config.max_num_seqs,\n                self.scheduler_config.max_num_batched_tokens, self.device,\n                self.prompt_adapter_config)\n            self.model = (\n                self.prompt_adapter_manager.create_prompt_adapter_manager(\n                    self.model))\n\n        if self.vllm_config.compilation_config.level ==\\\n            CompilationLevel.DYNAMO_AS_IS and supports_dynamo():\n            backend = self.vllm_config.compilation_config.init_backend(\n                self.vllm_config)\n            self.model = torch.compile(\n                self.model,\n                fullgraph=envs.VLLM_TEST_DYNAMO_FULLGRAPH_CAPTURE,\n                backend=backend)\n\n    def get_model(self) -> nn.Module:\n        return self.model\n\n    def save_sharded_state(\n        self,\n        path: str,\n        pattern: Optional[str] = None,\n        max_size: Optional[int] = None,\n    ) -> None:\n        from vllm.model_executor.model_loader.loader import ShardedStateLoader\n        ShardedStateLoader.save_model(\n            self.model,\n            path,\n            pattern=pattern,\n            max_size=max_size,\n        )\n\n    def save_tensorized_model(\n        self,\n        tensorizer_config: TensorizerConfig,\n    ) -> None:\n        from vllm.model_executor.model_loader.loader import TensorizerLoader\n        TensorizerLoader.save_model(\n            self.model,\n            tensorizer_config=tensorizer_config,\n        )\n\n    def get_max_block_per_batch(self) -> int:\n        block_size = self.block_size\n        return (self.max_seq_len_to_capture + block_size - 1) // block_size\n\n    def _prepare_model_input_tensors(\n        self,\n        seq_group_metadata_list: List[SequenceGroupMetadata],\n        finished_requests_ids: Optional[List[str]] = None\n    ) -> TModelInputForGPU:\n        \"\"\"Helper method to prepare the model input based on a given sequence\n        group. Prepares metadata needed for the base model forward pass but not\n        metadata for possible additional steps, e.g., sampling.\n\n        The API assumes seq_group_metadata_list is sorted by prefill -> decode.\n\n        The result tensors and data structure also batches input in prefill\n        -> decode order. For example,\n\n        - input_tokens[:num_prefill_tokens] contains prefill tokens.\n        - input_tokens[num_prefill_tokens:] contains decode tokens.\n\n        If cuda graph is required, this API automatically pads inputs.\n        \"\"\"\n        self.builder.prepare(finished_requests_ids)\n        for seq_group_metadata in seq_group_metadata_list:\n            self.builder.add_seq_group(seq_group_metadata)\n\n        self.builder.reset_cached_inter_data()\n\n        return self.builder.build()  # type: ignore\n\n    @contextmanager\n    def set_in_profile_run(self):\n        self.in_profile_run = True\n        try:\n            yield\n        finally:\n            self.in_profile_run = False\n\n    @torch.inference_mode()\n    def profile_run(self) -> None:\n        max_num_batched_tokens = \\\n            self.scheduler_config.max_num_batched_tokens\n        max_num_seqs = self.scheduler_config.max_num_seqs\n        self._dummy_run(max_num_batched_tokens, max_num_seqs)\n\n    def _dummy_run(self,\n                   max_num_batched_tokens: int,\n                   max_num_seqs: int = 1) -> None:\n        with self.set_in_profile_run():\n            # Enable top-k sampling to reflect the accurate memory usage.\n            sampling_params = \\\n                SamplingParams(top_p=0.99, top_k=self.vocab_size - 1)\n\n            # This represents the maximum number of different requests\n            # that will have unique loras, an therefore the max amount of memory\n            # consumption create dummy lora request copies from the lora request\n            # passed in, which contains a lora from the lora warmup path.\n            dummy_lora_requests: List[LoRARequest] = []\n            dummy_lora_requests_per_seq: List[LoRARequest] = []\n            if self.lora_config:\n                assert self.lora_manager is not None\n                with self.lora_manager.dummy_lora_cache():\n                    for idx in range(self.lora_config.max_loras):\n                        lora_id = idx + 1\n                        dummy_lora_request = LoRARequest(\n                            lora_name=f\"warmup_{lora_id}\",\n                            lora_int_id=lora_id,\n                            lora_path=\"/not/a/real/path\",\n                        )\n                        self.lora_manager.add_dummy_lora(dummy_lora_request,\n                                                         rank=LORA_WARMUP_RANK)\n                        dummy_lora_requests.append(dummy_lora_request)\n                    dummy_lora_requests_per_seq = [\n                        dummy_lora_requests[idx % len(dummy_lora_requests)]\n                        for idx in range(max_num_seqs)\n                    ]\n\n            # Profile memory usage with max_num_sequences sequences and the\n            # total number of tokens equal to max_num_batched_tokens.\n            seqs: List[SequenceGroupMetadata] = []\n            # Additional GPU memory may be needed for multi-modal encoding,\n            # which needs to be accounted for when calculating the GPU blocks\n            # for vLLM blocker manager.\n            # To exercise the worst scenario for GPU memory consumption,\n            # the number of seqs (batch_size) is chosen to maximize the number\n            # of images processed.\n\n            max_mm_tokens = self.mm_registry.get_max_multimodal_tokens(\n                self.model_config)\n            if max_mm_tokens > 0:\n                max_num_seqs_orig = max_num_seqs\n                max_num_seqs = min(max_num_seqs,\n                                   max_num_batched_tokens // max_mm_tokens)\n                if max_num_seqs < 1:\n                    expr = (f\"min({max_num_seqs_orig}, \"\n                            f\"{max_num_batched_tokens} // {max_mm_tokens})\")\n                    logger.warning(\n                        \"Computed max_num_seqs (%s) to be less than 1. \"\n                        \"Setting it to the minimum value of 1.\", expr)\n                    max_num_seqs = 1\n\n            batch_size = 0\n            for group_id in range(max_num_seqs):\n                seq_len = (max_num_batched_tokens // max_num_seqs +\n                           (group_id < max_num_batched_tokens % max_num_seqs))\n                batch_size += seq_len\n\n                dummy_data = self.input_registry \\\n                    .dummy_data_for_profiling(self.model_config,\n                                            seq_len,\n                                            self.mm_registry)\n\n                seq = SequenceGroupMetadata(\n                    request_id=str(group_id),\n                    is_prompt=True,\n                    seq_data={group_id: dummy_data.seq_data},\n                    sampling_params=sampling_params,\n                    block_tables=None,\n                    lora_request=dummy_lora_requests_per_seq[group_id]\n                    if dummy_lora_requests_per_seq else None,\n                    multi_modal_data=dummy_data.multi_modal_data,\n                    multi_modal_placeholders=dummy_data.\n                    multi_modal_placeholders,\n                )\n                seqs.append(seq)\n\n            # Run the model with the dummy inputs.\n            num_layers = self.model_config.get_num_layers(self.parallel_config)\n            # use an empty tensor instead of `None`` to force Dynamo to pass\n            # it by reference, rather by specializing on the value ``None``.\n            # the `dtype` argument does not matter, and we use `float32` as\n            # a placeholder (it has wide hardware support).\n            # it is important to create tensors inside the loop, rather than\n            # multiplying the list, to avoid Dynamo from treating them as\n            # tensor aliasing.\n            kv_caches = [\n                torch.tensor([], dtype=torch.float32, device=self.device)\n                for _ in range(num_layers)\n            ]\n            finished_requests_ids = [seq.request_id for seq in seqs]\n            model_input = self.prepare_model_input(\n                seqs, finished_requests_ids=finished_requests_ids)\n            intermediate_tensors = None\n            if not get_pp_group().is_first_rank:\n                intermediate_tensors = \\\n                    self.model.make_empty_intermediate_tensors(\n                    batch_size=batch_size,\n                    dtype=self.model_config.dtype,\n                    device=self.device)\n\n            # Disable KV Scale Calculation for dummy data during profile run\n            if model_input.attn_metadata is not None:\n                model_input.attn_metadata.enable_kv_scales_calculation = False\n\n            self.execute_model(model_input, kv_caches, intermediate_tensors)\n            torch.cuda.synchronize()\n            return\n\n    def remove_all_loras(self):\n        if not self.lora_manager:\n            raise RuntimeError(\"LoRA is not enabled.\")\n        self.lora_manager.remove_all_adapters()\n\n    def set_active_loras(self, lora_requests: Set[LoRARequest],\n                         lora_mapping: LoRAMapping) -> None:\n        if not self.lora_manager:\n            raise RuntimeError(\"LoRA is not enabled.\")\n        self.lora_manager.set_active_adapters(lora_requests, lora_mapping)\n\n    def add_lora(self, lora_request: LoRARequest) -> bool:\n        if not self.lora_manager:\n            raise RuntimeError(\"LoRA is not enabled.\")\n        return self.lora_manager.add_adapter(lora_request)\n\n    def remove_lora(self, lora_id: int) -> bool:\n        if not self.lora_manager:\n            raise RuntimeError(\"LoRA is not enabled.\")\n        return self.lora_manager.remove_adapter(lora_id)\n\n    def pin_lora(self, lora_id: int) -> bool:\n        if not self.lora_manager:\n            raise RuntimeError(\"LoRA is not enabled.\")\n        return self.lora_manager.pin_adapter(lora_id)\n\n    def list_loras(self) -> Set[int]:\n        if not self.lora_manager:\n            raise RuntimeError(\"LoRA is not enabled.\")\n        return self.lora_manager.list_adapters()\n\n    def remove_all_prompt_adapters(self):\n        if not self.prompt_adapter_manager:\n            raise RuntimeError(\"PromptAdapter is not enabled.\")\n        self.prompt_adapter_manager.remove_all_adapters()\n\n    def set_active_prompt_adapters(\n            self, prompt_adapter_requests: Set[PromptAdapterRequest],\n            prompt_adapter_mapping: PromptAdapterMapping) -> None:\n        if not self.prompt_adapter_manager:\n            raise RuntimeError(\"PromptAdapter is not enabled.\")\n        self.prompt_adapter_manager.set_active_adapters(\n            prompt_adapter_requests, prompt_adapter_mapping)\n\n    def add_prompt_adapter(\n            self, prompt_adapter_request: PromptAdapterRequest) -> bool:\n        if not self.prompt_adapter_manager:\n            raise RuntimeError(\"PromptAdapter is not enabled.\")\n        return self.prompt_adapter_manager.add_adapter(prompt_adapter_request)\n\n    def remove_prompt_adapter(self, prompt_adapter_id: int) -> bool:\n        if not self.prompt_adapter_manager:\n            raise RuntimeError(\"PromptAdapter is not enabled.\")\n        return self.prompt_adapter_manager.remove_adapter(prompt_adapter_id)\n\n    def pin_prompt_adapter(self, prompt_adapter_id: int) -> bool:\n        if not self.prompt_adapter_manager:\n            raise RuntimeError(\"PromptAdapter is not enabled.\")\n        return self.prompt_adapter_manager.pin_adapter(prompt_adapter_id)\n\n    def list_prompt_adapters(self) -> Set[int]:\n        if not self.prompt_adapter_manager:\n            raise RuntimeError(\"PromptAdapter is not enabled.\")\n        return self.prompt_adapter_manager.list_adapters()\n\n    @torch.inference_mode()\n    def capture_model(self, kv_caches: List[List[torch.Tensor]]) -> None:\n        \"\"\"Cuda graph capture a model.\n\n        Note that CUDA graph's performance gain is negligible if number\n        of batched tokens are larger than 200. And since CUDA graph\n        requires fixed sized tensors, supporting large/variable batch\n        size requires high GPU memory overhead. Thus, vLLM only captures\n        decoding requests. Mixed batch (chunked prefill + decoding) or\n        prefill requests are not captured.\n\n        Since it is used for decoding-only, it assumes there's only 1 token\n        per sequence in the batch.\n        \"\"\"\n        assert not self.model_config.enforce_eager\n        logger.info(\"Capturing cudagraphs for decoding. This may lead to \"\n                    \"unexpected consequences if the model is not static. To \"\n                    \"run the model in eager mode, set 'enforce_eager=True' or \"\n                    \"use '--enforce-eager' in the CLI. \"\n                    \"If out-of-memory error occurs during cudagraph capture,\"\n                    \" consider decreasing `gpu_memory_utilization` or \"\n                    \"switching to eager mode. You can also reduce the \"\n                    \"`max_num_seqs` as needed to decrease memory usage.\")\n        start_time = time.perf_counter()\n        start_free_gpu_memory = torch.cuda.mem_get_info()[0]\n\n        # Prepare dummy inputs. These will be reused for all batch sizes.\n        max_batch_size = self.max_batchsize_to_capture\n        input_tokens = torch.zeros(max_batch_size,\n                                   dtype=torch.long,\n                                   device=self.device)\n        input_positions = torch.zeros(max_batch_size,\n                                      dtype=torch.long,\n                                      device=self.device)\n        if self.model_config.uses_mrope:\n            input_positions = torch.tile(input_positions,\n                                         (3, 1)).cuda(device=self.device)\n        # Prepare dummy previous_hidden_states only if needed by the model.\n        # This is used by draft models such as EAGLE.\n        previous_hidden_states = None\n        if \"previous_hidden_states\" in inspect.signature(\n                self.model.forward).parameters:\n            previous_hidden_states = torch.empty(\n                [max_batch_size,\n                 self.model_config.get_hidden_size()],\n                dtype=self.model_config.dtype,\n                device=self.device)\n\n        intermediate_inputs = None\n        if not get_pp_group().is_first_rank:\n            intermediate_inputs = self.model.make_empty_intermediate_tensors(\n                batch_size=max_batch_size,\n                dtype=self.model_config.dtype,\n                device=self.device)\n\n        with self.attn_state.graph_capture(max_batch_size), graph_capture(\n                self.device) as graph_capture_context:\n            # NOTE: Capturing the largest batch size first may help reduce the\n            # memory usage of CUDA graph.\n            for virtual_engine in range(\n                    self.parallel_config.pipeline_parallel_size):\n                # Only rank 0 should print progress bar during capture\n                cudagraph_capture_sizes = (tqdm(\n                    self.vllm_config.compilation_config.\n                    cudagraph_capture_sizes,\n                    desc=\"Capturing CUDA graph shapes\",\n                ) if get_tensor_model_parallel_rank() == 0 else\n                                           self.vllm_config.compilation_config.\n                                           cudagraph_capture_sizes)\n                for batch_size in cudagraph_capture_sizes:\n                    attn_metadata = (\n                        self.attn_state.graph_capture_get_metadata_for_batch(\n                            batch_size,\n                            is_encoder_decoder_model=self.model_config.\n                            is_encoder_decoder))\n                    # Disable KV Scale Calculation for graph capture\n                    attn_metadata.enable_kv_scales_calculation = False\n                    if self.lora_config:\n                        lora_mapping = LoRAMapping(\n                            **dict(index_mapping=[0] * batch_size,\n                                   prompt_mapping=[0] * batch_size,\n                                   is_prefill=False))\n                        self.set_active_loras(set(), lora_mapping)\n\n                    if self.prompt_adapter_config:\n                        prompt_adapter_mapping = PromptAdapterMapping(\n                            [-1] * batch_size,\n                            [-1] * batch_size,\n                        )\n                        self.set_active_prompt_adapters(\n                            set(), prompt_adapter_mapping)\n                    graph_runner = CUDAGraphRunner(\n                        self.model, self.attn_backend.get_name(),\n                        self.attn_state.graph_clone(batch_size),\n                        self.model_config.is_encoder_decoder)\n\n                    capture_inputs = {\n                        \"input_ids\":\n                        input_tokens[:batch_size],\n                        \"positions\":\n                        input_positions[..., :batch_size],\n                        \"intermediate_inputs\":\n                        intermediate_inputs[:batch_size]\n                        if intermediate_inputs is not None else None,\n                        \"kv_caches\":\n                        kv_caches[virtual_engine],\n                        \"attn_metadata\":\n                        attn_metadata,\n                        \"memory_pool\":\n                        self.graph_memory_pool,\n                        \"stream\":\n                        graph_capture_context.stream\n                    }\n                    if previous_hidden_states is not None:\n                        capture_inputs[\n                            \"previous_hidden_states\"] = previous_hidden_states[:\n                                                                               batch_size]\n\n                    if self.has_inner_state:\n                        # Only used by Mamba-based models CUDA graph atm (Jamba)\n                        capture_inputs.update({\n                            \"seqlen_agnostic_capture_inputs\":\n                            self.model.get_seqlen_agnostic_capture_inputs(\n                                batch_size)\n                        })\n                    if self.model_config.is_encoder_decoder:\n                        # add the additional inputs to capture for\n                        # encoder-decoder models.\n                        self._update_inputs_to_capture_for_enc_dec_model(\n                            capture_inputs)\n\n                    with set_forward_context(attn_metadata, self.vllm_config,\n                                             virtual_engine):\n                        graph_runner.capture(**capture_inputs)\n                    self.graph_memory_pool = graph_runner.graph.pool()\n                    self.graph_runners[virtual_engine][batch_size] = (\n                        graph_runner)\n\n        end_time = time.perf_counter()\n        end_free_gpu_memory = torch.cuda.mem_get_info()[0]\n        elapsed_time = end_time - start_time\n        cuda_graph_size = start_free_gpu_memory - end_free_gpu_memory\n        # This usually takes < 10 seconds.\n        logger.info(\"Graph capturing finished in %.0f secs, took %.2f GiB\",\n                    elapsed_time, cuda_graph_size / GiB_bytes)\n\n    def _update_inputs_to_capture_for_enc_dec_model(self,\n                                                    capture_inputs: Dict[str,\n                                                                         Any]):\n        \"\"\"\n        Updates the set of input tensors needed for CUDA graph capture in an\n        encoder-decoder model.\n\n        This method modifies the provided `capture_inputs` dictionary by\n        adding tensors specific to encoder-decoder specific models that\n        need to be captured for CUDA Graph replay.\n        \"\"\"\n        # During the decode phase encoder_input_ids and encoder_positions are\n        # unset. Do the same thing for graph capture.\n        capture_inputs[\"encoder_input_ids\"] = torch.tensor([],\n                                                           dtype=torch.long,\n                                                           device=self.device)\n        capture_inputs[\"encoder_positions\"] = torch.tensor([],\n                                                           dtype=torch.long,\n                                                           device=self.device)\n\n    @property\n    def vocab_size(self) -> int:\n        return self.model_config.get_vocab_size()\n\n\nclass ModelRunner(GPUModelRunnerBase[ModelInputForGPUWithSamplingMetadata]):\n    \"\"\"\n    GPU model runner with sampling step.\n    \"\"\"\n    _model_input_cls: Type[ModelInputForGPUWithSamplingMetadata] = (\n        ModelInputForGPUWithSamplingMetadata)\n    _builder_cls: Type[ModelInputForGPUBuilder] = ModelInputForGPUBuilder\n\n    def make_model_input_from_broadcasted_tensor_dict(\n        self,\n        tensor_dict: Dict[str, Any],\n    ) -> ModelInputForGPUWithSamplingMetadata:\n        model_input = \\\n            ModelInputForGPUWithSamplingMetadata.from_broadcasted_tensor_dict(\n                tensor_dict,\n                attn_backend=self.attn_backend,\n            )\n        return model_input\n\n    def prepare_model_input(\n        self,\n        seq_group_metadata_list: List[SequenceGroupMetadata],\n        virtual_engine: int = 0,\n        finished_requests_ids: Optional[List[str]] = None,\n    ) -> ModelInputForGPUWithSamplingMetadata:\n        \"\"\"Prepare the model input based on a given sequence group, including\n        metadata for the sampling step.\n\n        The API assumes seq_group_metadata_list is sorted by prefill -> decode.\n\n        The result tensors and data structure also batches input in prefill\n        -> decode order. For example,\n\n        - input_tokens[:num_prefill_tokens] contains prefill tokens.\n        - input_tokens[num_prefill_tokens:] contains decode tokens.\n\n        If cuda graph is required, this API automatically pads inputs.\n        \"\"\"\n        model_input = self._prepare_model_input_tensors(\n            seq_group_metadata_list, finished_requests_ids)\n        if get_pp_group().is_last_rank:\n            # Sampling metadata is only required for the final pp group\n            generators = self.get_generators(finished_requests_ids)\n            sampling_metadata = SamplingMetadata.prepare(\n                seq_group_metadata_list, model_input.seq_lens,\n                model_input.query_lens, self.device, self.pin_memory,\n                generators, self.sampling_metadata_cache)\n        else:\n            sampling_metadata = None\n        is_prompt = (seq_group_metadata_list[0].is_prompt\n                     if seq_group_metadata_list else None)\n        return dataclasses.replace(model_input,\n                                   sampling_metadata=sampling_metadata,\n                                   is_prompt=is_prompt,\n                                   virtual_engine=virtual_engine)\n\n    @torch.inference_mode()\n    @dump_input_when_exception(exclude_args=[0], exclude_kwargs=[\"self\"])\n    def execute_model(\n        self,\n        model_input: ModelInputForGPUWithSamplingMetadata,\n        kv_caches: List[torch.Tensor],\n        intermediate_tensors: Optional[IntermediateTensors] = None,\n        num_steps: int = 1,\n    ) -> Optional[Union[List[SamplerOutput], IntermediateTensors]]:\n        if num_steps > 1:\n            raise ValueError(\"num_steps > 1 is not supported in ModelRunner\")\n\n        if self.lora_config:\n            assert model_input.lora_requests is not None\n            assert model_input.lora_mapping is not None\n            self.set_active_loras(model_input.lora_requests,\n                                  model_input.lora_mapping)\n\n        if self.prompt_adapter_config:\n            assert model_input.prompt_adapter_requests is not None\n            assert model_input.prompt_adapter_mapping is not None\n            self.set_active_prompt_adapters(\n                model_input.prompt_adapter_requests,\n                model_input.prompt_adapter_mapping)\n\n        self.attn_state.begin_forward(model_input)\n\n        # Currently cuda graph is only supported by the decode phase.\n        assert model_input.attn_metadata is not None\n        prefill_meta = model_input.attn_metadata.prefill_metadata\n        decode_meta = model_input.attn_metadata.decode_metadata\n        # TODO(andoorve): We can remove this once all\n        # virtual engines share the same kv cache.\n        virtual_engine = model_input.virtual_engine\n        if prefill_meta is None and decode_meta.use_cuda_graph:\n            assert model_input.input_tokens is not None\n            graph_batch_size = model_input.input_tokens.shape[0]\n            model_executable = self.graph_runners[virtual_engine][\n                graph_batch_size]\n        else:\n            model_executable = self.model\n\n        # Receive KV cache in distributed KV cache transfer setting\n        # In disagg prefill setting, it will also recv hidden states and bypass\n        # model forwarding\n        # In KV cache database setting, it will change the model input so that\n        # we can skip prefilling on tokens that successfully received KV caches\n        # NOTE: The receive operation is blocking\n        bypass_model_exec = False\n        if self.need_recv_kv(model_input, kv_caches):\n            hidden_or_intermediate_states, bypass_model_exec, model_input = \\\n                get_kv_transfer_group().recv_kv_caches_and_hidden_states(\n                    # model is used to know which layer the current worker\n                    # is working on, so that we can receive KV for only those\n                    # layers.\n                    model_executable,\n                    model_input,\n                    kv_caches=kv_caches\n                )\n\n        multi_modal_kwargs = model_input.multi_modal_kwargs or {}\n        seqlen_agnostic_kwargs = {\n            \"finished_requests_ids\": model_input.finished_requests_ids,\n            \"request_ids_to_seq_ids\": model_input.request_ids_to_seq_ids,\n        } if self.has_inner_state else {}\n        if (self.observability_config is not None\n                and self.observability_config.collect_model_forward_time):\n            model_forward_start = torch.cuda.Event(enable_timing=True)\n            model_forward_end = torch.cuda.Event(enable_timing=True)\n            model_forward_start.record()\n\n        if not bypass_model_exec:\n            with set_forward_context(model_input.attn_metadata,\n                                     self.vllm_config, virtual_engine):\n                hidden_or_intermediate_states = model_executable(\n                    input_ids=model_input.input_tokens,\n                    positions=model_input.input_positions,\n                    kv_caches=kv_caches,\n                    attn_metadata=model_input.attn_metadata,\n                    intermediate_tensors=intermediate_tensors,\n                    **MultiModalKwargs.as_kwargs(multi_modal_kwargs,\n                                                 device=self.device),\n                    **seqlen_agnostic_kwargs)\n\n        if (self.observability_config is not None\n                and self.observability_config.collect_model_forward_time):\n            model_forward_end.record()\n\n        # Sending KV cache in distributed KV cache transfer setting\n        # NOTE: the send operation is non-blocking\n        if self.need_send_kv(model_input, kv_caches):\n            get_kv_transfer_group().send_kv_caches_and_hidden_states(\n                # model_executable is used to know which layer the current\n                # worker is working on, so that we can send KV for only those\n                # layers.\n                model_executable,\n                model_input,\n                kv_caches,\n                hidden_or_intermediate_states,\n            )\n\n        # Compute the logits in the last pipeline stage.\n        if not get_pp_group().is_last_rank:\n            if (self.is_driver_worker\n                    and hidden_or_intermediate_states is not None\n                    and isinstance(hidden_or_intermediate_states,\n                                   IntermediateTensors)\n                    and self.observability_config is not None\n                    and self.observability_config.collect_model_forward_time):\n                model_forward_end.synchronize()\n                model_forward_time = model_forward_start.elapsed_time(\n                    model_forward_end)\n                orig_model_forward_time = 0.0\n                if intermediate_tensors is not None:\n                    orig_model_forward_time = intermediate_tensors.tensors.get(\n                        \"model_forward_time\", torch.tensor(0.0)).item()\n                hidden_or_intermediate_states.tensors[\"model_forward_time\"] = (\n                    torch.tensor(model_forward_time + orig_model_forward_time))\n            return hidden_or_intermediate_states\n\n        logits = self.model.compute_logits(hidden_or_intermediate_states,\n                                           model_input.sampling_metadata)\n\n        if not self.is_driver_worker:\n            return []\n\n        if model_input.async_callback is not None:\n            model_input.async_callback()\n\n        # Sample the next token.\n        output: SamplerOutput = self.model.sample(\n            logits=logits,\n            sampling_metadata=model_input.sampling_metadata,\n        )\n        if (self.observability_config is not None\n                and self.observability_config.collect_model_forward_time\n                and output is not None):\n            model_forward_end.synchronize()\n            model_forward_time = model_forward_start.elapsed_time(\n                model_forward_end)\n            orig_model_forward_time = 0.0\n            if intermediate_tensors is not None:\n                orig_model_forward_time = intermediate_tensors.tensors.get(\n                    \"model_forward_time\", torch.tensor(0.0)).item()\n            # If there are multiple workers, we are still tracking the latency\n            # from the start time of the driver worker to the end time of the\n            # driver worker. The model forward time will then end up covering\n            # the communication time as well.\n            output.model_forward_time = (orig_model_forward_time +\n                                         model_forward_time)\n\n        if self.return_hidden_states:\n            # we only need to pass hidden states of most recent token\n            assert model_input.sampling_metadata is not None\n            indices = model_input.sampling_metadata.selected_token_indices\n            if model_input.is_prompt:\n                hidden_states = hidden_or_intermediate_states.index_select(\n                    0, indices)\n                output.prefill_hidden_states = hidden_or_intermediate_states\n            elif decode_meta.use_cuda_graph:\n                hidden_states = hidden_or_intermediate_states[:len(indices)]\n            else:\n                hidden_states = hidden_or_intermediate_states\n\n            output.hidden_states = hidden_states\n\n        return [output]\n\n    def need_recv_kv(self, model_input, kv_caches) -> bool:\n        \"\"\"Check if we need to receive kv-cache from the other worker.\n        We need to receive KV when\n            1. current vLLM instance is KV cache consumer/decode vLLM instance\n            2. this batch is not a profiling run\n            3. this batch is a prefill run\n            \n        Args:\n            model_input: input to the model executable\n            kv_caches: vLLM's paged memory\n        \"\"\"\n\n        if self.vllm_config.kv_transfer_config is None:\n            return False\n\n        prefill_meta = model_input.attn_metadata.prefill_metadata\n\n        # check if the current run is profiling\n        is_profile_run = (kv_caches[0].numel() == 0)\n        # check if the current run is prefill\n        is_prefill_run = prefill_meta is not None\n\n        return self.vllm_config.kv_transfer_config.is_kv_consumer and (\n            not is_profile_run) and is_prefill_run\n\n    def need_send_kv(self, model_input, kv_caches) -> bool:\n        \"\"\"Check if we need to send kv-cache to the other worker.\n        We need to send KV when\n            1. current vLLM instance is KV cache producer/prefill vLLM instance\n            2. this batch is not a profiling run\n            3. this batch is a prefill run\n            \n        Args:\n            model_input: input to the model executable\n            kv_caches: vLLM's paged memory\n        \"\"\"\n\n        if self.vllm_config.kv_transfer_config is None:\n            return False\n\n        prefill_meta = model_input.attn_metadata.prefill_metadata\n\n        # check if the current run is profiling\n        is_profile_run = (kv_caches[0].numel() == 0)\n        # check if the current run is prefill\n        is_prefill_run = prefill_meta is not None\n\n        return self.vllm_config.kv_transfer_config.is_kv_producer and (\n            not is_profile_run) and is_prefill_run\n\n\n# NOTE: this is nn.Module so the profiler can properly capture/group\n#  kernels calls made within the graph\nclass CUDAGraphRunner(nn.Module):\n\n    def __init__(self, model: nn.Module, backend_name: str,\n                 attn_state: AttentionState, is_encoder_decoder_model: bool):\n        super().__init__()\n        self.model = model\n        self.backend_name = backend_name\n        self.attn_state = attn_state\n\n        self.input_buffers: Dict[str, torch.Tensor] = {}\n        self.output_buffers: Dict[str, torch.Tensor] = {}\n\n        self._graph: Optional[torch.cuda.CUDAGraph] = None\n        self._is_encoder_decoder_model = is_encoder_decoder_model\n\n    @property\n    def graph(self):\n        assert self._graph is not None\n        return self._graph\n\n    def capture(\n        self,\n        input_ids: torch.Tensor,\n        positions: torch.Tensor,\n        intermediate_inputs: Optional[IntermediateTensors],\n        kv_caches: List[torch.Tensor],\n        attn_metadata: AttentionMetadata,\n        memory_pool: Optional[Tuple[int, int]],\n        stream: torch.cuda.Stream,\n        **kwargs,\n    ):\n        assert self._graph is None\n        # Run the model a few times without capturing the graph.\n        # This is to make sure that the captured graph does not include the\n        # kernel launches for initial benchmarking (e.g., Triton autotune).\n        # Note one iteration is not enough for torch.compile\n        for _ in range(_NUM_WARMUP_ITERS):\n            self.model(\n                input_ids=input_ids,\n                positions=positions,\n                kv_caches=kv_caches,\n                attn_metadata=attn_metadata,\n                intermediate_tensors=intermediate_inputs,\n                **kwargs,\n            )\n        # Wait for the warm up operations to finish before proceeding with\n        # Graph Capture.\n        torch.cuda.synchronize()\n        # Capture the graph.\n        self._graph = torch.cuda.CUDAGraph()\n        with torch.cuda.graph(self._graph, pool=memory_pool, stream=stream):\n            output_hidden_or_intermediate_states = self.model(\n                input_ids=input_ids,\n                positions=positions,\n                kv_caches=kv_caches,\n                attn_metadata=attn_metadata,\n                intermediate_tensors=intermediate_inputs,\n                **kwargs,\n            )\n\n            if isinstance(output_hidden_or_intermediate_states, torch.Tensor):\n                hidden_or_intermediate_states = weak_ref_tensor(\n                    output_hidden_or_intermediate_states)\n            elif isinstance(output_hidden_or_intermediate_states,\n                            IntermediateTensors):\n                hidden_or_intermediate_states = IntermediateTensors(\n                    tensors={\n                        key: weak_ref_tensor(value)\n                        for key, value in\n                        output_hidden_or_intermediate_states.tensors.items()\n                    })\n\n            del output_hidden_or_intermediate_states\n            # make sure `output_hidden_or_intermediate_states` is deleted\n            # in the graph's memory pool\n            gc.collect()\n        torch.cuda.synchronize()\n\n        # Save the input and output buffers.\n        self.input_buffers = {\n            \"input_ids\":\n            input_ids,\n            \"positions\":\n            positions,\n            \"kv_caches\":\n            kv_caches,\n            **self.attn_state.get_graph_input_buffers(\n                attn_metadata, self._is_encoder_decoder_model),\n            **kwargs,\n        }\n        if intermediate_inputs is not None:\n            self.input_buffers.update(intermediate_inputs.tensors)\n        if get_pp_group().is_last_rank:\n            self.output_buffers = {\n                \"hidden_states\": hidden_or_intermediate_states\n            }\n        else:\n            self.output_buffers = hidden_or_intermediate_states\n\n    def forward(\n        self,\n        input_ids: torch.Tensor,\n        positions: torch.Tensor,\n        kv_caches: List[torch.Tensor],\n        attn_metadata: AttentionMetadata,\n        intermediate_tensors: Optional[IntermediateTensors],\n        **kwargs,\n    ) -> torch.Tensor:\n        # KV caches are fixed tensors, so we don't need to copy them.\n        del kv_caches\n\n        # Copy the input tensors to the input buffers.\n        self.input_buffers[\"input_ids\"].copy_(input_ids, non_blocking=True)\n        self.input_buffers[\"positions\"].copy_(positions, non_blocking=True)\n\n        if self.backend_name != \"NO_ATTENTION\":\n            self.input_buffers[\"slot_mapping\"].copy_(\n                attn_metadata.slot_mapping, non_blocking=True)\n\n        self.attn_state.prepare_graph_input_buffers(\n            self.input_buffers, attn_metadata, self._is_encoder_decoder_model)\n\n        if \"seqlen_agnostic_capture_inputs\" in self.input_buffers:\n            self.model.copy_inputs_before_cuda_graphs(self.input_buffers,\n                                                      **kwargs)\n\n        if \"previous_hidden_states\" in self.input_buffers:\n            self.input_buffers[\"previous_hidden_states\"].copy_(\n                kwargs[\"previous_hidden_states\"], non_blocking=True)\n\n        if intermediate_tensors is not None:\n            for key in intermediate_tensors.tensors:\n                if key != \"model_execute_time\" and key != \"model_forward_time\":\n                    self.input_buffers[key].copy_(intermediate_tensors[key],\n                                                  non_blocking=True)\n        if self._is_encoder_decoder_model:\n            self.input_buffers[\"encoder_input_ids\"].copy_(\n                kwargs['encoder_input_ids'], non_blocking=True)\n            self.input_buffers[\"encoder_positions\"].copy_(\n                kwargs['encoder_positions'], non_blocking=True)\n\n        # Run the graph.\n        self.graph.replay()\n        # Return the output tensor.\n        if get_pp_group().is_last_rank:\n            return self.output_buffers[\"hidden_states\"]\n\n        return self.output_buffers\n",
      "diff": "diff --git a/vllm/worker/model_runner.py b/vllm/worker/model_runner.py\nindex cf2f1c6b3..bf1a40d48 100644\n--- a/vllm/worker/model_runner.py\n+++ b/vllm/worker/model_runner.py\n@@ -455,7 +455,6 @@ class ModelInputForGPUBuilder(ModelRunnerInputBuilderBase[ModelInputForGPU]):\n         self.enable_prompt_adapter = (self.runner.prompt_adapter_config\n                                       is not None)\n         self.multi_modal_input_mapper = self.runner.multi_modal_input_mapper\n-        self.decode_only = True\n \n         # Attention metadata inputs.\n         if self.attn_backend is not None:\n@@ -477,6 +476,10 @@ class ModelInputForGPUBuilder(ModelRunnerInputBuilderBase[ModelInputForGPU]):\n                 finished_requests_ids: Optional[List[str]] = None) -> None:\n         self.finished_requests_ids = finished_requests_ids\n \n+        # if the current batch is decode-only.\n+        # will be set to False if there is any non-decode request.\n+        self.decode_only = True\n+\n         # Intermediate data (data in CPU before going to GPU) for\n         # the current sequence group.\n         self.inter_data_list: List[",
      "change_type": "modified",
      "lines_added": 5,
      "lines_removed": 2
    }
  ],
  "affected_apis": [
    "ModelInputForGPUBuilder.__init__",
    "ModelInputForGPUBuilder.reset"
  ],
  "summary": {
    "total_files": 1,
    "files_added": 0,
    "files_deleted": 0,
    "files_modified": 1
  },
  "csv_metadata": {
    "category": "model-based",
    "json_has_tests": "FALSE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "YES (test_model_runner)",
    "is_benchmark_actually_there": "",
    "sample_clues": "init, model, model_runner"
  }
}