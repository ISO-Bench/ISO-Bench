{
  "commit_hash": "6ce01f30667bbae33f112152e07a3b66b841078f",
  "parent_hash": "6a11fdfbb8d6701c7ad38648aead23d8cbe6aac5",
  "message": "[Performance] Optimize `get_seqs` (#7051)",
  "author": "Woosuk Kwon <woosuk.kwon@berkeley.edu>",
  "date": "2024-08-01 18:29:52 -0700",
  "files_changed": [
    {
      "file_path": "vllm/core/block_manager_v1.py",
      "old_content": "\"\"\"A block manager that manages token blocks.\"\"\"\nimport math\nfrom abc import ABC, abstractmethod\nfrom itertools import count, takewhile\nfrom os.path import commonprefix\nfrom typing import Dict, List, Optional\nfrom typing import Sequence as GenericSequence\nfrom typing import Set, Tuple\n\nfrom vllm.block import BlockTable, PhysicalTokenBlock\nfrom vllm.core.block.utils import check_no_caching_or_swa_for_blockmgr_encdec\nfrom vllm.core.evictor_v1 import EvictionPolicy, Evictor, make_evictor\nfrom vllm.core.interfaces import AllocStatus, BlockSpaceManager\nfrom vllm.logger import init_logger\nfrom vllm.sequence import Sequence, SequenceGroup, SequenceStatus\nfrom vllm.utils import Device\n\nlogger = init_logger(__name__)\n\n\nclass BlockAllocatorBase(ABC):\n    \"\"\"Manages free physical token blocks for a device.\n\n    The allocator maintains a list of free blocks and allocates a block when\n    requested. When a block is freed, its reference count is decremented. If\n    the reference count becomes zero, the block is added back to the free list.\n    \"\"\"\n\n    @abstractmethod\n    def __init__(self,\n                 device: Device,\n                 block_size: int,\n                 num_blocks: int,\n                 eviction_policy: EvictionPolicy = EvictionPolicy.LRU):\n        pass\n\n    @abstractmethod\n    def allocate(self,\n                 block_hash: Optional[int] = None,\n                 num_hashed_tokens: int = 0) -> PhysicalTokenBlock:\n        pass\n\n    @abstractmethod\n    def free(self, block: PhysicalTokenBlock) -> None:\n        pass\n\n    @abstractmethod\n    def get_num_free_blocks(self) -> int:\n        pass\n\n    @abstractmethod\n    def get_num_total_blocks(self) -> int:\n        pass\n\n    @abstractmethod\n    def contains_block(self, block_hash: int) -> bool:\n        pass\n\n    @abstractmethod\n    def update_hash(self, block_hash: int, block: PhysicalTokenBlock):\n        pass\n\n\nclass CachedBlockAllocator(BlockAllocatorBase):\n    \"\"\"Manages free physical token blocks for a device.\n\n    The allocator maintains a list of free blocks and allocates a block when\n    requested. When a block is freed, its reference count is decremented. If\n    the reference count becomes zero, the block is added back to the free list.\n    \"\"\"\n\n    def __init__(self,\n                 device: Device,\n                 block_size: int,\n                 num_blocks: int,\n                 eviction_policy: EvictionPolicy = EvictionPolicy.LRU) -> None:\n        self.device = device\n        self.block_size = block_size\n        self.num_blocks = num_blocks\n\n        self.current_num_blocks = 0\n        self.cached_blocks: Dict[int, PhysicalTokenBlock] = {}\n\n        self.evictor: Evictor = make_evictor(eviction_policy)\n\n        self.default_hash_ctr = count()\n\n    def allocate_block(self, block_hash: int,\n                       num_hashed_tokens: int) -> PhysicalTokenBlock:\n        if self.current_num_blocks == self.num_blocks:\n            block = self.evictor.evict()\n            block.block_hash = block_hash\n            block.num_hashed_tokens = num_hashed_tokens\n            return block\n        block = PhysicalTokenBlock(device=self.device,\n                                   block_number=self.current_num_blocks,\n                                   block_size=self.block_size,\n                                   block_hash=block_hash,\n                                   num_hashed_tokens=num_hashed_tokens)\n        self.current_num_blocks += 1\n        return block\n\n    def allocate(self,\n                 block_hash: Optional[int] = None,\n                 num_hashed_tokens: int = 0) -> PhysicalTokenBlock:\n        if block_hash is None:\n            block_hash = next(self.default_hash_ctr)\n        if block_hash in self.evictor:\n            assert block_hash not in self.cached_blocks\n            block = self.evictor.remove(block_hash)\n            assert block.ref_count == 0\n            self.cached_blocks[block_hash] = block\n            block.ref_count += 1\n            assert block.block_hash == block_hash\n            return block\n        if block_hash not in self.cached_blocks:\n            self.cached_blocks[block_hash] = self.allocate_block(\n                block_hash, num_hashed_tokens)\n        block = self.cached_blocks[block_hash]\n        assert block.block_hash == block_hash\n        block.ref_count += 1\n        return block\n\n    def free(self, block: PhysicalTokenBlock) -> None:\n        if block.ref_count == 0:\n            raise ValueError(f\"Double free! {block} is already freed.\")\n        block.ref_count -= 1\n        if block.ref_count == 0:\n            assert block.block_hash not in self.evictor\n            self.evictor.add(block)\n\n            # Remove the block from the cached_blocks\n            del self.cached_blocks[block.block_hash]\n\n    def get_num_free_blocks(self) -> int:\n        return (self.num_blocks - self.current_num_blocks +\n                self.evictor.num_blocks)\n\n    def get_num_total_blocks(self) -> int:\n        return self.num_blocks\n\n    def contains_block(self, block_hash: int) -> bool:\n        return block_hash in self.cached_blocks or block_hash in self.evictor\n\n    def update_hash(self, block_hash: int, block: PhysicalTokenBlock):\n        # Update the hash of block and the cached_blocks dictionary.\n        assert not self.contains_block(block_hash)\n        old_hash = block.block_hash\n        block.block_hash = block_hash\n        del self.cached_blocks[old_hash]\n        self.cached_blocks[block_hash] = block\n\n\nclass UncachedBlockAllocator(BlockAllocatorBase):\n    \"\"\"Manages free physical token blocks for a device.\n\n    The allocator maintains a list of free blocks and allocates a block when\n    requested. When a block is freed, its reference count is decremented. If\n    the reference count becomes zero, the block is added back to the free list.\n    \"\"\"\n\n    def __init__(\n        self,\n        device: Device,\n        block_size: int,\n        num_blocks: int,\n    ) -> None:\n        self.device = device\n        self.block_size = block_size\n        self.num_blocks = num_blocks\n\n        # Initialize the free blocks.\n        self.free_blocks: BlockTable = []\n        for i in range(num_blocks):\n            block = PhysicalTokenBlock(device=device,\n                                       block_number=i,\n                                       block_size=block_size,\n                                       block_hash=-1,\n                                       num_hashed_tokens=0)\n            self.free_blocks.append(block)\n\n    def allocate(self,\n                 block_hash: Optional[int] = None,\n                 num_hashed_tokens: int = 0) -> PhysicalTokenBlock:\n        if not self.free_blocks:\n            raise ValueError(\"Out of memory! No free blocks are available.\")\n        block = self.free_blocks.pop()\n        block.ref_count = 1\n        return block\n\n    def free(self, block: PhysicalTokenBlock) -> None:\n        if block.ref_count == 0:\n            raise ValueError(f\"Double free! {block} is already freed.\")\n        block.ref_count -= 1\n        if block.ref_count == 0:\n            self.free_blocks.append(block)\n\n    def get_num_free_blocks(self) -> int:\n        return len(self.free_blocks)\n\n    def get_num_total_blocks(self) -> int:\n        return self.num_blocks\n\n    def contains_block(self, block_hash: int) -> bool:\n        raise NotImplementedError(\n            \"Invalid codepath for uncached block allocator.\")\n\n    def update_hash(self, block_hash: int, block: PhysicalTokenBlock):\n        raise NotImplementedError(\n            \"Invalid codepath for uncached block allocator.\")\n\n\nclass BlockSpaceManagerV1(BlockSpaceManager):\n    \"\"\"Manages the mapping between logical and physical token blocks.\"\"\"\n\n    def __init__(\n        self,\n        block_size: int,\n        num_gpu_blocks: int,\n        num_cpu_blocks: int,\n        watermark: float = 0.01,\n        sliding_window: Optional[int] = None,\n        enable_caching: bool = False,\n    ) -> None:\n        self.block_size = block_size\n        self.num_total_gpu_blocks = num_gpu_blocks\n        self.num_total_cpu_blocks = num_cpu_blocks\n\n        if enable_caching and sliding_window is not None:\n            raise NotImplementedError(\n                \"Sliding window is not allowed with prefix caching enabled!\")\n\n        self.block_sliding_window = None\n        if sliding_window is not None:\n            # Round up to nearest block size to regularize sliding window\n            # allocation sizes.\n            self.block_sliding_window = math.ceil(sliding_window / block_size)\n\n        self.watermark = watermark\n        assert watermark >= 0.0\n\n        self.enable_caching = enable_caching\n\n        self.watermark_blocks = int(watermark * num_gpu_blocks)\n\n        if self.enable_caching:\n            logger.info(\"Automatic prefix caching is enabled.\")\n            self.gpu_allocator: BlockAllocatorBase = CachedBlockAllocator(\n                Device.GPU, block_size, num_gpu_blocks)\n            self.cpu_allocator: BlockAllocatorBase = CachedBlockAllocator(\n                Device.CPU, block_size, num_cpu_blocks)\n        else:\n            self.gpu_allocator = UncachedBlockAllocator(\n                Device.GPU, block_size, num_gpu_blocks)\n            self.cpu_allocator = UncachedBlockAllocator(\n                Device.CPU, block_size, num_cpu_blocks)\n        # Mapping: seq_id -> BlockTable.\n        self.block_tables: Dict[int, BlockTable] = {}\n        # Mapping: req_id -> BlockTable\n        # Note that each SequenceGroup has a unique\n        # request ID\n        self.cross_block_tables: Dict[str, BlockTable] = {}\n\n    def _get_seq_num_required_blocks(self, seq: Sequence) -> int:\n        return 0 if seq is None else seq.n_blocks\n\n    def can_allocate(self, seq_group: SequenceGroup) -> AllocStatus:\n        # FIXME(woosuk): Here we assume that all sequences in the group share\n        # the same prompt. This may not be true for preempted sequences.\n\n        check_no_caching_or_swa_for_blockmgr_encdec(self, seq_group)\n\n        self_num_required_blocks = self._get_seq_num_required_blocks(\n            seq_group.get_seqs(status=SequenceStatus.WAITING)[0])\n        cross_num_required_blocks = self._get_seq_num_required_blocks(\n            seq_group.get_encoder_seq())\n        num_required_blocks = self_num_required_blocks + \\\n                              cross_num_required_blocks\n\n        if self.block_sliding_window is not None:\n\n            num_required_blocks = min(num_required_blocks,\n                                      self.block_sliding_window)\n        num_free_gpu_blocks = self.gpu_allocator.get_num_free_blocks()\n\n        # Use watermark to avoid frequent cache eviction.\n        if (self.num_total_gpu_blocks - num_required_blocks <\n                self.watermark_blocks):\n            return AllocStatus.NEVER\n        if num_free_gpu_blocks - num_required_blocks >= self.watermark_blocks:\n            return AllocStatus.OK\n        else:\n            return AllocStatus.LATER\n\n    def _allocate_sequence(self, \\\n                           seq: Sequence, \\\n                           ref_count: int, \\\n                           is_encoder_decoder: bool = True) -> BlockTable:\n        # Allocate new physical token blocks that will store the prompt tokens.\n        num_prompt_blocks = seq.n_blocks\n\n        block_table: BlockTable = []\n        for logical_idx in range(num_prompt_blocks):\n            if (self.block_sliding_window is not None\n                    and logical_idx >= self.block_sliding_window):\n                block = block_table[logical_idx % self.block_sliding_window]\n                # Set the reference counts of the token blocks.\n                block.ref_count = ref_count\n            elif not is_encoder_decoder and self.enable_caching:\n                block = self.gpu_allocator.allocate(\n                    seq.hash_of_block(logical_idx),\n                    seq.num_hashed_tokens_of_block(logical_idx))\n            else:\n                block = self.gpu_allocator.allocate()\n                # Set the reference counts of the token blocks.\n                block.ref_count = ref_count\n            block_table.append(block)\n\n        return block_table\n\n    def allocate(self, seq_group: SequenceGroup) -> None:\n        is_encoder_decoder = seq_group.is_encoder_decoder()\n        check_no_caching_or_swa_for_blockmgr_encdec(self, seq_group)\n\n        # Allocate decoder sequences\n        #\n        # NOTE: Here we assume that all sequences in the group have the same\n        # decoder prompt.\n        seq = seq_group.get_seqs(status=SequenceStatus.WAITING)[0]\n        block_table: BlockTable = \\\n            self._allocate_sequence(seq,\n                                    seq_group.num_seqs(),\n                                    is_encoder_decoder)\n\n        # Assign the self-attention block tables for each sequence.\n        for seq in seq_group.get_seqs(status=SequenceStatus.WAITING):\n            self.block_tables[seq.seq_id] = block_table.copy()\n\n        # Allocate encoder sequence\n        if is_encoder_decoder:\n            # A SequenceGroup has only a single encoder sequence (at most),\n            # thus allocate with a ref count of 1\n            block_table = self._allocate_sequence(seq_group.get_encoder_seq(),\n                                                  1, is_encoder_decoder)\n            # Assign the cross-attention block table for the SequenceGroup.\n            self.cross_block_tables[seq_group.request_id] = block_table\n\n    def can_append_slots(self,\n                         seq_group: SequenceGroup,\n                         num_lookahead_slots: int = 0) -> bool:\n        assert (num_lookahead_slots == 0\n                ), \"lookahead allocation not supported in BlockSpaceManagerV1\"\n\n        # Simple heuristic: If there is at least one free block\n        # for each sequence, we can append.\n        num_free_gpu_blocks = self.gpu_allocator.get_num_free_blocks()\n        num_seqs = seq_group.num_seqs(status=SequenceStatus.RUNNING)\n        return num_seqs <= num_free_gpu_blocks\n\n    def _promote_last_block(\n        self,\n        seq: Sequence,\n        last_block: PhysicalTokenBlock,\n    ) -> PhysicalTokenBlock:\n        assert self.enable_caching\n\n        # Compute a new hash for the block so that it can be shared by other\n        # Sequences\n        new_hash = seq.hash_of_block(seq.n_blocks - 1)\n\n        # if new_hash is already in the cached table, then free last_block\n        # and return the cached version\n        if self.gpu_allocator.contains_block(new_hash):\n            self.gpu_allocator.free(last_block)\n            return self.gpu_allocator.allocate(new_hash)\n        else:\n            self.gpu_allocator.update_hash(new_hash, last_block)\n            return last_block\n\n    def _is_last_block_full(\n        self,\n        seq: Sequence,\n    ) -> bool:\n        token_ids_len = seq.data.get_len()\n        return token_ids_len > 0 and token_ids_len % seq.block_size == 0\n\n    def _maybe_promote_last_block(\n        self,\n        seq: Sequence,\n        last_block: PhysicalTokenBlock,\n    ) -> PhysicalTokenBlock:\n        if self._is_last_block_full(seq):\n            return self._promote_last_block(seq, last_block)\n        else:\n            return last_block\n\n    def _allocate_last_physical_block(\n        self,\n        seq: Sequence,\n    ) -> PhysicalTokenBlock:\n        # Called before a new block is appended.\n        # This is in charge of allocating a new physical block (to be appended).\n\n        # None if the last block is not full. Otherwise, we set it to the\n        # content hash.\n        if not self.enable_caching:\n            return self.gpu_allocator.allocate()\n        block_hash: Optional[int] = None\n        n_blocks = seq.n_blocks\n        if (self._is_last_block_full(seq)):\n            block_hash = seq.hash_of_block(n_blocks - 1)\n        num_hashed_tokens = seq.num_hashed_tokens_of_block(n_blocks - 1)\n\n        # num_hashed_tokens is used to compute future hashes\n        # (e.g. in the hashing function, it is used to ask the sequence for\n        # prefix tokens)\n        new_block = self.gpu_allocator.allocate(block_hash, num_hashed_tokens)\n\n        # If the block has is None, then the block is not full.\n        # If the block is not full, then we expect it to have a refcount of 1.\n        if block_hash is None:\n            assert new_block.ref_count == 1\n        return new_block\n\n    def append_slots(\n        self,\n        seq: Sequence,\n        num_lookahead_slots: int = 0,\n    ) -> List[Tuple[int, int]]:\n        \"\"\"Allocate a physical slot for a new token.\"\"\"\n        n_blocks = seq.n_blocks\n        block_table = self.block_tables[seq.seq_id]\n        # If we need to allocate a new physical block\n        if len(block_table) < n_blocks:\n            # Currently this code only supports adding one physical block\n            assert len(block_table) == n_blocks - 1\n\n            if (self.block_sliding_window\n                    and len(block_table) >= self.block_sliding_window):\n                # reuse a block\n                block_table.append(block_table[len(block_table) %\n                                               self.block_sliding_window])\n            else:\n                # The sequence hash a new logical block.\n                # Allocate a new physical block.\n                new_block = self._allocate_last_physical_block(seq)\n                block_table.append(new_block)\n                return []\n\n        # We want to append the token to the last physical block.\n        last_block = block_table[-1]\n        assert last_block.device == Device.GPU\n        if last_block.ref_count == 1:\n            # Not shared with other sequences. Appendable.\n            if self.enable_caching:\n                # If the last block is now complete, we may reuse an old block\n                # to save memory.\n                maybe_new_block = self._maybe_promote_last_block(\n                    seq, last_block)\n                block_table[-1] = maybe_new_block\n            return []\n        else:\n            # The last block is shared with other sequences.\n            # Copy on Write: Allocate a new block and copy the tokens.\n            new_block = self._allocate_last_physical_block(seq)\n\n            block_table[-1] = new_block\n            self.gpu_allocator.free(last_block)\n            return [(last_block.block_number, new_block.block_number)]\n\n    def fork(self, parent_seq: Sequence, child_seq: Sequence) -> None:\n        # NOTE: fork does not allocate a new physical block.\n        # Thus, it is always safe from OOM.\n        if parent_seq.seq_id not in self.block_tables:\n            # Parent sequence has either been freed or never existed.\n            return\n        src_block_table = self.block_tables[parent_seq.seq_id]\n        self.block_tables[child_seq.seq_id] = src_block_table.copy()\n        # When using a sliding window, blocks will be eventually reused.\n        # In this case the block tables will contain repeated blocks.\n        # When forking, we must make sure that each block's `ref_count`\n        # is only incremented by one, so we deduplicate them by wrapping\n        # them in a set.\n        for block in set(src_block_table):\n            block.ref_count += 1\n\n    def _get_physical_blocks(\n            self, seq_group: SequenceGroup) -> List[PhysicalTokenBlock]:\n\n        # NOTE: Here, we assume that the physical blocks are only shared by\n        # the sequences in the same group.\n        request_id = seq_group.request_id\n        blocks: Set[PhysicalTokenBlock] = set()\n        for seq in seq_group.get_seqs():\n            if seq.is_finished():\n                continue\n            blocks.update(self.block_tables[seq.seq_id])\n        # Cross-attention blocks\n        if seq_group.is_encoder_decoder():\n            blocks.update(self.cross_block_tables[request_id])\n        return list(blocks)\n\n    def can_swap_in(self,\n                    seq_group: SequenceGroup,\n                    num_lookahead_slots: int = 0) -> AllocStatus:\n        assert (num_lookahead_slots == 0\n                ), \"BlockSpaceManagerV1 does not support lookahead allocation\"\n\n        blocks = self._get_physical_blocks(seq_group)\n        num_swapped_seqs = seq_group.num_seqs(status=SequenceStatus.SWAPPED)\n        if seq_group.is_encoder_decoder():\n            num_swapped_seqs += 1\n        num_free_blocks = self.gpu_allocator.get_num_free_blocks()\n        # NOTE: Conservatively, we assume that every sequence will allocate\n        # at least one free block right after the swap-in.\n        # NOTE: This should match the logic in can_append_slot().\n        num_required_blocks = len(blocks) + num_swapped_seqs\n        if self.gpu_allocator.get_num_total_blocks() < num_required_blocks:\n            return AllocStatus.NEVER\n        elif num_free_blocks - num_required_blocks >= self.watermark_blocks:\n            return AllocStatus.OK\n        else:\n            return AllocStatus.LATER\n\n    def _swap_block_table(\n            self, block_table: BlockTable, src_allocator: BlockAllocatorBase,\n            dest_allocator: BlockAllocatorBase,\n            mapping: Dict[PhysicalTokenBlock,\n                          PhysicalTokenBlock]) -> BlockTable:\n        new_block_table = []\n\n        for from_block in block_table:\n            if from_block in mapping:\n                to_block = mapping[from_block]\n                to_block.ref_count += 1\n            else:\n                to_block = dest_allocator.allocate(\n                    from_block.block_hash, from_block.num_hashed_tokens)\n                mapping[from_block] = to_block\n            new_block_table.append(to_block)\n            # Free the source block swapped in to destination.\n            src_allocator.free(from_block)\n\n        return new_block_table\n\n    def swap_in(self, seq_group: SequenceGroup) -> List[Tuple[int, int]]:\n\n        request_id = seq_group.request_id\n\n        # CPU block -> GPU block.\n        # dict is efficient in lookup `if cpu_block in mapping`\n        mapping: Dict[PhysicalTokenBlock, PhysicalTokenBlock] = {}\n        for seq in seq_group.get_seqs(status=SequenceStatus.SWAPPED):\n            self.block_tables[seq.seq_id] = \\\n                self._swap_block_table(self.block_tables[seq.seq_id],\n                                       self.cpu_allocator,\n                                       self.gpu_allocator,\n                                       mapping)\n\n        if seq_group.is_encoder_decoder():\n            self.cross_block_tables[request_id] = \\\n                self._swap_block_table(self.cross_block_tables[request_id],\n                                       self.cpu_allocator,\n                                       self.gpu_allocator,\n                                       mapping)\n\n        return [(cpu_block.block_number, gpu_block.block_number)\n                for cpu_block, gpu_block in mapping.items()]\n\n    def can_swap_out(self, seq_group: SequenceGroup) -> bool:\n        blocks = self._get_physical_blocks(seq_group)\n        return len(blocks) <= self.cpu_allocator.get_num_free_blocks()\n\n    def swap_out(self, seq_group: SequenceGroup) -> List[Tuple[int, int]]:\n        request_id = seq_group.request_id\n\n        # GPU block -> CPU block.\n        # dict is efficient in lookup `if gpu_block in mapping`\n        mapping: Dict[PhysicalTokenBlock, PhysicalTokenBlock] = {}\n        for seq in seq_group.get_seqs(status=SequenceStatus.RUNNING):\n            self.block_tables[seq.seq_id] = \\\n                self._swap_block_table(self.block_tables[seq.seq_id],\n                                       self.gpu_allocator,\n                                       self.cpu_allocator,\n                                       mapping)\n\n        if seq_group.is_encoder_decoder():\n            self.cross_block_tables[request_id] = \\\n                self._swap_block_table(self.cross_block_tables[request_id],\n                                       self.gpu_allocator,\n                                       self.cpu_allocator,\n                                       mapping)\n\n        return [(cpu_block.block_number, gpu_block.block_number)\n                for cpu_block, gpu_block in mapping.items()]\n\n    def _free_block_table(self, block_table: BlockTable) -> None:\n        # when using a sliding window, each seq will only use up\n        # to `self.block_sliding_window` blocks. When freeing\n        # the block table, we must make sure to not free blocks more\n        # than once. If no sliding window is used, there is no block\n        # reuse in the block table, so we must free all blocks.\n        blocks_to_free = (block_table[-self.block_sliding_window:]\n                          if self.block_sliding_window is not None else\n                          block_table)\n        for block in set(blocks_to_free):\n            if block.device == Device.GPU:\n                self.gpu_allocator.free(block)\n            else:\n                self.cpu_allocator.free(block)\n\n    def free(self, seq: Sequence) -> None:\n        if seq.seq_id not in self.block_tables:\n            # Already freed or haven't been scheduled yet.\n            return\n        block_table = self.block_tables[seq.seq_id]\n        self._free_block_table(block_table)\n        del self.block_tables[seq.seq_id]\n\n    def free_cross(self, seq_group: SequenceGroup) -> None:\n        if seq_group.request_id not in self.cross_block_tables:\n            # Already freed or hasn't ben scheduled yet.\n            return\n        block_table = self.cross_block_tables[seq_group.request_id]\n        self._free_block_table(block_table)\n        del self.cross_block_tables[seq_group.request_id]\n\n    def reset(self) -> None:\n        # Free decoder block tables\n        for block_table in self.block_tables.values():\n            self._free_block_table(block_table)\n        self.block_tables.clear()\n        # Free cross-attention block tables\n        for block_table in self.cross_block_tables.values():\n            self._free_block_table(block_table)\n        self.cross_block_tables.clear()\n\n    def get_block_table(self, seq: Sequence) -> List[int]:\n        block_table = self.block_tables[seq.seq_id]\n        return [block.block_number for block in block_table]\n\n    def get_cross_block_table(self, seq_group: SequenceGroup) -> List[int]:\n        block_table = self.cross_block_tables[seq_group.request_id]\n        return [block.block_number for block in block_table]\n\n    def get_num_free_gpu_blocks(self) -> int:\n        return self.gpu_allocator.get_num_free_blocks()\n\n    def get_num_free_cpu_blocks(self) -> int:\n        return self.cpu_allocator.get_num_free_blocks()\n\n    def access_all_blocks_in_seq(\n        self,\n        seq: Sequence,\n        access_time: float,\n    ) -> None:\n        if self.enable_caching:\n            # Update the last accessed time of all the blocks accessed\n            # in this step.\n            block_table = self.block_tables[seq.seq_id]\n            for block in block_table:\n                block.last_accessed = access_time\n\n    def compute_full_blocks_in_seq(self, seq: Sequence):\n        if seq.seq_id not in self.block_tables:\n            return\n        max_full_block = seq.get_len() // self.block_size - 1\n        block_table = self.block_tables[seq.seq_id]\n        if max_full_block == -1:\n            return\n        for i in reversed(range(max_full_block)):\n            if block_table[i].computed:\n                break\n            block_table[i].computed = True\n\n    def get_all_computed_blocks(self, seq: Sequence) -> List[int]:\n        if seq.seq_id not in self.block_tables:\n            return []\n        block_table = self.block_tables[seq.seq_id]\n        # NOTE We exclude the last block to avoid the case where the entire\n        # prompt is cached. This would cause erroneous behavior in model\n        # runner.\n        return [\n            b.block_number\n            for b in takewhile(lambda b: b.computed, block_table[:-1])\n        ]\n\n    def get_common_computed_block_ids(\n            self, seqs: List[Sequence]) -> GenericSequence[int]:\n        \"\"\"Return the block ids that are common for a given sequence group.\n\n        Used in prefill (can skip prefill of some blocks).\n        \"\"\"\n        # Can return non-empty result only with prefix caching enabled.\n        if not self.enable_caching:\n            return []\n\n        ids_list = [self.get_all_computed_blocks(seq) for seq in seqs]\n        return commonprefix([ids for ids in ids_list if ids != []])\n\n    def mark_blocks_as_computed(self, seq_group: SequenceGroup):\n        if self.enable_caching:\n            for seq in seq_group.seqs_dict.values():\n                self.compute_full_blocks_in_seq(seq)\n",
      "diff": "diff --git a/vllm/core/block_manager_v1.py b/vllm/core/block_manager_v1.py\nindex e29eba375..d81648caa 100644\n--- a/vllm/core/block_manager_v1.py\n+++ b/vllm/core/block_manager_v1.py\n@@ -700,5 +700,5 @@ class BlockSpaceManagerV1(BlockSpaceManager):\n \n     def mark_blocks_as_computed(self, seq_group: SequenceGroup):\n         if self.enable_caching:\n-            for seq in seq_group.seqs_dict.values():\n+            for seq in seq_group.get_seqs():\n                 self.compute_full_blocks_in_seq(seq)",
      "change_type": "modified",
      "lines_added": 2,
      "lines_removed": 2
    },
    {
      "file_path": "vllm/sequence.py",
      "old_content": "\"\"\"Sequence and its related classes.\"\"\"\nimport copy\nimport enum\nimport math\nfrom abc import ABC, abstractmethod\nfrom array import array\nfrom collections import defaultdict\nfrom dataclasses import dataclass, field\nfrom typing import (TYPE_CHECKING, Dict, List, Mapping, Optional, Set, Tuple,\n                    Union)\n\nimport torch\n\nfrom vllm.lora.request import LoRARequest\nfrom vllm.pooling_params import PoolingParams\nfrom vllm.prompt_adapter.request import PromptAdapterRequest\nfrom vllm.sampling_params import SamplingParams\n\nif TYPE_CHECKING:\n    from vllm.inputs import LLMInputs\n    from vllm.multimodal import MultiModalDataDict\n    from vllm.spec_decode.metrics import SpecDecodeWorkerMetrics\n\n\n@dataclass\nclass Logprob:\n    \"\"\"Infos for supporting OpenAI compatible logprobs and token ranks.\n\n    Attributes:\n        logprob: The logprob of chosen token\n        rank: The vocab rank of chosen token (>=1)\n        decoded_token: The decoded chosen token index\n    \"\"\"\n    logprob: float\n    rank: Optional[int] = None\n    decoded_token: Optional[str] = None\n\n\n# {token_id -> logprob} per each sequence group. None if the corresponding\n# sequence group doesn't require prompt logprob.\nPromptLogprobs = List[Optional[Dict[int, Logprob]]]\n# {token_id -> logprob} for each sequence group.\nSampleLogprobs = List[Dict[int, Logprob]]\n\n\nclass SequenceStatus(enum.IntEnum):\n    \"\"\"Status of a sequence.\"\"\"\n    WAITING = 0\n    RUNNING = 1\n    SWAPPED = 2\n    # Note: anything after SWAPPED (2) will be considered\n    # as a finished status.\n    FINISHED_STOPPED = 3\n    FINISHED_LENGTH_CAPPED = 4\n    FINISHED_ABORTED = 5\n    FINISHED_IGNORED = 6\n\n    @staticmethod\n    def is_finished(status: \"SequenceStatus\") -> bool:\n        return status > SequenceStatus.SWAPPED\n\n    @staticmethod\n    def get_finished_reason(status: \"SequenceStatus\") -> Union[str, None]:\n        if status == SequenceStatus.FINISHED_STOPPED:\n            finish_reason = \"stop\"\n        elif status == SequenceStatus.FINISHED_LENGTH_CAPPED:\n            finish_reason = \"length\"\n        elif status == SequenceStatus.FINISHED_ABORTED:\n            finish_reason = \"abort\"\n        elif status == SequenceStatus.FINISHED_IGNORED:\n            # The ignored sequences are the sequences whose prompt lengths\n            # are longer than the model's length cap. Therefore, the stop\n            # reason should also be \"length\" as in OpenAI API.\n            finish_reason = \"length\"\n        else:\n            finish_reason = None\n        return finish_reason\n\n\nclass SequenceStage(enum.Enum):\n    PREFILL = enum.auto()\n    DECODE = enum.auto()\n\n\n@dataclass\nclass RequestMetrics:\n    \"\"\"Metrics associated with a request.\n\n    Attributes:\n        arrival_time: The time when the request arrived.\n        first_scheduled_time: The time when the request was first scheduled.\n        first_token_time: The time when the first token was generated.\n        time_in_queue: The time the request spent in the queue.\n        finished_time: The time when the request was finished.\n    \"\"\"\n    arrival_time: float\n    last_token_time: float\n    first_scheduled_time: Optional[float]\n    first_token_time: Optional[float]\n    time_in_queue: Optional[float]\n    finished_time: Optional[float] = None\n\n\nclass SequenceData:\n    \"\"\"Data associated with a sequence.\n\n    Args:\n        prompt_token_ids: The token IDs of the prompt.\n        output_token_ids: The token IDs of the output. Set to an empty list if\n            None.\n\n    Attributes:\n        prompt_token_ids: The token IDs of the prompt.\n        output_token_ids: The token IDs of the output.\n        cumulative_logprob: The cumulative log probability of the output.\n    \"\"\"\n\n    def __init__(\n        self,\n        prompt_token_ids: List[int],\n        output_token_ids: Optional[List[int]] = None,\n    ) -> None:\n        self._prompt_token_ids = array('l', prompt_token_ids)\n        self._prompt_token_ids_tuple: Tuple[int, ...] = tuple(prompt_token_ids)\n        self._output_token_ids = array(\n            'l', output_token_ids if output_token_ids is not None else [])\n\n        self.cumulative_logprob = 0.0\n        # The number of tokens that are computed (that run against the model).\n        self._num_computed_tokens = 0\n        self._stage: SequenceStage = SequenceStage.PREFILL\n\n        self._update_cached_all_tokens()\n\n    def _update_cached_all_tokens(self):\n        self._cached_all_token_ids: List[int] = list(self._prompt_token_ids +\n                                                     self._output_token_ids)\n\n    @property\n    def prompt_token_ids(self) -> Tuple[int, ...]:\n        return self._prompt_token_ids_tuple\n\n    @prompt_token_ids.setter\n    def prompt_token_ids(self, new_prompt_token_ids) -> None:\n        self._prompt_token_ids = array('l', new_prompt_token_ids)\n        self._prompt_token_ids_tuple = tuple(new_prompt_token_ids)\n        self._update_cached_all_tokens()\n\n    @property\n    def prompt_token_ids_array(self) -> array:\n        return self._prompt_token_ids\n\n    @property\n    def output_token_ids(self) -> Tuple[int, ...]:\n        return tuple(self._output_token_ids)\n\n    @output_token_ids.setter\n    def output_token_ids(self, new_output_token_ids) -> None:\n        self._output_token_ids = array('l', new_output_token_ids)\n        self._update_cached_all_tokens()\n\n    @property\n    def output_token_ids_array(self) -> array:\n        return self._output_token_ids\n\n    def append_token_id(self, token_id: int, logprob: float) -> None:\n        self._output_token_ids.append(token_id)\n        self._cached_all_token_ids.append(token_id)\n        self.cumulative_logprob += logprob\n\n    def get_len(self) -> int:\n        return len(self._output_token_ids) + len(self._prompt_token_ids)\n\n    def get_prompt_len(self) -> int:\n        return len(self._prompt_token_ids)\n\n    def get_output_len(self) -> int:\n        return len(self._output_token_ids)\n\n    def get_token_ids(self) -> List[int]:\n        return self._cached_all_token_ids\n\n    def get_prefix_token_ids(\n            self, num_tokens: int\n    ) -> Tuple[Tuple[int, ...], Optional[Tuple[int, ...]]]:\n        \"\"\"Get prefix tokens, and make the return value hashable\"\"\"\n        prompt_length = self.get_prompt_len()\n        if num_tokens > prompt_length:\n            return (self._prompt_token_ids_tuple,\n                    tuple(self._output_token_ids[:num_tokens - prompt_length]))\n        else:\n            return (self._prompt_token_ids_tuple[:num_tokens], None)\n\n    def get_num_computed_tokens(self) -> int:\n        \"\"\"Return the number of prefill tokens that are already computed.\"\"\"\n        return self._num_computed_tokens\n\n    def update_num_computed_tokens(self, num_new_computed_tokens: int):\n        \"\"\"Update number of tokens computed so far.\"\"\"\n        self._num_computed_tokens += num_new_computed_tokens\n        assert self._num_computed_tokens <= self.get_len(), (\n            self._num_computed_tokens, self.get_len())\n        # If all tokens are computed, it means it is in decoding phase.\n        if self.get_num_uncomputed_tokens() == 0:\n            self._stage = SequenceStage.DECODE\n\n    def reset_state_for_recompute(self) -> None:\n        \"\"\"Reset the number of computed tokens from this sequence. It is\n        supposed to be called when a sequence needs to be started from\n        the beginning again (e.g., sequence is preempted).\n        \"\"\"\n        self._num_computed_tokens = 0\n        self._stage = SequenceStage.PREFILL\n\n    def get_num_uncomputed_tokens(self) -> int:\n        \"\"\"Return the number of prefill tokens that are not computed.\"\"\"\n        # we use `get_len()` which includes prompt_len + output_len instead\n        # of prompt_len here. This is because during recompute we need to\n        # prefill for both prompt and output.\n        return self.get_len() - self.get_num_computed_tokens()\n\n    def get_last_token_id(self) -> int:\n        if not self._output_token_ids:\n            return self._prompt_token_ids[-1]\n        return self._output_token_ids[-1]\n\n    def get_prompt_token_ids(self) -> Tuple[int, ...]:\n        return self.prompt_token_ids\n\n    def get_output_token_ids(self) -> Tuple[int, ...]:\n        return self.output_token_ids\n\n    @property\n    def stage(self) -> SequenceStage:\n        return self._stage\n\n    def __repr__(self) -> str:\n        return (f\"SequenceData(\"\n                f\"prompt_token_ids={self._prompt_token_ids}, \"\n                f\"output_token_ids={self._output_token_ids}, \"\n                f\"cumulative_logprob={self.cumulative_logprob})\")\n\n\nclass Sequence:\n    \"\"\"Stores the data, status, and block information of a sequence.\n\n    Args:\n        seq_id: The ID of the sequence.\n        inputs: The inputs of the sequence.\n        block_size: The block size of the sequence. Should be the same as the\n            block size used by the block manager and cache engine.\n        lora_request: LoRA request.\n        prompt_adapter_request: Prompt Adapter request.\n\n    \"\"\"\n\n    def __init__(\n            self,\n            seq_id: int,\n            inputs: \"LLMInputs\",\n            block_size: int,\n            eos_token_id: Optional[int] = None,\n            lora_request: Optional[LoRARequest] = None,\n            prompt_adapter_request: Optional[PromptAdapterRequest] = None\n    ) -> None:\n        self.seq_id = seq_id\n        self.inputs = inputs\n        self.block_size = block_size\n        self.eos_token_id = eos_token_id\n        self.lora_request = lora_request\n        self.prompt_adapter_request = prompt_adapter_request\n\n        self.data = SequenceData(self.prompt_token_ids)\n        self.output_logprobs: SampleLogprobs = []\n        self.output_text = \"\"\n\n        self.status = SequenceStatus.WAITING\n        self.stop_reason: Union[int, str, None] = None\n\n        # Used for incremental detokenization\n        self.prefix_offset = 0\n        self.read_offset = 0\n        # Input + output tokens\n        self.tokens: Optional[List[str]] = None\n\n    @property\n    def n_blocks(self) -> int:\n        return math.ceil(self.get_len() / self.block_size)\n\n    @property\n    def prompt(self) -> Optional[str]:\n        return self.inputs.get(\"prompt\")\n\n    @property\n    def prompt_token_ids(self) -> List[int]:\n        return self.inputs[\"prompt_token_ids\"]\n\n    @property\n    def multi_modal_data(self) -> \"MultiModalDataDict\":\n        return self.inputs.get(\"multi_modal_data\") or {}\n\n    @property\n    def lora_int_id(self) -> int:\n        return self.lora_request.lora_int_id if self.lora_request else 0\n\n    @property\n    def prompt_adapter_id(self) -> int:\n        return self.prompt_adapter_request.prompt_adapter_id \\\n                        if self.prompt_adapter_request else 0\n\n    def get_output_text_to_return(self, buffer_length: int):\n        # We return the full output text if the sequence is finished.\n        truncate = buffer_length and not self.is_finished()\n        return self.output_text[:-buffer_length] if truncate else (\n            self.output_text)\n\n    def hash_of_block(self, logical_idx: int) -> int:\n        # TODO This can produce incorrect hash when block size > prompt size\n\n        # Compute the number of tokens in the sequence\n        # TODO: The current hashing function is O(L^2). We should optimize\n        # this in the future.\n        num_tokens = self.num_hashed_tokens_of_block(logical_idx)\n        hashed_tokens = self.data.get_prefix_token_ids(num_tokens)\n        return hash((hashed_tokens, self.lora_int_id))\n\n    def num_hashed_tokens_of_block(self, logical_idx: int):\n        return logical_idx * self.block_size + self.block_size\n\n    def reset_state_for_recompute(self):\n        \"\"\"Reset the sequence states for recomputation.\"\"\"\n        self.data.reset_state_for_recompute()\n\n    def append_token_id(\n        self,\n        token_id: int,\n        logprobs: Dict[int, Logprob],\n    ) -> None:\n        assert token_id in logprobs\n        self.output_logprobs.append(logprobs)\n        self.data.append_token_id(token_id, logprobs[token_id].logprob)\n\n    def get_len(self) -> int:\n        return self.data.get_len()\n\n    def get_prompt_len(self) -> int:\n        return self.data.get_prompt_len()\n\n    def get_output_len(self) -> int:\n        return self.data.get_output_len()\n\n    def get_token_ids(self) -> List[int]:\n        return self.data.get_token_ids()\n\n    def get_prompt_token_ids(self) -> Tuple[int, ...]:\n        return self.data.get_prompt_token_ids()\n\n    def get_last_token_id(self) -> int:\n        return self.data.get_last_token_id()\n\n    def get_output_token_ids(self) -> Tuple[int, ...]:\n        return self.data.get_output_token_ids()\n\n    def get_cumulative_logprob(self) -> float:\n        return self.data.cumulative_logprob\n\n    def get_beam_search_score(self,\n                              length_penalty: float = 1.0,\n                              seq_len: Optional[int] = None,\n                              eos_token_id: Optional[int] = None) -> float:\n        \"\"\"Calculate the beam search score with length penalty.\n\n        Adapted from\n\n        https://github.com/huggingface/transformers/blob/ccb92be23def445f2afdea94c31286f84b89eb5b/src/transformers/generation/beam_search.py#L938\n        \"\"\"\n        if seq_len is None:\n            seq_len = self.get_len()\n            # NOTE: HF implementation does not count the EOS token\n            # towards the length, we align with that here for testing.\n            if (eos_token_id is not None\n                    and self.get_last_token_id() == eos_token_id):\n                seq_len -= 1\n        return self.get_cumulative_logprob() / (seq_len**length_penalty)\n\n    def is_finished(self) -> bool:\n        return SequenceStatus.is_finished(self.status)\n\n    def fork(self, new_seq_id: int) -> \"Sequence\":\n        new_seq = copy.deepcopy(self)\n        new_seq.seq_id = new_seq_id\n        return new_seq\n\n    def get_num_new_tokens(self) -> int:\n        \"\"\"Get the number of new tokens to be computed.\n\n        Returns:\n            The new number of tokens to be computed. I.e., 1 for decode, or\n            the remaining prompt size for prefill.\n        \"\"\"\n        if self.data.stage == SequenceStage.DECODE:\n            return 1\n        return self.data.get_num_uncomputed_tokens()\n\n    def is_prefill(self) -> bool:\n        return self.data.stage == SequenceStage.PREFILL\n\n    def __repr__(self) -> str:\n        return (f\"Sequence(seq_id={self.seq_id}, \"\n                f\"status={self.status.name}, \"\n                f\"num_blocks={self.n_blocks}, \")\n\n\nclass SequenceGroup:\n    \"\"\"A group of sequences that are generated from the same prompt.\n\n    Args:\n        request_id: The ID of the request.\n        seqs: The list of sequences.\n        sampling_params: The sampling parameters used to generate the outputs.\n        arrival_time: The arrival time of the request.\n        lora_request: LoRA request.\n        embeddings: The embeddings vectors of the prompt of the sequence group\n            for an embedding model.\n        pooling_params: The pooling parameters used to generate the pooling\n            for an embedding model.\n        encoder_seq: Optional, the single encoder sequence. Should be None\n                     unless you are working with an encoder/decoder model.\n        trace_headers: OpenTelemetry trace headers.\n        prompt_adapter_request: Prompt Adapter request.\n    \"\"\"\n\n    def __init__(\n        self,\n        request_id: str,\n        seqs: List[Sequence],\n        arrival_time: float,\n        sampling_params: Optional[SamplingParams] = None,\n        lora_request: Optional[LoRARequest] = None,\n        embeddings: Optional[List[float]] = None,\n        pooling_params: Optional[PoolingParams] = None,\n        encoder_seq: Optional[Sequence] = None,\n        trace_headers: Optional[Mapping[str, str]] = None,\n        prompt_adapter_request: Optional[PromptAdapterRequest] = None,\n    ) -> None:\n        self.request_id = request_id\n        self.seqs_dict = {seq.seq_id: seq for seq in seqs}\n        self.sampling_params = sampling_params\n        self.metrics = RequestMetrics(arrival_time=arrival_time,\n                                      last_token_time=arrival_time,\n                                      first_scheduled_time=None,\n                                      first_token_time=None,\n                                      time_in_queue=None)\n        self.lora_request = lora_request\n        self.prompt_logprobs: Optional[PromptLogprobs] = None\n        self.embeddings = embeddings\n        self.pooling_params = pooling_params\n        self.prompt_adapter_request = prompt_adapter_request\n        self.encoder_seq = encoder_seq\n        self.trace_headers = trace_headers\n        self._first_seq = next(iter(self.seqs_dict.values()))\n\n    @property\n    def prompt(self) -> Optional[str]:\n        # All sequences in the group should have the same prompt.\n        # We use the prompt of an arbitrary sequence.\n        return self._first_seq.prompt\n\n    @property\n    def prompt_token_ids(self) -> List[int]:\n        # All sequences in the group should have the same prompt.\n        # We use the prompt of an arbitrary sequence.\n        return self._first_seq.prompt_token_ids\n\n    @property\n    def multi_modal_data(self) -> \"MultiModalDataDict\":\n        # All sequences in the group should have the same multi-modal data.\n        # We use the multi-modal data of an arbitrary sequence.\n        return self._first_seq.multi_modal_data\n\n    @property\n    def lora_int_id(self) -> int:\n        return self.lora_request.lora_int_id if self.lora_request else 0\n\n    @property\n    def prompt_adapter_id(self) -> int:\n        return self.prompt_adapter_request.prompt_adapter_id \\\n                        if self.prompt_adapter_request else 0\n\n    @property\n    def prompt_adapter_num_virtual_tokens(self) -> int:\n        return self.prompt_adapter_request.prompt_adapter_num_virtual_tokens\\\n                         if self.prompt_adapter_request else 0\n\n    def get_last_latency(self, now: float) -> Optional[float]:\n        \"\"\"Sets the last token time for Request level timings.\"\"\"\n        # If still in prefill phase, raise Error.\n        if self.is_prefill():\n            raise ValueError(\n                \"seq_group.get_last_latency() should not be called \"\n                \"if the seq_group is in prefill phase.\")\n\n        # Otherwise return token latency.\n        latency = now - self.metrics.last_token_time\n        self.metrics.last_token_time = now\n        return latency\n\n    def maybe_set_first_token_time(self, time: float) -> None:\n        \"\"\"Sets the first token time for Request level timings.\"\"\"\n        # Note: in a case where a sequence_group is swapped and\n        #   recomputed, the time between iterations is counted\n        #   in TPOT, rather than recalculating TTFT (since from the )\n        #   POV of the user, there is simply a long generation delay.\n        if (self.metrics.first_token_time is None\n                and self.get_seqs()[0].get_output_len() == 1):\n            self.metrics.first_token_time = time\n\n    def maybe_set_first_scheduled_time(self, time: float) -> None:\n        \"\"\"Sets the first scheduled time and time in queue for Request\n        level timings.\"\"\"\n        if self.metrics.first_scheduled_time is None:\n            self.metrics.first_scheduled_time = time\n            self.metrics.time_in_queue = time - self.metrics.arrival_time\n\n    def set_finished_time(self, time: Optional[float]) -> None:\n        \"\"\"Sets the finished time for Request level timings.\"\"\"\n        self.metrics.finished_time = time\n\n    def get_max_num_running_seqs(self) -> int:\n        \"\"\"The maximum number of sequences running in parallel in the remaining\n        lifetime of the request.\"\"\"\n        if self.sampling_params and self.sampling_params.use_beam_search:\n            # For beam search, maximally there will always be `best_of` beam\n            # candidates running in the future.\n            return self.sampling_params.best_of\n        else:\n            if (self.sampling_params\n                    and self.sampling_params.best_of > self.num_seqs()):\n                # At prompt stage, the sequence group is not yet filled up\n                # and only have one sequence running. However, in the\n                # generation stage, we will have `best_of` sequences running.\n                return self.sampling_params.best_of\n            # At sampling stages, return the number of actual sequences\n            # that are not finished yet.\n            return self.num_unfinished_seqs()\n\n    def get_seqs(\n        self,\n        status: Optional[SequenceStatus] = None,\n    ) -> List[Sequence]:\n        return list(self.seqs_dict.values()) if status is None else [\n            seq for seq in self.seqs_dict.values() if seq.status == status\n        ]\n\n    def is_encoder_decoder(self) -> bool:\n        return self.encoder_seq is not None\n\n    def get_encoder_seq(self) -> Optional[Sequence]:\n        return self.encoder_seq\n\n    def get_unfinished_seqs(self) -> List[Sequence]:\n        return [\n            seq for seq in self.seqs_dict.values() if not seq.is_finished()\n        ]\n\n    def get_finished_seqs(self) -> List[Sequence]:\n        return [seq for seq in self.seqs_dict.values() if seq.is_finished()]\n\n    def update_num_computed_tokens(self, num_new_computed_tokens: int):\n        \"\"\"Update number of tokens computed so far.\"\"\"\n        for seq in self.seqs_dict.values():\n            if not seq.is_finished():\n                seq.data.update_num_computed_tokens(num_new_computed_tokens)\n\n    def get_num_uncomputed_tokens(self) -> int:\n        num_uncomputed_tokens = 0\n        for seq in self.get_seqs():\n            if not seq.is_finished():\n                num_uncomputed_tokens += seq.data.get_num_uncomputed_tokens()\n        return num_uncomputed_tokens\n\n    def num_seqs(self, status: Optional[SequenceStatus] = None) -> int:\n        # Optimization. We don't need to call get_seqs if we don't need to\n        # filter by states.\n        if status is None:\n            return len(self.seqs_dict)\n\n        return len(self.get_seqs(status))\n\n    def num_unfinished_seqs(self) -> int:\n        return len(self.get_unfinished_seqs())\n\n    def num_finished_seqs(self) -> int:\n        return len(self.get_finished_seqs())\n\n    def find(self, seq_id: int) -> Sequence:\n        if seq_id not in self.seqs_dict:\n            raise ValueError(f\"Sequence {seq_id} not found.\")\n        return self.seqs_dict[seq_id]\n\n    def add(self, seq: Sequence) -> None:\n        if seq.seq_id in self.seqs_dict:\n            raise ValueError(f\"Sequence {seq.seq_id} already exists.\")\n        self.seqs_dict[seq.seq_id] = seq\n\n    def remove(self, seq_id: int) -> None:\n        if seq_id not in self.seqs_dict:\n            raise ValueError(f\"Sequence {seq_id} not found.\")\n        del self.seqs_dict[seq_id]\n\n    def is_finished(self) -> bool:\n        return all(seq.is_finished() for seq in self.get_seqs())\n\n    def is_prefill(self) -> bool:\n        # Every sequence should be in the same stage.\n        return self.get_seqs()[0].is_prefill()\n\n    def __repr__(self) -> str:\n        return (f\"SequenceGroup(request_id={self.request_id}, \"\n                f\"sampling_params={self.sampling_params}, \"\n                f\"num_seqs={len(self.seqs_dict)})\")\n\n\nclass SequenceGroupMetadata:\n    \"\"\"Metadata for a sequence group. Used to create `AttentionMetadata`.\n\n    Args:\n        request_id: The ID of the request.\n        is_prompt: Whether the request is at prompt stage.\n        seq_data: The sequence data. (Seq id -> sequence data)\n        sampling_params: The sampling parameters used to generate the outputs.\n        block_tables: The block tables. (Seq id -> list of physical block\n            numbers)\n        do_sample: True if sampling is required. Sampling is not required when\n            e.g., prefill is chunked, and the current iteration only computes\n            query tokens for prefill, we don't need sampling.\n        token_chunk_size: The number of tokens to be processed (per sequence).\n            None if chunking is not required.\n        lora_request: LoRA request.\n        computed_block_nums: The block numbers that are already computed,\n            used in prefix caching.\n        multi_modal_data: Multi modal data.\n        encoder_seq_data: Optional sequence data for encoder prompt\n                          (SequenceGroup.encoder_seq). Should be None \n                          unless you are working with an encoder/decoder\n                          model.\n        cross_block_table: Optional cross-attention block table associated\n                           with the encoder prompt\n                           (SequenceGroup.encoder_seq). Should be None\n                           unless you are working with an encoder/decoder\n                           model.\n        prompt_adapter_request: Prompt Adapter request.\n    \"\"\"\n\n    def __init__(\n        self,\n        request_id: str,\n        is_prompt: bool,\n        seq_data: Dict[int, SequenceData],\n        sampling_params: SamplingParams,\n        block_tables: Dict[int, List[int]],\n        do_sample: bool = True,\n        pooling_params: Optional[PoolingParams] = None,\n        token_chunk_size: Optional[int] = None,\n        lora_request: Optional[LoRARequest] = None,\n        computed_block_nums: Optional[List[int]] = None,\n        multi_modal_data: Optional[\"MultiModalDataDict\"] = None,\n        encoder_seq_data: Optional[SequenceData] = None,\n        cross_block_table: Optional[List[int]] = None,\n        prompt_adapter_request: Optional[PromptAdapterRequest] = None,\n    ) -> None:\n        self.request_id = request_id\n        self.is_prompt = is_prompt\n        self.seq_data = seq_data\n        self.sampling_params = sampling_params\n        self.block_tables = block_tables\n        self.pooling_params = pooling_params\n        self.lora_request = lora_request\n        self.prompt_adapter_request = prompt_adapter_request\n        self.computed_block_nums = computed_block_nums\n        self.multi_modal_data = multi_modal_data\n        self.encoder_seq_data = encoder_seq_data\n        self.cross_block_table = cross_block_table\n        self._token_chunk_size = token_chunk_size\n        self.do_sample = do_sample\n\n        # The number of speculative tokens adopted in this request.\n        # None means specuative decoding is not used.\n        # Zero means speculative decoding is disabled for some reasons.\n        # TODO: We should maintain this states out of the sequence group.\n        self.num_speculative_tokens = None\n\n        if self._token_chunk_size is None:\n            if is_prompt:\n                self._token_chunk_size = list(seq_data.values())[0].get_len()\n            else:\n                self._token_chunk_size = 1\n\n    @property\n    def lora_int_id(self) -> int:\n        return self.lora_request.lora_int_id if self.lora_request else 0\n\n    @property\n    def prompt_adapter_id(self) -> int:\n        return self.prompt_adapter_request.prompt_adapter_id \\\n                        if self.prompt_adapter_request else 0\n\n    @property\n    def prompt_adapter_num_virtual_tokens(self) -> int:\n        return self.prompt_adapter_request.prompt_adapter_num_virtual_tokens \\\n                        if self.prompt_adapter_request else 0\n\n    @property\n    def token_chunk_size(self) -> int:\n        \"\"\"Return the number of tokens to be processed (chunk size).\"\"\"\n        assert self._token_chunk_size is not None\n        return self._token_chunk_size\n\n\nclass SequenceOutput:\n    \"\"\"The model output associated with a sequence.\n\n    Args:\n        parent_seq_id: The ID of the parent sequence (for forking in beam\n            search).\n        output_token: The output token ID.\n        logprobs: The logprobs of the output token.\n            (Token id -> logP(x_i+1 | x_0, ..., x_i))\n    \"\"\"\n\n    def __init__(\n        self,\n        parent_seq_id: int,\n        output_token: int,\n        logprobs: Dict[int, Logprob],\n    ) -> None:\n        self.parent_seq_id = parent_seq_id\n        self.output_token = output_token\n        self.logprobs = logprobs\n\n    def __repr__(self) -> str:\n        return (f\"SequenceOutput(parent_seq_id={self.parent_seq_id}, \"\n                f\"output_token={self.output_token}, \"\n                f\"logprobs={self.logprobs})\")\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SequenceOutput):\n            raise NotImplementedError()\n        equal = (self.parent_seq_id == other.parent_seq_id\n                 and self.output_token == other.output_token)\n        log_probs_equal = other.logprobs == self.logprobs\n        return equal and log_probs_equal\n\n\nclass SequenceGroupOutput(ABC):\n    \"\"\"The base class for model outputs associated with a sequence group.\"\"\"\n\n    @abstractmethod\n    def __repr__(self) -> str:\n        pass\n\n    @abstractmethod\n    def __eq__(self, other: object) -> bool:\n        pass\n\n\nclass CompletionSequenceGroupOutput(SequenceGroupOutput):\n    \"\"\"The model output associated with a completion sequence group.\"\"\"\n\n    def __init__(\n        self,\n        samples: List[SequenceOutput],\n        prompt_logprobs: Optional[PromptLogprobs],\n    ) -> None:\n        self.samples = samples\n        # Prompt logprob for each prompt query token.\n        self.prompt_logprobs = prompt_logprobs\n\n    def __repr__(self) -> str:\n        return (f\"CompletionSequenceGroupOutput(samples={self.samples}, \"\n                f\"prompt_logprobs={self.prompt_logprobs})\")\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CompletionSequenceGroupOutput):\n            raise NotImplementedError()\n        return (self.samples == other.samples\n                and self.prompt_logprobs == other.prompt_logprobs)\n\n\nclass EmbeddingSequenceGroupOutput(SequenceGroupOutput):\n    \"\"\"The model output associated with an embedding sequence group.\"\"\"\n\n    def __init__(\n        self,\n        embeddings: List[float],\n    ) -> None:\n        self.embeddings = embeddings\n\n    def __repr__(self) -> str:\n        return (f\"EmbeddingSequenceGroupOutput(\"\n                f\"embeddings_shape={len(self.embeddings)})\")\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, EmbeddingSequenceGroupOutput):\n            raise NotImplementedError()\n        return self.embeddings == other.embeddings\n\n\n@dataclass\nclass IntermediateTensors:\n    \"\"\"For all pipeline stages except the last, we need to return the hidden\n    states and residuals to be sent to the next stage. This data structure\n    contains the hidden states and residuals for a request.\n    \"\"\"\n\n    tensors: Dict[str, torch.Tensor]\n\n    def __getitem__(self, key: Union[str, slice]):\n        if isinstance(key, str):\n            return self.tensors[key]\n        elif isinstance(key, slice):\n            return self.__class__({k: v[key] for k, v in self.tensors.items()})\n\n    def __setitem__(self, key: str, value):\n        self.tensors[key] = value\n\n    def __len__(self):\n        return len(self.tensors)\n\n    def __eq__(self, other: object):\n        return isinstance(other, self.__class__) and self\n\n    def __repr__(self) -> str:\n        return f\"IntermediateTensors(tensors={self.tensors})\"\n\n\n@dataclass\nclass SamplerOutput:\n    \"\"\"For each sequence group, we generate a list of SequenceOutput object,\n    each of which contains one possible candidate for the next token.\n\n    This data structure implements methods, so it can be used like a list, but\n    also has optional fields for device tensors.\n    \"\"\"\n\n    outputs: List[CompletionSequenceGroupOutput]\n\n    # On-device tensor containing probabilities of each token.\n    sampled_token_probs: Optional[torch.Tensor] = None\n\n    # On-device tensor containing the logprobs of each token.\n    logprobs: Optional[\"torch.Tensor\"] = None\n\n    # On-device tensor containing the sampled token ids.\n    sampled_token_ids: Optional[torch.Tensor] = None\n\n    # Spec decode metrics populated by workers.\n    spec_decode_worker_metrics: Optional[\"SpecDecodeWorkerMetrics\"] = None\n\n    # Optional last hidden states from the model.\n    hidden_states: Optional[torch.Tensor] = None\n\n    def __getitem__(self, idx: int):\n        return self.outputs[idx]\n\n    def __setitem__(self, idx: int, value):\n        self.outputs[idx] = value\n\n    def __len__(self):\n        return len(self.outputs)\n\n    def __eq__(self, other: object):\n        return isinstance(other,\n                          self.__class__) and self.outputs == other.outputs\n\n    def __repr__(self) -> str:\n        \"\"\"Show the shape of a tensor instead of its values to reduce noise.\n        \"\"\"\n        sampled_token_probs_repr = (\"None\" if self.sampled_token_probs is None\n                                    else self.sampled_token_probs.shape)\n        sampled_token_ids_repr = (\"None\" if self.sampled_token_ids is None else\n                                  self.sampled_token_ids.shape)\n        return (\n            f\"SamplerOutput(outputs={self.outputs}, \"\n            f\"sampled_token_probs={sampled_token_probs_repr}, \"\n            f\"sampled_token_ids={sampled_token_ids_repr}, \"\n            f\"spec_decode_worker_metrics={self.spec_decode_worker_metrics})\")\n\n\n@dataclass\nclass PoolerOutput:\n    \"\"\"The output from a pooling operation in the embedding model.\"\"\"\n    outputs: List[EmbeddingSequenceGroupOutput]\n\n    spec_decode_worker_metrics: Optional[\"SpecDecodeWorkerMetrics\"] = None\n\n    def __getitem__(self, idx: int):\n        return self.outputs[idx]\n\n    def __setitem__(self, idx: int, value):\n        self.outputs[idx] = value\n\n    def __len__(self):\n        return len(self.outputs)\n\n    def __eq__(self, other: object):\n        return isinstance(other,\n                          self.__class__) and self.outputs == other.outputs\n\n\ndef get_all_seq_ids(\n        seq_group_metadata_list: List[SequenceGroupMetadata]) -> List[int]:\n    \"\"\"Given a list of SequenceGroupMetadata, create a list of all\n    sequence ids.\n    \"\"\"\n    return [seq_id for sg in seq_group_metadata_list for seq_id in sg.seq_data]\n\n\ndef get_all_seq_ids_and_request_ids(\n    seq_group_metadata_list: List[SequenceGroupMetadata]\n) -> Tuple[List[int], Dict[str, Set[int]]]:\n    \"\"\"Given a list of SequenceGroupMetadata, create a list of all\n    sequence ids.\n    \"\"\"\n    seq_ids: List[int] = []\n    request_id_seq_ids_mapping: Dict[str, Set[int]] = defaultdict(set)\n    for sg in seq_group_metadata_list:\n        for seq_id in sg.seq_data:\n            seq_ids.append(seq_id)\n            request_id_seq_ids_mapping[sg.request_id].add(seq_id)\n    return seq_ids, request_id_seq_ids_mapping\n\n\nclass HiddenStates:\n    \"\"\"Hidden states corresponding to in-progress sequences.\n    Used in speculative decoding to pass hidden states from\n    the target model to the proposer model in the subsequent step.\n\n    seq_ids are the sequence ids of each entry of the batch\n    dimension of the hidden_states tensor\"\"\"\n\n    def __init__(self, seq_group_metadata_list: List[SequenceGroupMetadata],\n                 hidden_states: torch.Tensor):\n        assert len(seq_group_metadata_list) == len(hidden_states)\n        self.seq_ids: List[int] = get_all_seq_ids(seq_group_metadata_list)\n        self.hidden_states: torch.Tensor = hidden_states\n\n    def update(self, seq_group_metadata_list: List[SequenceGroupMetadata],\n               hidden_states: torch.Tensor) -> None:\n        \"\"\"Update hidden states from target model invocation.\"\"\"\n        assert len(seq_group_metadata_list) == len(hidden_states)\n        self.seq_ids.extend(get_all_seq_ids(seq_group_metadata_list))\n        self.hidden_states = torch.cat([self.hidden_states, hidden_states])\n\n    def prune(self,\n              seq_group_metadata_list: List[SequenceGroupMetadata]) -> None:\n        \"\"\"Prune to provided list of sequence ids.\"\"\"\n        seq_ids = get_all_seq_ids(seq_group_metadata_list)\n        if seq_ids != self.seq_ids:\n            # Batch contents changed - prune removed sequences.\n            index = [self.seq_ids.index(seq_id) for seq_id in seq_ids]\n            self.hidden_states = self.hidden_states[index]\n            self.seq_ids = seq_ids\n\n\n@dataclass\nclass ExecuteModelRequest:\n    \"\"\"The model execution request, containing CPU metadata only. The LLM\n    engine should create an instance of this class for each request batch.\"\"\"\n    # The sequence group metadata list.\n    seq_group_metadata_list: List[SequenceGroupMetadata]\n    # Blocks to swap in. List of CPU -> GPU block number.\n    blocks_to_swap_in: List[Tuple[int, int]] = field(default_factory=list)\n    # Blocks to swap out. List of GPU -> CPU block number.\n    blocks_to_swap_out: List[Tuple[int, int]] = field(default_factory=list)\n    # Blocks to copy. Source to dest block.\n    blocks_to_copy: List[Tuple[int, int]] = field(default_factory=list)\n    # Virtual engine ID for pipeline parallel.\n    virtual_engine: int = 0\n    # The number of slots for lookahead decoding.\n    num_lookahead_slots: int = 0\n    # The number of requests in the running queue.\n    running_queue_size: int = 0\n    # Optional hidden states from prior step.\n    previous_hidden_states: Optional[HiddenStates] = None\n    # The number of forward steps to run.\n    num_steps: int = 1\n    # Finished request ids since last step.\n    finished_requests_ids: List[str] = field(default_factory=list)\n\n    def clone(\n        self, seq_group_metadata_list: List[SequenceGroupMetadata]\n    ) -> \"ExecuteModelRequest\":\n        \"\"\"Clone the request with a new sequence group metadata list.\"\"\"\n        return ExecuteModelRequest(\n            seq_group_metadata_list=seq_group_metadata_list,\n            blocks_to_swap_in=self.blocks_to_swap_in.copy(),\n            blocks_to_swap_out=self.blocks_to_swap_out.copy(),\n            blocks_to_copy=self.blocks_to_copy.copy(),\n            virtual_engine=self.virtual_engine,\n            num_lookahead_slots=self.num_lookahead_slots,\n            running_queue_size=self.running_queue_size,\n            previous_hidden_states=self.previous_hidden_states,\n            num_steps=self.num_steps,\n            finished_requests_ids=self.finished_requests_ids)\n",
      "diff": "diff --git a/vllm/sequence.py b/vllm/sequence.py\nindex ab50cfdfd..7ef9387c6 100644\n--- a/vllm/sequence.py\n+++ b/vllm/sequence.py\n@@ -444,6 +444,7 @@ class SequenceGroup:\n         prompt_adapter_request: Optional[PromptAdapterRequest] = None,\n     ) -> None:\n         self.request_id = request_id\n+        self.seqs = seqs\n         self.seqs_dict = {seq.seq_id: seq for seq in seqs}\n         self.sampling_params = sampling_params\n         self.metrics = RequestMetrics(arrival_time=arrival_time,\n@@ -458,25 +459,24 @@ class SequenceGroup:\n         self.prompt_adapter_request = prompt_adapter_request\n         self.encoder_seq = encoder_seq\n         self.trace_headers = trace_headers\n-        self._first_seq = next(iter(self.seqs_dict.values()))\n \n     @property\n     def prompt(self) -> Optional[str]:\n         # All sequences in the group should have the same prompt.\n         # We use the prompt of an arbitrary sequence.\n-        return self._first_seq.prompt\n+        return self.seqs[0].prompt\n \n     @property\n     def prompt_token_ids(self) -> List[int]:\n         # All sequences in the group should have the same prompt.\n         # We use the prompt of an arbitrary sequence.\n-        return self._first_seq.prompt_token_ids\n+        return self.seqs[0].prompt_token_ids\n \n     @property\n     def multi_modal_data(self) -> \"MultiModalDataDict\":\n         # All sequences in the group should have the same multi-modal data.\n         # We use the multi-modal data of an arbitrary sequence.\n-        return self._first_seq.multi_modal_data\n+        return self.seqs[0].multi_modal_data\n \n     @property\n     def lora_int_id(self) -> int:\n@@ -512,7 +512,7 @@ class SequenceGroup:\n         #   in TPOT, rather than recalculating TTFT (since from the )\n         #   POV of the user, there is simply a long generation delay.\n         if (self.metrics.first_token_time is None\n-                and self.get_seqs()[0].get_output_len() == 1):\n+                and self.seqs[0].get_output_len() == 1):\n             self.metrics.first_token_time = time\n \n     def maybe_set_first_scheduled_time(self, time: float) -> None:\n@@ -548,9 +548,9 @@ class SequenceGroup:\n         self,\n         status: Optional[SequenceStatus] = None,\n     ) -> List[Sequence]:\n-        return list(self.seqs_dict.values()) if status is None else [\n-            seq for seq in self.seqs_dict.values() if seq.status == status\n-        ]\n+        if status is None:\n+            return self.seqs\n+        return [seq for seq in self.seqs if seq.status == status]\n \n     def is_encoder_decoder(self) -> bool:\n         return self.encoder_seq is not None\n@@ -559,22 +559,20 @@ class SequenceGroup:\n         return self.encoder_seq\n \n     def get_unfinished_seqs(self) -> List[Sequence]:\n-        return [\n-            seq for seq in self.seqs_dict.values() if not seq.is_finished()\n-        ]\n+        return [seq for seq in self.seqs if not seq.is_finished()]\n \n     def get_finished_seqs(self) -> List[Sequence]:\n-        return [seq for seq in self.seqs_dict.values() if seq.is_finished()]\n+        return [seq for seq in self.seqs if seq.is_finished()]\n \n     def update_num_computed_tokens(self, num_new_computed_tokens: int):\n         \"\"\"Update number of tokens computed so far.\"\"\"\n-        for seq in self.seqs_dict.values():\n+        for seq in self.seqs:\n             if not seq.is_finished():\n                 seq.data.update_num_computed_tokens(num_new_computed_tokens)\n \n     def get_num_uncomputed_tokens(self) -> int:\n         num_uncomputed_tokens = 0\n-        for seq in self.get_seqs():\n+        for seq in self.seqs:\n             if not seq.is_finished():\n                 num_uncomputed_tokens += seq.data.get_num_uncomputed_tokens()\n         return num_uncomputed_tokens\n@@ -583,7 +581,7 @@ class SequenceGroup:\n         # Optimization. We don't need to call get_seqs if we don't need to\n         # filter by states.\n         if status is None:\n-            return len(self.seqs_dict)\n+            return len(self.seqs)\n \n         return len(self.get_seqs(status))\n \n@@ -602,23 +600,25 @@ class SequenceGroup:\n         if seq.seq_id in self.seqs_dict:\n             raise ValueError(f\"Sequence {seq.seq_id} already exists.\")\n         self.seqs_dict[seq.seq_id] = seq\n+        self.seqs.append(seq)\n \n     def remove(self, seq_id: int) -> None:\n-        if seq_id not in self.seqs_dict:\n+        seq = self.seqs_dict.pop(seq_id, None)\n+        if seq is None:\n             raise ValueError(f\"Sequence {seq_id} not found.\")\n-        del self.seqs_dict[seq_id]\n+        self.seqs.remove(seq)\n \n     def is_finished(self) -> bool:\n-        return all(seq.is_finished() for seq in self.get_seqs())\n+        return all(seq.is_finished() for seq in self.seqs)\n \n     def is_prefill(self) -> bool:\n         # Every sequence should be in the same stage.\n-        return self.get_seqs()[0].is_prefill()\n+        return self.seqs[0].is_prefill()\n \n     def __repr__(self) -> str:\n         return (f\"SequenceGroup(request_id={self.request_id}, \"\n                 f\"sampling_params={self.sampling_params}, \"\n-                f\"num_seqs={len(self.seqs_dict)})\")\n+                f\"num_seqs={len(self.seqs)})\")\n \n \n class SequenceGroupMetadata:",
      "change_type": "modified",
      "lines_added": 21,
      "lines_removed": 21
    },
    {
      "file_path": "vllm/transformers_utils/detokenizer.py",
      "old_content": "from typing import Dict, List, Optional, Tuple, Union\n\nfrom transformers import PreTrainedTokenizer, PreTrainedTokenizerFast\n\nfrom vllm.sequence import Logprob, SamplingParams, Sequence, SequenceGroup\nfrom vllm.transformers_utils.tokenizer_group.base_tokenizer_group import (\n    BaseTokenizerGroup)\n\n# Used eg. for marking rejected tokens in spec decoding.\nINVALID_TOKEN_ID = -1\n\n\nclass Detokenizer:\n    \"\"\"Provides methods to decode the output of a model into text.\"\"\"\n\n    def __init__(self, tokenizer_group: BaseTokenizerGroup):\n        self.tokenizer_group = tokenizer_group\n\n    def get_tokenizer_for_seq(self,\n                              sequence: Sequence) -> \"PreTrainedTokenizer\":\n        \"\"\"Returns the HF tokenizer to use for a given sequence.\"\"\"\n        return self.tokenizer_group.get_lora_tokenizer(sequence.lora_request)\n\n    def decode_prompt_logprobs_inplace(self, seq_group: SequenceGroup,\n                                       prompt_logprobs: List[Optional[Dict[\n                                           int, Logprob]]],\n                                       position_offset: int) -> None:\n        \"\"\"Decodes the logprobs for the prompt of a sequence group.\n\n        Args:\n            seq_group: The sequence group to decode.\n            prompt_logprobs: The logprobs to decode.\n            position_offset: Offset of the first index of the logprobs \n                relative to the start of the sequence (for chunked prefill).\n        \n        Returns:\n            The prompt logprobs with the decoded tokens.\n        \"\"\"\n        prms = seq_group.sampling_params\n        assert prms is not None\n\n        # We can pick any sequence for the prompt.\n        seq = next(iter(seq_group.seqs_dict.values()))\n        # Only prompt, without the generated token.\n        all_token_ids = seq.get_token_ids()\n        prompt_token_ids = all_token_ids[:-1]\n        tokenizer = self.get_tokenizer_for_seq(seq)\n        prefix_offset = 0\n        read_offset = 0\n        next_iter_prefix_offset = 0\n        next_iter_read_offset = 0\n        next_iter_tokens: List[str] = []\n        prev_tokens = None\n\n        for token_position_in_logprob, prompt_logprobs_for_token in enumerate(\n                prompt_logprobs):\n\n            # Absolute token position equals the index in the logprobs\n            # list plus the offset of the entire logprobs list relative\n            # to the start of the sequence.\n            token_position = token_position_in_logprob + position_offset\n            if not prompt_logprobs_for_token:\n                continue\n            for token_id, sample_logprob in prompt_logprobs_for_token.items():\n                if (sample_logprob.decoded_token is None\n                        and token_id != INVALID_TOKEN_ID):\n                    prompt_token_ids_with_token = (\n                        prompt_token_ids[:token_position] + [token_id])\n                    (new_tokens, new_text, new_prefix_offset,\n                     new_read_offset) = detokenize_incrementally(\n                         tokenizer=tokenizer,\n                         all_input_ids=prompt_token_ids_with_token,\n                         prev_tokens=prev_tokens,\n                         prefix_offset=prefix_offset,\n                         read_offset=read_offset,\n                         skip_special_tokens=prms.skip_special_tokens,\n                         spaces_between_special_tokens=prms.\n                         spaces_between_special_tokens,\n                     )\n\n                    sample_logprob.decoded_token = new_text\n\n                    # Use the offsets & prev tokens corresponding to\n                    # real tokens to ensure detokenization is consistent\n                    # actual with prompt.\n                    if token_id == all_token_ids[token_position]:\n                        next_iter_prefix_offset = new_prefix_offset\n                        next_iter_read_offset = new_read_offset\n                        next_iter_tokens = new_tokens\n\n            # Advance to the next token position.\n            prefix_offset = next_iter_prefix_offset\n            read_offset = next_iter_read_offset\n            if prev_tokens is None:\n                prev_tokens = next_iter_tokens\n            else:\n                prev_tokens.extend(next_iter_tokens)\n\n    def decode_sequence_inplace(self, seq: Sequence,\n                                prms: SamplingParams) -> int:\n        \"\"\"Decodes the new token for a sequence. In-place operation.\n\n        Args:\n            seq: The sequence to decode.\n            prms: The sampling parameters used to generate the sequence.\n\n        Returns:\n            The number of characters added to the output text.\n        \"\"\"\n        all_input_ids = seq.get_token_ids()\n        token_id_generated_this_iteration = all_input_ids[-1]\n        tokenizer = self.get_tokenizer_for_seq(seq)\n\n        # Convert prompt token IDs to tokens if necessary.\n        # Do it here so that we don't have to repeat this\n        # computation for each logprob.\n        if seq.tokens is None:\n            (seq.tokens, seq.prefix_offset,\n             seq.read_offset) = convert_prompt_ids_to_tokens(\n                 tokenizer=tokenizer,\n                 prompt_ids=all_input_ids[:-1],\n                 skip_special_tokens=prms.skip_special_tokens,\n             )\n\n        (new_tokens, new_decoded_token_text, prefix_offset,\n         read_offset) = detokenize_incrementally(\n             tokenizer=tokenizer,\n             all_input_ids=all_input_ids,\n             prev_tokens=seq.tokens,\n             prefix_offset=seq.prefix_offset,\n             read_offset=seq.read_offset,\n             skip_special_tokens=prms.skip_special_tokens,\n             spaces_between_special_tokens=prms.spaces_between_special_tokens,\n         )\n\n        # Decode logprobs\n        logprobs = seq.output_logprobs[-1]\n        if logprobs:\n            previous_tokens = all_input_ids[:-1]\n            for token_id, sample_logprob in logprobs.items():\n                # If the token was generated this iteration,\n                # use the provided text.\n                if token_id == token_id_generated_this_iteration:\n                    sample_logprob.decoded_token = new_decoded_token_text\n                    continue\n\n                if (sample_logprob.decoded_token is None\n                        and token_id != INVALID_TOKEN_ID):\n                    all_input_ids_with_logprob = previous_tokens + [token_id]\n                    (_, new_text, _, _) = detokenize_incrementally(\n                        tokenizer=tokenizer,\n                        all_input_ids=all_input_ids_with_logprob,\n                        prev_tokens=seq.tokens,\n                        prefix_offset=seq.prefix_offset,\n                        read_offset=seq.read_offset,\n                        skip_special_tokens=prms.skip_special_tokens,\n                        spaces_between_special_tokens=prms.\n                        spaces_between_special_tokens,\n                    )\n                    sample_logprob.decoded_token = new_text\n\n        seq.tokens.extend(new_tokens)\n        seq.prefix_offset = prefix_offset\n        seq.read_offset = read_offset\n        seq.output_text += new_decoded_token_text\n\n        return len(new_decoded_token_text)\n\n\ndef _replace_none_with_empty(tokens: List[Optional[str]]):\n    for i, token in enumerate(tokens):\n        if token is None:\n            tokens[i] = \"\"\n\n\ndef _convert_tokens_to_string_with_added_encoders(\n    tokenizer: Union[PreTrainedTokenizer, PreTrainedTokenizerFast],\n    output_tokens: List[str],\n    skip_special_tokens: bool,\n    spaces_between_special_tokens: bool,\n) -> str:\n    # Adapted from\n    # https://github.com/huggingface/transformers/blob/v4.28.0/src/transformers/tokenization_utils.py#L921\n    # NOTE(woosuk): The following code is slow because it runs a for loop over\n    # the output_tokens. In Python, running a for loop over a list can be slow\n    # even when the loop body is very simple.\n    sub_texts: List[str] = []\n    current_sub_text: List[str] = []\n    all_special_tokens = set(tokenizer.all_special_tokens)\n    for token in output_tokens:\n        if skip_special_tokens and token in all_special_tokens:\n            continue\n        if token in tokenizer.get_added_vocab():\n            if current_sub_text:\n                sub_text = tokenizer.convert_tokens_to_string(current_sub_text)\n                sub_texts.append(sub_text)\n                current_sub_text = []\n            sub_texts.append(token)\n        else:\n            current_sub_text.append(token)\n    if current_sub_text:\n        sub_text = tokenizer.convert_tokens_to_string(current_sub_text)\n        sub_texts.append(sub_text)\n    if spaces_between_special_tokens:\n        return \" \".join(sub_texts)\n    else:\n        return \"\".join(sub_texts)\n\n\n# 5 is an arbitrary value that should work for all\n# tokenizers (bigger = more conservative).\nINITIAL_INCREMENTAL_DETOKENIZATION_OFFSET = 5\n\n\ndef convert_prompt_ids_to_tokens(\n    tokenizer: Union[PreTrainedTokenizer, PreTrainedTokenizerFast],\n    prompt_ids: List[int],\n    skip_special_tokens: bool = False,\n) -> Tuple[List[str], int, int]:\n    \"\"\"Converts the prompt ids to tokens and returns the tokens and offsets\n    for incremental detokenization.\n\n    Note that not all tokens are converted to strings. Only the tokens that\n    are necessary for incremental detokenization are converted to strings.\n    \"\"\"\n    # We do not need to convert the whole prompt to tokens.\n    # Offset a little more in case we have special tokens.\n    new_tokens = tokenizer.convert_ids_to_tokens(\n        prompt_ids[-INITIAL_INCREMENTAL_DETOKENIZATION_OFFSET - 2:],\n        skip_special_tokens=skip_special_tokens)\n    read_offset = len(new_tokens)\n    prefix_offset = max(\n        read_offset - INITIAL_INCREMENTAL_DETOKENIZATION_OFFSET, 0)\n    # This is required to guard against out-of-vocab prompt token ids\n    _replace_none_with_empty(new_tokens)\n    return new_tokens, prefix_offset, read_offset\n\n\n# Based on\n# https://github.com/huggingface/text-generation-inference/blob/v0.9.4/server/text_generation_server/models/model.py#L62C9-L62C15\n# under Apache 2.0 license\ndef detokenize_incrementally(\n    tokenizer: Union[PreTrainedTokenizer, PreTrainedTokenizerFast],\n    all_input_ids: List[int],\n    prev_tokens: Optional[List[str]],\n    prefix_offset: int,\n    read_offset: int,\n    skip_special_tokens: bool = False,\n    spaces_between_special_tokens: bool = True,\n) -> Tuple[List[str], str, int, int]:\n    \"\"\"Detokenizes the input ids incrementally and returns the new tokens\n    and the new text.\n\n    If `prev_tokens` is None, this function will convert the input ids to\n    tokens and return the tokens and the new text. Otherwise, it will return the\n    new tokens and the new text.\n\n    This function will also return the new prefix offset and the new read\n    offset to be used in the next iteration.\n\n    The offsets are necessary to defeat cleanup algorithms in the decode which\n    decide to add a space or not depending on the surrounding ids.\n\n    Args:\n        tokenizer: The tokenizer to use.\n        all_input_ids: The input ids. The last id is the new token id.\n        prev_tokens: The previous tokens. If None, this function will convert\n            the input ids to tokens and return the tokens and the new text.\n        prefix_offset: The prefix offset.\n        read_offset: The read offset.\n        skip_special_tokens: Whether to skip special tokens.\n        spaces_between_special_tokens: Whether to add spaces between special\n            tokens.\n    \"\"\"\n    new_token_id = all_input_ids[-1]\n    # This is the first iteration for this sequence\n    is_first_iter = prev_tokens is None\n    if is_first_iter:\n        (prev_tokens, prefix_offset,\n         read_offset) = convert_prompt_ids_to_tokens(\n             tokenizer,\n             all_input_ids[:-1],\n             skip_special_tokens=skip_special_tokens)\n    assert prev_tokens is not None\n\n    # If the new token id is out of bounds, return an empty string.\n    if new_token_id >= len(tokenizer):\n        new_tokens = [\"\"]\n    else:\n        # Put new_token_id in a list so skip_special_tokens is respected\n        new_tokens = tokenizer.convert_ids_to_tokens(\n            [new_token_id], skip_special_tokens=skip_special_tokens)\n        if isinstance(new_tokens, str):\n            new_tokens = [new_tokens]\n    output_tokens = prev_tokens + new_tokens\n\n    # If this is the first iteration, return all tokens.\n    if is_first_iter:\n        new_tokens = output_tokens\n\n    # The prefix text is necessary only to defeat cleanup algorithms in\n    # the decode which decide to add a space or not depending on the\n    # surrounding ids.\n    if tokenizer.is_fast or not tokenizer.get_added_vocab():\n        prefix_text = tokenizer.convert_tokens_to_string(\n            output_tokens[prefix_offset:read_offset])\n        new_text = tokenizer.convert_tokens_to_string(\n            output_tokens[prefix_offset:])\n    else:\n        prefix_text = _convert_tokens_to_string_with_added_encoders(\n            tokenizer,\n            output_tokens[prefix_offset:read_offset],\n            skip_special_tokens=skip_special_tokens,\n            spaces_between_special_tokens=spaces_between_special_tokens,\n        )\n        new_text = _convert_tokens_to_string_with_added_encoders(\n            tokenizer,\n            output_tokens[prefix_offset:],\n            skip_special_tokens=skip_special_tokens,\n            spaces_between_special_tokens=spaces_between_special_tokens,\n        )\n\n    if len(new_text) <= len(prefix_text) or new_text.endswith(\"\"):\n        # utf-8 char at the end means it's a potential unfinished byte sequence\n        # from byte fallback tokenization.\n        # If it's in the middle, it's probably a real invalid id generated\n        # by the model\n        return new_tokens, \"\", prefix_offset, read_offset\n\n    new_text = new_text[len(prefix_text):]\n    return new_tokens, new_text, read_offset, len(output_tokens)\n",
      "diff": "diff --git a/vllm/transformers_utils/detokenizer.py b/vllm/transformers_utils/detokenizer.py\nindex 76f418674..001af67f3 100644\n--- a/vllm/transformers_utils/detokenizer.py\n+++ b/vllm/transformers_utils/detokenizer.py\n@@ -40,7 +40,7 @@ class Detokenizer:\n         assert prms is not None\n \n         # We can pick any sequence for the prompt.\n-        seq = next(iter(seq_group.seqs_dict.values()))\n+        seq = seq_group.get_seqs()[0]\n         # Only prompt, without the generated token.\n         all_token_ids = seq.get_token_ids()\n         prompt_token_ids = all_token_ids[:-1]",
      "change_type": "modified",
      "lines_added": 2,
      "lines_removed": 2
    }
  ],
  "affected_apis": [
    "SequenceGroup.get_seqs",
    "SequenceGroup.__init__",
    "SequenceGroup.prompt",
    "SequenceGroup.remove",
    "BlockSpaceManagerV1.mark_blocks_as_computed"
  ],
  "summary": {
    "total_files": 3,
    "files_added": 0,
    "files_deleted": 0,
    "files_modified": 3
  },
  "csv_metadata": {
    "category": "miscellaneous",
    "json_has_tests": "FALSE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "Yes (test_block_manager, test_sequence, test_detokenize)",
    "is_benchmark_actually_there": "",
    "sample_clues": "block_manager_v1, blocks, blockspacemanagerv1"
  }
}