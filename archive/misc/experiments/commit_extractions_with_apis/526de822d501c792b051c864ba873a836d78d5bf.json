{
  "commit_hash": "526de822d501c792b051c864ba873a836d78d5bf",
  "parent_hash": "56fe4c297c7d9d872eccc19e3edbf1d75e1a30e2",
  "message": "[Kernel][Triton][AMD] Use block size heuristic for avg 2.8x speedup for int8 models (#11698)\n\nSigned-off-by: Randall Smith <Randall.Smith@amd.com>",
  "author": "rasmith <Randall.Smith@amd.com>",
  "date": "2025-01-08 20:23:15 +0000",
  "files_changed": [
    {
      "file_path": "vllm/model_executor/layers/quantization/compressed_tensors/triton_scaled_mm.py",
      "old_content": "from typing import Optional, Type\n\nimport torch\nimport triton\nimport triton.language as tl\n\n\ndef is_weak_contiguous(x: torch.Tensor):\n    strides = x.stride()\n    sizes = x.shape\n    is_not_transpose = strides[0] == 1 and (strides[1] >= max(1, sizes[0]))\n    is_transpose = strides[1] == 1 and (strides[0] >= max(1, sizes[1]))\n    return is_transpose or is_not_transpose\n\n\n@triton.jit\ndef scaled_mm_kernel(a_ptr, b_ptr, scale_a_ptr, scale_b_ptr, c_ptr, bias_ptr,\n                     M, N, K, stride_am, stride_ak, stride_bk, stride_bn,\n                     stride_cm, stride_cn, ACCUMULATOR_DTYPE: tl.constexpr,\n                     BLOCK_SIZE_M: tl.constexpr, BLOCK_SIZE_N: tl.constexpr,\n                     BLOCK_SIZE_K: tl.constexpr,\n                     BLOCK_SIZE_SCALE_A: tl.constexpr,\n                     BLOCK_SIZE_SCALE_B: tl.constexpr):\n    pid = tl.program_id(axis=0)\n\n    num_pid_n = tl.cdiv(N, BLOCK_SIZE_N)\n\n    pid_m = pid // num_pid_n\n    pid_n = pid % num_pid_n\n\n    accumulator_dtype = ACCUMULATOR_DTYPE\n    accumulator = tl.zeros((BLOCK_SIZE_M, BLOCK_SIZE_N),\n                           dtype=accumulator_dtype)\n\n    # NOTE: Some tensor inputs are so large, they will cause int32 overflow\n    # so it is necessary to use tl.int64 for all the offsets, else SEGV will\n    # eventually occur.\n\n    # Offsets and masks.\n    offsets_am = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M).to(tl.int64)\n    masks_am = offsets_am < M\n\n    offsets_bn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N).to(tl.int64)\n    masks_bn = offsets_bn < N\n\n    offsets_k = tl.arange(0, BLOCK_SIZE_K).to(tl.int64)\n    offsets_a = (stride_am * offsets_am[:, None] +\n                 stride_ak * offsets_k[None, :])\n    offsets_b = (stride_bk * offsets_k[:, None] +\n                 stride_bn * offsets_bn[None, :])\n\n    # NOTE: BLOCK_SIZE_SCALE_A could be 1 or BLOCK_SIZE_M, so need to create\n    # appropriate offsets and masks for each case. Same goes for\n    # BLOCK_SIZE_SCALE_B.\n    offsets_scale_am = (tl.arange(0, BLOCK_SIZE_SCALE_A) +\n                        (BLOCK_SIZE_SCALE_A > 1) * pid_m * BLOCK_SIZE_M)\n    masks_scale_am = offsets_scale_am < M\n\n    offsets_scale_bn = (tl.arange(0, BLOCK_SIZE_SCALE_B) +\n                        (BLOCK_SIZE_SCALE_B > 1) * pid_n * BLOCK_SIZE_N)\n    masks_scale_bn = offsets_scale_bn < N\n\n    a_ptrs = a_ptr + offsets_a\n    b_ptrs = b_ptr + offsets_b\n\n    scale_a_ptrs = scale_a_ptr + offsets_scale_am\n    scale_b_ptrs = scale_b_ptr + offsets_scale_bn\n\n    for k in range(0, tl.cdiv(K, BLOCK_SIZE_K)):\n        masks_k = offsets_k < K\n        masks_a = masks_am[:, None] & masks_k[None, :]\n        a = tl.load(a_ptrs, mask=masks_a)\n\n        masks_b = masks_k[:, None] & masks_bn[None, :]\n        b = tl.load(b_ptrs, mask=masks_b)\n\n        # Accumulate results.\n        accumulator = tl.dot(a, b, accumulator, out_dtype=accumulator_dtype)\n\n        offsets_k += BLOCK_SIZE_K\n        a_ptrs += BLOCK_SIZE_K * stride_ak\n        b_ptrs += BLOCK_SIZE_K * stride_bk\n\n    # Apply scale at end.\n    masks_scale_a = masks_scale_am[:, None] & (tl.arange(0, 1) < 1)[:, None]\n    scale_a = tl.load(scale_a_ptrs[:, None], masks_scale_a)\n    # Need to broadcast to the appropriate size, if scale_a is already\n    # (BLOCK_SIZE_M, 1) then it will broadcast to its own shape. Same goes\n    # for scale_b below.\n    scale_a = scale_a.broadcast_to((BLOCK_SIZE_M, 1))\n    accumulator = scale_a * accumulator.to(tl.float32)\n\n    masks_scale_b = masks_scale_bn[:, None] & (tl.arange(0, 1) < 1)[None, :]\n    scale_b = tl.load(scale_b_ptrs[:, None], masks_scale_b)\n    scale_b = scale_b.broadcast_to((BLOCK_SIZE_N, 1))\n    accumulator = scale_b.T * accumulator.to(tl.float32)\n\n    # Convert to output format.\n    c = accumulator.to(c_ptr.type.element_ty)\n\n    # Add bias, it's already in output format, so add it after conversion.\n    if bias_ptr:\n        offsets_bias = offsets_bn\n        bias_ptrs = bias_ptr + offsets_bias\n        bias_mask = offsets_bias < N\n        bias = tl.load(bias_ptrs, bias_mask)\n        c += bias\n\n    # Save output\n    offs_cm = pid_m * BLOCK_SIZE_M + tl.arange(0, BLOCK_SIZE_M).to(tl.int64)\n    offs_cn = pid_n * BLOCK_SIZE_N + tl.arange(0, BLOCK_SIZE_N).to(tl.int64)\n    offs_cm = offs_cm.to(tl.int64)\n    offs_cn = offs_cn.to(tl.int64)\n    c_ptrs = (c_ptr + stride_cm * offs_cm[:, None] +\n              stride_cn * offs_cn[None, :])\n    c_mask = (offs_cm[:, None] < M) & (offs_cn[None, :] < N)\n\n    tl.store(c_ptrs, c, mask=c_mask)\n\n\n# input   - [M, K]\n# weight - [K, N]\ndef triton_scaled_mm(input: torch.Tensor,\n                     weight: torch.Tensor,\n                     scale_a: torch.Tensor,\n                     scale_b: torch.Tensor,\n                     out_dtype: Type[torch.dtype],\n                     bias: Optional[torch.Tensor] = None,\n                     block_size_m: int = 32,\n                     block_size_n: int = 32,\n                     block_size_k: int = 32) -> torch.Tensor:\n    M, K = input.shape\n    N = weight.shape[1]\n\n    assert N > 0 and K > 0 and M > 0\n    assert weight.shape[0] == K\n    assert input.dtype == weight.dtype\n    assert scale_a.dtype == scale_b.dtype and scale_a.is_floating_point()\n    assert scale_a.shape == torch.Size([1, 1]) or scale_a.shape == torch.Size(\n        [M, 1])\n    assert scale_b.shape == torch.Size([1, 1]) or scale_b.shape == torch.Size(\n        [N, 1])\n    assert out_dtype.is_floating_point\n    assert bias is None or bias.is_floating_point()\n    assert is_weak_contiguous(input)\n    assert is_weak_contiguous(weight)\n\n    grid = lambda META: (triton.cdiv(M, META['BLOCK_SIZE_M']) * triton.cdiv(\n        N, META['BLOCK_SIZE_N']), )\n\n    result = torch.empty((M, N), dtype=out_dtype, device=input.device)\n\n    has_scalar = lambda x: x.shape[0] == 1 and x.shape[1] == 1\n\n    block_size_sa = 1 if has_scalar(scale_a) else block_size_m\n    block_size_sb = 1 if has_scalar(scale_b) else block_size_n\n\n    accumulator_dtype = tl.float32 if input.is_floating_point() else tl.int32\n\n    # A = input, B = weight, C = result\n    # A = M x K, B = K x N, C = M x N\n    scaled_mm_kernel[grid](input,\n                           weight,\n                           scale_a,\n                           scale_b,\n                           result,\n                           bias,\n                           M,\n                           N,\n                           K,\n                           input.stride(0),\n                           input.stride(1),\n                           weight.stride(0),\n                           weight.stride(1),\n                           result.stride(0),\n                           result.stride(1),\n                           accumulator_dtype,\n                           BLOCK_SIZE_M=block_size_m,\n                           BLOCK_SIZE_N=block_size_n,\n                           BLOCK_SIZE_K=block_size_k,\n                           BLOCK_SIZE_SCALE_A=block_size_sa,\n                           BLOCK_SIZE_SCALE_B=block_size_sb)\n\n    return result.to(out_dtype)\n",
      "diff": "diff --git a/vllm/model_executor/layers/quantization/compressed_tensors/triton_scaled_mm.py b/vllm/model_executor/layers/quantization/compressed_tensors/triton_scaled_mm.py\nindex 3ff162170..2659afcdc 100644\n--- a/vllm/model_executor/layers/quantization/compressed_tensors/triton_scaled_mm.py\n+++ b/vllm/model_executor/layers/quantization/compressed_tensors/triton_scaled_mm.py\n@@ -128,7 +128,8 @@ def triton_scaled_mm(input: torch.Tensor,\n                      bias: Optional[torch.Tensor] = None,\n                      block_size_m: int = 32,\n                      block_size_n: int = 32,\n-                     block_size_k: int = 32) -> torch.Tensor:\n+                     block_size_k: int = 32,\n+                     use_heuristic=True) -> torch.Tensor:\n     M, K = input.shape\n     N = weight.shape[1]\n \n@@ -152,6 +153,20 @@ def triton_scaled_mm(input: torch.Tensor,\n \n     has_scalar = lambda x: x.shape[0] == 1 and x.shape[1] == 1\n \n+    if use_heuristic:\n+        is_small_N = N < 8192\n+        next_power_of_2_M = max(32, triton.next_power_of_2(M))\n+        if next_power_of_2_M <= 32:\n+            tile_shape = (64, 64, 256) if is_small_N else (64, 128, 256)\n+        elif next_power_of_2_M <= 64:\n+            tile_shape = (64, 64, 256)\n+        elif next_power_of_2_M <= 128:\n+            tile_shape = (64, 128, 128)\n+        else:\n+            tile_shape = (128, 128, 128)\n+\n+    block_size_m, block_size_n, block_size_k = tile_shape\n+\n     block_size_sa = 1 if has_scalar(scale_a) else block_size_m\n     block_size_sb = 1 if has_scalar(scale_b) else block_size_n",
      "change_type": "modified",
      "lines_added": 17,
      "lines_removed": 2
    }
  ],
  "affected_apis": [
    "vllm.model_executor.layers.quantization.compressed_tensors.triton_scaled_mm.triton_scaled_mm"
  ],
  "summary": {
    "total_files": 1,
    "files_added": 0,
    "files_deleted": 0,
    "files_modified": 1
  },
  "csv_metadata": {
    "category": "kernel-based",
    "json_has_tests": "FALSE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "YES (test_triton_scaled_mm)",
    "is_benchmark_actually_there": "",
    "sample_clues": "scaled, triton, triton_scaled_mm"
  }
}