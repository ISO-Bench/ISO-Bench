{
  "commit_hash": "d7740ea4dcee4ab75d7d6eef723f33cae957b288",
  "parent_hash": "cc466a32903d53d0ceca459b766d74ad668c8f87",
  "message": "[Core] Optimize sampler get_logprobs (#4594)",
  "author": "SangBin Cho <rkooo567@gmail.com>",
  "date": "2024-05-08 08:42:28 -0700",
  "files_changed": [
    {
      "file_path": "vllm/model_executor/layers/sampler.py",
      "old_content": "\"\"\"A layer that samples the next tokens from the model's outputs.\"\"\"\nimport itertools\nfrom typing import Dict, List, Optional, Tuple\n\nimport torch\nimport torch.nn as nn\n\nfrom vllm.model_executor.layers.ops.sample import sample as sample_triton\nfrom vllm.model_executor.sampling_metadata import (SamplingMetadata,\n                                                   SamplingTensors,\n                                                   SequenceGroupToSample)\nfrom vllm.sampling_params import SamplingType\nfrom vllm.sequence import (Logprob, PromptLogprobs, SampleLogprobs,\n                           SamplerOutput, SequenceGroupOutput, SequenceOutput)\n\n# (num_token_ids, num_parent_ids) per sequence group.\nSampleResultType = List[Tuple[List[int], List[int]]]\n\n\nclass Sampler(nn.Module):\n    \"\"\"Samples the next tokens from the model's outputs.\n\n    This layer does the following:\n    1. Discard the hidden states that are not used for sampling (i.e., all\n        tokens except the final one in each prompt).\n    2. Compute the logits for the next tokens.\n    3. Apply presence, frequency and repetition penalties.\n    4. Apply temperature scaling.\n    5. Apply top-p and top-k truncation.\n    6. Sample the next tokens.\n    Here, each sequence group within the batch can have different sampling\n    parameters (e.g., sampling method, temperature, top-p, top-k, etc.).\n\n    The structure of the logits tensor is coupled with the seq_groups in\n    sampling_metadata. Typically, each sequence in each seq_group has one row in\n    logits for the next token to be sampled; however, for a seq_group with a\n    prompt request with the prompt_logprobs sampling parameter, there are rows\n    in logits for each token in the input prompt.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n\n        # Whether or not the SamplerOutput should have on-device tensors\n        # containing the sampled token ids and probabilities. This is used by\n        # speculative decoding.\n        self.include_gpu_probs_tensor = False\n\n    def forward(\n        self,\n        logits: torch.Tensor,\n        sampling_metadata: SamplingMetadata,\n    ) -> Optional[SamplerOutput]:\n        \"\"\"\n        Args:\n            logits: (num_tokens, vocab_size).\n            sampling_metadata: Metadata for sampling.\n        \"\"\"\n        assert logits is not None\n        _, vocab_size = logits.shape\n\n        logits = _apply_min_tokens_penalty(logits, sampling_metadata)\n\n        # Prepare sampling tensors with pinned memory to avoid blocking.\n        (sampling_tensors, do_penalties, do_top_p_top_k,\n         do_min_p) = SamplingTensors.from_sampling_metadata(\n             sampling_metadata, vocab_size, logits.device, logits.dtype)\n\n        # Apply presence and frequency penalties.\n        if do_penalties:\n            logits = _apply_penalties(logits, sampling_tensors.prompt_tokens,\n                                      sampling_tensors.output_tokens,\n                                      sampling_tensors.presence_penalties,\n                                      sampling_tensors.frequency_penalties,\n                                      sampling_tensors.repetition_penalties)\n\n        # Apply temperature scaling.\n        # Use in-place division to avoid creating a new tensor.\n        logits.div_(sampling_tensors.temperatures.unsqueeze_(dim=1))\n\n        if do_top_p_top_k:\n            logits = _apply_top_k_top_p(logits, sampling_tensors.top_ps,\n                                        sampling_tensors.top_ks)\n\n        if do_min_p:\n            logits = _apply_min_p(logits, sampling_tensors.min_ps)\n\n        # We use float32 for probabilities and log probabilities.\n        # Compute the probabilities.\n        probs = torch.softmax(logits, dim=-1, dtype=torch.float)\n        # Compute the log probabilities.\n        logprobs = torch.log_softmax(logits, dim=-1, dtype=torch.float)\n\n        # Sample the next tokens.\n        sample_results, maybe_sampled_tokens_tensor = _sample(\n            probs,\n            logprobs,\n            sampling_metadata,\n            sampling_tensors,\n            include_gpu_probs_tensor=self.include_gpu_probs_tensor,\n            modify_greedy_probs=self._should_modify_greedy_probs_inplace,\n        )\n\n        if self.include_gpu_probs_tensor:\n            assert maybe_sampled_tokens_tensor is not None\n            on_device_tensors = (probs, logprobs, maybe_sampled_tokens_tensor)\n        else:\n            on_device_tensors = None\n\n        # Get the logprobs query results.\n        prompt_logprobs, sample_logprobs = _get_logprobs(\n            logprobs, sampling_metadata, sample_results)\n        return _build_sampler_output(sample_results,\n                                     sampling_metadata,\n                                     prompt_logprobs,\n                                     sample_logprobs,\n                                     on_device_tensors=on_device_tensors)\n\n    @property\n    def _should_modify_greedy_probs_inplace(self) -> bool:\n        \"\"\"Whether or not the sampler should modify the probability distribution\n        of greedily-sampled tokens such that multinomial sampling would sample\n        the greedily-sampled token.\n\n        In other words, if True then we set the probability of the greedily-\n        sampled token to 1.\n\n        This is used by speculative decoding, which requires that the sampling\n        method be encoded into the probability distribution.\n        \"\"\"\n        # Modify greedy probs if include_gpu_probs_tensor is set.\n        return self.include_gpu_probs_tensor\n\n\ndef _get_bin_counts_and_mask(\n    tokens: torch.Tensor,\n    vocab_size: int,\n    num_seqs: int,\n) -> Tuple[torch.Tensor, torch.Tensor]:\n    # Compute the bin counts for the tokens.\n    # vocab_size + 1 for padding.\n    bin_counts = torch.zeros((num_seqs, vocab_size + 1),\n                             dtype=torch.long,\n                             device=tokens.device)\n    bin_counts.scatter_add_(1, tokens, torch.ones_like(tokens))\n    bin_counts = bin_counts[:, :vocab_size]\n    mask = bin_counts > 0\n\n    return bin_counts, mask\n\n\ndef _apply_min_tokens_penalty(\n    logits: torch.Tensor,\n    sampling_metadata: SamplingMetadata,\n) -> torch.Tensor:\n    \"\"\"Apply min_tokens penalty which sets stop tokens to -inf if min_tokens\n        have not been generated yet\n    \"\"\"\n    # list of indices in logits that will be set to -inf\n    logits_to_penalize: List[Tuple[int, int]] = []\n    logits_applied = 0\n    for seq_group in sampling_metadata.seq_groups:\n        seq_ids = seq_group.seq_ids\n        sampling_params = seq_group.sampling_params\n\n        sample_indices = seq_group.sample_indices\n        logits_applied += len(sample_indices) + len(\n            seq_group.prompt_logprob_indices)\n        if not seq_group.do_sample:\n            continue\n\n        start_idx = sample_indices[0]\n        min_tokens = sampling_params.min_tokens\n        token_ids_to_penalize = sampling_params.all_stop_token_ids\n        if min_tokens > 0 and token_ids_to_penalize:\n            seqs_to_penalize = []\n            for j, seq_id in enumerate(seq_ids):\n                seq_data = seq_group.seq_data[seq_id]\n                if len(seq_data.output_token_ids) < min_tokens:\n                    seqs_to_penalize.append(j)\n\n            if seqs_to_penalize:\n                # convert to the index into logits\n                seqs_to_penalize = [start_idx + j for j in seqs_to_penalize]\n                # itertools.product pairs each seq index with every token id\n                logits_to_penalize.extend(\n                    itertools.product(seqs_to_penalize, token_ids_to_penalize))\n\n    if logits_to_penalize:\n        # use zip and * to group indices along each dimension\n        # eg. [ (1,2), (1,3), (5,6) ] -> ( (1,1,5), (2,3,6) )\n        logits[tuple(zip(*logits_to_penalize))] = -float(\"inf\")\n\n    # verifies that no rows in logits were missed unexpectedly\n    assert logits_applied == logits.shape[0]\n    return logits\n\n\ndef _apply_penalties(logits: torch.Tensor, prompt_tokens_tensor: torch.Tensor,\n                     output_tokens_tensor: torch.Tensor,\n                     presence_penalties: torch.Tensor,\n                     frequency_penalties: torch.Tensor,\n                     repetition_penalties: torch.Tensor) -> torch.Tensor:\n    num_seqs, vocab_size = logits.shape\n    _, prompt_mask = _get_bin_counts_and_mask(prompt_tokens_tensor, vocab_size,\n                                              num_seqs)\n    output_bin_counts, output_mask = _get_bin_counts_and_mask(\n        output_tokens_tensor, vocab_size, num_seqs)\n\n    repetition_penalties = repetition_penalties[:, None].repeat(1, vocab_size)\n    repetition_penalties[~(prompt_mask | output_mask)] = 1.0\n    logits = torch.where(logits > 0, logits / repetition_penalties,\n                         logits * repetition_penalties)\n\n    # We follow the definition in OpenAI API.\n    # Refer to https://platform.openai.com/docs/api-reference/parameter-details\n    logits -= frequency_penalties.unsqueeze_(dim=1) * output_bin_counts\n    logits -= presence_penalties.unsqueeze_(dim=1) * output_mask\n    return logits\n\n\ndef _apply_top_k_top_p(\n    logits: torch.Tensor,\n    p: torch.Tensor,\n    k: torch.Tensor,\n) -> torch.Tensor:\n    logits_sort, logits_idx = logits.sort(dim=-1, descending=False)\n\n    # Apply top-k.\n    top_k_mask = logits_sort.size(1) - k.to(torch.long)\n    # Get all the top_k values.\n    top_k_mask = logits_sort.gather(1, top_k_mask.unsqueeze(dim=1))\n    top_k_mask = logits_sort < top_k_mask\n    logits_sort.masked_fill_(top_k_mask, -float(\"inf\"))\n\n    # Apply top-p.\n    probs_sort = logits_sort.softmax(dim=-1)\n    probs_sum = probs_sort.cumsum(dim=-1)\n    top_p_mask = probs_sum <= 1 - p.unsqueeze(dim=1)\n    # at least one\n    top_p_mask[:, -1] = False\n    logits_sort.masked_fill_(top_p_mask, -float(\"inf\"))\n\n    # Re-sort the probabilities.\n    src = torch.arange(logits_idx.shape[-1],\n                       device=logits_idx.device).expand_as(logits_idx)\n    logits_idx_inv = torch.empty_like(logits_idx).scatter_(dim=-1,\n                                                           index=logits_idx,\n                                                           src=src)\n    logits = torch.gather(logits_sort, dim=-1, index=logits_idx_inv)\n    return logits\n\n\ndef _apply_min_p(\n    logits: torch.Tensor,\n    min_p: torch.Tensor,\n) -> torch.Tensor:\n    \"\"\"\n    Adapted from\n    https://github.com/oobabooga/text-generation-webui/blob/3146124ec01f02c8fb1650a6517cf1b60b537aaf/modules/sampler_hijack.py#L16C17-L16C17\n    \"\"\"\n    probs = torch.softmax(logits, dim=-1)\n    top_probs, _ = probs.max(dim=-1, keepdim=True)\n    scaled_min_p = min_p.unsqueeze_(dim=1) * top_probs\n    tokens_to_remove = probs < scaled_min_p\n    logits = logits.masked_fill_(tokens_to_remove, -float(\"inf\"))\n\n    return logits\n\n\ndef _greedy_sample(\n    selected_seq_groups: List[SequenceGroupToSample],\n    samples: torch.Tensor,\n) -> SampleResultType:\n    \"\"\"Run greedy sampling on a given samples.\n\n    Args:\n        selected_seq_groups: A list of sequence groups batched.\n        samples: (num_selected_samples,) A tensor of samples. The length of\n            samples could be smaller than selected_seq_groups if\n            seq_group.do_sample is False.\n    Returns:\n        Tuple of (next_token_ids, parent_ids). The length of returned list is\n        same as the length of selected_seq_groups. If the corresponding\n        seq_group has do_sample=False, tuple contains ([], [])\n    \"\"\"\n    samples = samples.tolist()\n    sample_idx = 0\n    results: SampleResultType = []\n    for seq_group in selected_seq_groups:\n        if not seq_group.do_sample:\n            results.append(([], []))\n            continue\n\n        seq_ids = seq_group.seq_ids\n        num_parent_seqs = len(seq_ids)\n        assert num_parent_seqs == 1, (\n            \"Greedy sampling should have only one seq.\")\n        parent_ids = list(range(num_parent_seqs))\n        next_token_ids = [samples[sample_idx]]\n        results.append((next_token_ids, parent_ids))\n        sample_idx += num_parent_seqs\n    return results\n\n\ndef _random_sample(\n    selected_seq_groups: List[SequenceGroupToSample],\n    random_samples: torch.Tensor,\n) -> SampleResultType:\n    \"\"\"Run random sampling on a given samples.\n\n    Args:\n        selected_seq_groups: A list of sequence groups batched.\n        random_samples: (num_selected_samples,) A tensor of samples. The\n            length of samples could be smaller than selected_seq_groups if\n            seq_group.do_sample is False.\n    Returns:\n        Tuple of (next_token_ids, parent_ids). The length of returned list is\n        same as the length of selected_seq_groups. If the corresponding\n        seq_group has do_sample=False, tuple contains ([], [])\n    \"\"\"\n    # Find the maximum best_of value of the prompt phase requests.\n    random_samples = random_samples.cpu()\n    sample_idx = 0\n    results: SampleResultType = []\n    for seq_group in selected_seq_groups:\n        if not seq_group.do_sample:\n            results.append(([], []))\n            continue\n\n        seq_ids = seq_group.seq_ids\n        sampling_params = seq_group.sampling_params\n        is_prompt = seq_group.is_prompt\n        num_parent_seqs = len(seq_ids)\n        if is_prompt:\n            # Prompt phase.\n            parent_ids = [0] * sampling_params.best_of\n            next_token_ids = random_samples[\n                sample_idx, :sampling_params.best_of].tolist()\n        else:\n            # Generation phase.\n            parent_ids = list(range(num_parent_seqs))\n            next_token_ids = random_samples[sample_idx:sample_idx +\n                                            num_parent_seqs, 0].tolist()\n        results.append((next_token_ids, parent_ids))\n        sample_idx += num_parent_seqs\n    return results\n\n\ndef _beam_search_sample(\n    selected_seq_groups: List[SequenceGroupToSample],\n    logprobs: torch.Tensor,\n) -> SampleResultType:\n    \"\"\"Run beam sampling on a given samples.\n\n    Args:\n        selected_seq_groups: A list of sequence groups batched.\n        logprobs: (num_selected_samples, vocab_size,) A tensor of logprob\n        on selected sample indices.\n    Returns:\n        Tuple of (next_token_ids, parent_ids). The length of returned list is\n        same as the length of selected_seq_groups. If the corresponding\n        seq_group has do_sample=False, tuple contains ([], [])\n    \"\"\"\n    # We sample 2 * beam_width candidates to make sure that with high\n    # probability we can get `beam_width` candidates in addition to\n    # the finished sequences for the next iteration. See\n    # https://github.com/tensorflow/tensor2tensor/blob/bafdc1b67730430d38d6ab802cbd51f9d053ba2e/tensor2tensor/utils/beam_search.py#L557-L563\n    # for details. See also HF reference:\n    # https://github.com/huggingface/transformers/blob/a4dd53d88e4852f023332d284ff07a01afcd5681/src/transformers/generation/utils.py#L3063-L3065\n    #\n    # NOTE: Beam search is not vectorized, so its speed can be slower than\n    # other sampling methods.\n    sample_idx = 0\n    results: SampleResultType = []\n    for seq_group in selected_seq_groups:\n        if not seq_group.do_sample:\n            results.append(([], []))\n            continue\n\n        is_prompt = seq_group.is_prompt\n        seq_ids, sampling_params = seq_group.seq_ids, seq_group.sampling_params\n        num_parent_seqs = len(seq_ids)\n        beam_width = sampling_params.best_of\n        seq_group_logprobs = logprobs[sample_idx:sample_idx + num_parent_seqs]\n        if is_prompt:\n            # Prompt phase.\n            assert num_parent_seqs == 1, (\n                \"Prompt input should have only one seq.\")\n            parent_ids = [0] * (2 * beam_width)\n            _, next_token_ids = torch.topk(seq_group_logprobs[0],\n                                           2 * beam_width)\n            next_token_ids = next_token_ids.tolist()\n        else:\n            # Generation phase.\n            cumulative_logprobs: List[int] = [\n                seq_group.seq_data[seq_id].cumulative_logprob\n                for seq_id in seq_ids\n            ]\n            cumulative_logprobs_tensor = torch.tensor(\n                cumulative_logprobs,\n                dtype=torch.float,\n                device=seq_group_logprobs.device)\n            seq_group_logprobs = (seq_group_logprobs +\n                                  cumulative_logprobs_tensor.unsqueeze(dim=1))\n            _, topk_ids = torch.topk(seq_group_logprobs.flatten(),\n                                     2 * beam_width)\n            topk_ids = topk_ids.tolist()\n            vocab_size = seq_group_logprobs.size(-1)\n            parent_ids = [i // vocab_size for i in topk_ids]\n            next_token_ids = [i % vocab_size for i in topk_ids]\n        results.append((next_token_ids, parent_ids))\n        sample_idx += num_parent_seqs\n    assert sample_idx == logprobs.size(0)\n    return results\n\n\n# torch.multinomial forces a GPU<->CPU sync.\n# Therefore, we use an optimized implementation instead.\n# Note that we always sample with replacement.\n# probs will be modified in place, but this is fine, as we pass\n# in a copy already.\ndef _multinomial(\n    probs: torch.Tensor,\n    num_samples: int,\n    seq_groups: Optional[List[SequenceGroupToSample]] = None,\n) -> torch.Tensor:\n    if num_samples > 1:\n        # This is equivalent to torch.repeat_interleaved (which also\n        # forces a GPU<->CPU sync).\n        # This allows us to do sampling with replacement by creating\n        # num_samples copies of each row in the tensor, and then\n        # batch sampling the resulting tensor.\n        probs = probs[:, None, :].expand(probs.shape[0], num_samples,\n                                         probs.shape[1]).contiguous().view(\n                                             -1, probs.shape[1])\n    q = torch.empty_like(probs)\n    if seq_groups is None:\n        q.exponential_()\n    else:\n        sample_idx = 0\n        for seq_group in seq_groups:\n            seq_ids = seq_group.seq_ids\n            next_sample_idx = sample_idx + len(seq_ids) * num_samples\n            q[sample_idx:next_sample_idx].exponential_(\n                generator=seq_group.generator)\n            sample_idx = next_sample_idx\n    return probs.div_(q).argmax(dim=1).view(-1, num_samples)\n\n\ndef _sample_with_torch(\n    probs: torch.Tensor,\n    logprobs: torch.Tensor,\n    sampling_metadata: SamplingMetadata,\n    include_gpu_probs_tensor: bool,\n    modify_greedy_probs: bool,\n) -> Tuple[SampleResultType, Optional[torch.Tensor]]:\n    categorized_seq_group_ids: Dict[SamplingType,\n                                    List[int]] = {t: []\n                                                  for t in SamplingType}\n    categorized_sample_indices = sampling_metadata.categorized_sample_indices\n    for i, seq_group in enumerate(sampling_metadata.seq_groups):\n        sampling_params = seq_group.sampling_params\n        sampling_type = sampling_params.sampling_type\n        categorized_seq_group_ids[sampling_type].append(i)\n\n    sample_results_dict: Dict[int, Tuple[List[int], List[int]]] = {}\n    sample_metadata = {}\n    multinomial_samples = {}\n\n    # Create output tensor for sampled token ids.\n    if include_gpu_probs_tensor:\n        sampled_token_ids_tensor = torch.empty(logprobs.shape[0],\n                                               1,\n                                               dtype=torch.long,\n                                               device=logprobs.device)\n    else:\n        sampled_token_ids_tensor = None\n\n    # Counterintiutively, having two loops here is actually faster.\n    # The first loop can run without waiting on GPU<->CPU sync.\n    for sampling_type in SamplingType:\n        sample_indices = categorized_sample_indices[sampling_type][:, 0]\n        num_tokens = len(sample_indices)\n        if num_tokens == 0:\n            continue\n\n        seq_group_id = categorized_seq_group_ids[sampling_type]\n        seq_groups = [sampling_metadata.seq_groups[i] for i in seq_group_id]\n        sample_metadata[sampling_type] = (seq_group_id, seq_groups)\n        long_sample_indices = sample_indices.long()\n        if sampling_type == SamplingType.GREEDY:\n            greedy_samples = torch.argmax(logprobs[long_sample_indices],\n                                          dim=-1)\n\n            if include_gpu_probs_tensor:\n                # Store sampled tokens in output tensor.\n                sampled_token_ids_tensor[\n                    long_sample_indices] = greedy_samples.unsqueeze(-1)\n\n            if modify_greedy_probs:\n                # If required, modify the probabilities such that sampling from\n                # the modified distribution would always sample the argmax\n                # token id.\n                _modify_greedy_probs_inplace(logprobs, probs,\n                                             long_sample_indices,\n                                             greedy_samples)\n\n        elif sampling_type in (SamplingType.RANDOM, SamplingType.RANDOM_SEED):\n            max_best_of_in_batch = 1\n            for seq_group in seq_groups:\n                if seq_group.is_prompt:\n                    sampling_params = seq_group.sampling_params\n                    max_best_of_in_batch = max(max_best_of_in_batch,\n                                               sampling_params.best_of)\n            seeded_args = {} if sampling_type == SamplingType.RANDOM else {\n                \"seq_groups\": seq_groups,\n            }\n\n            multinomial_samples[sampling_type] = _multinomial(\n                probs[long_sample_indices], max_best_of_in_batch,\n                **seeded_args)\n\n            if include_gpu_probs_tensor:\n                # Store sampled tokens in output tensor.\n                sampled_token_ids_tensor[\n                    long_sample_indices] = multinomial_samples[sampling_type]\n\n        elif sampling_type == SamplingType.BEAM:\n            beam_search_logprobs = logprobs[sample_indices]\n        else:\n            raise ValueError(f\"Unsupported sampling type: {sampling_type}\")\n\n    # GPU<->CPU sync happens in the loop below.\n    # This also converts the sample output to Python objects.\n    for sampling_type in SamplingType:\n        if sampling_type not in sample_metadata:\n            continue\n        (seq_group_id, seq_groups) = sample_metadata[sampling_type]\n        if sampling_type == SamplingType.GREEDY:\n            sample_results = _greedy_sample(seq_groups, greedy_samples)\n        elif sampling_type in (SamplingType.RANDOM, SamplingType.RANDOM_SEED):\n            sample_results = _random_sample(seq_groups,\n                                            multinomial_samples[sampling_type])\n        elif sampling_type == SamplingType.BEAM:\n            sample_results = _beam_search_sample(seq_groups,\n                                                 beam_search_logprobs)\n        sample_results_dict.update(zip(seq_group_id, sample_results))\n\n    sample_results = [\n        sample_results_dict.get(i, ([], []))\n        for i in range(len(sampling_metadata.seq_groups))\n    ]\n    return sample_results, sampled_token_ids_tensor\n\n\ndef _sample_with_triton_kernel(\n    probs: torch.Tensor,\n    logprobs: torch.Tensor,\n    sampling_metadata: SamplingMetadata,\n    sampling_tensors: SamplingTensors,\n) -> SampleResultType:\n    categorized_seq_group_ids: Dict[SamplingType,\n                                    List[int]] = {t: []\n                                                  for t in SamplingType}\n    categorized_sample_indices = sampling_metadata.categorized_sample_indices\n    for i, seq_group in enumerate(sampling_metadata.seq_groups):\n        sampling_params = seq_group.sampling_params\n        sampling_type = sampling_params.sampling_type\n        categorized_seq_group_ids[sampling_type].append(i)\n\n    sample_results_dict: Dict[int, Tuple[List[int], List[int]]] = {}\n    sample_metadata = {}\n    max_best_of_in_batch = 1\n\n    # Counterintiutively, having two loops here is actually faster.\n    # The first loop can run without waiting on GPU<->CPU sync.\n    for sampling_type in SamplingType:\n        sample_indices = categorized_sample_indices[sampling_type][:, 0]\n        sampled_token_indices = categorized_sample_indices[sampling_type][:, 1]\n        num_tokens = len(sample_indices)\n        if num_tokens == 0:\n            continue\n        seq_group_id = categorized_seq_group_ids[sampling_type]\n        seq_groups = [sampling_metadata.seq_groups[i] for i in seq_group_id]\n        sample_metadata[sampling_type] = (seq_group_id, seq_groups,\n                                          sample_indices,\n                                          sampled_token_indices)\n        if sampling_type in (SamplingType.GREEDY, SamplingType.RANDOM,\n                             SamplingType.RANDOM_SEED):\n            for seq_group in seq_groups:\n                if seq_group.is_prompt:\n                    sampling_params = seq_group.sampling_params\n                    max_best_of_in_batch = max(max_best_of_in_batch,\n                                               sampling_params.best_of)\n        elif sampling_type == SamplingType.BEAM:\n            beam_search_logprobs = logprobs[sample_indices]\n        else:\n            raise ValueError(f\"Unsupported sampling type: {sampling_type}\")\n\n    sampled_tokens, _, _ = sample_triton(\n        probs=probs,\n        seeds=sampling_tensors.sampling_seeds,\n        max_best_of=max_best_of_in_batch,\n        sample_indices=sampling_tensors.sample_indices,\n        logprobs=logprobs,\n        # don't save logprobs because we have logic for that below\n        # TODO: use this instead of the CPU-based logic below\n        save_logprobs=False,\n    )\n\n    # GPU<->CPU sync happens in the loop below.\n\n    for sampling_type in SamplingType:\n        if sampling_type not in sample_metadata:\n            continue\n        (seq_group_id, seq_groups, sample_indices,\n         sampled_token_indices) = sample_metadata[sampling_type]\n        if sampling_type == SamplingType.GREEDY:\n            sample_results = _greedy_sample(\n                seq_groups, sampled_tokens[sampled_token_indices][:, 0])\n        elif sampling_type in (SamplingType.RANDOM, SamplingType.RANDOM_SEED):\n            sample_results = _random_sample(\n                seq_groups, sampled_tokens[sampled_token_indices])\n        elif sampling_type == SamplingType.BEAM:\n            sample_results = _beam_search_sample(seq_groups,\n                                                 beam_search_logprobs)\n        sample_results_dict.update(zip(seq_group_id, sample_results))\n\n    sample_results = [\n        sample_results_dict.get(i, ([], []))\n        for i in range(len(sampling_metadata.seq_groups))\n    ]\n    return sample_results\n\n\ndef _sample(\n    probs: torch.Tensor, logprobs: torch.Tensor,\n    sampling_metadata: SamplingMetadata, sampling_tensors: SamplingTensors,\n    include_gpu_probs_tensor: bool, modify_greedy_probs: bool\n) -> Tuple[SampleResultType, Optional[torch.Tensor]]:\n    \"\"\"\n    Args:\n        probs: (num_query_tokens_in_batch, num_vocab)\n        logprobs: (num_query_tokens_in_batch, num_vocab)\n        sampling_metadata: The metadata for a batch for sampling.\n        sampling_tensors: Tensors that include sampling related metadata.\n\n    Returns:\n        (next_token_ids, parent_seq_ids) for each seq group in a batch.\n            If sampling is skipped, it returns ([], [])\n        sampled_token_ids_tensor: A tensor of sampled token ids.\n    \"\"\"\n    return _sample_with_torch(\n        probs,\n        logprobs,\n        sampling_metadata,\n        include_gpu_probs_tensor=include_gpu_probs_tensor,\n        modify_greedy_probs=modify_greedy_probs,\n    )\n\n    # TODO: Enable once Triton kernel & associated code is faster.\n    # return _sample_with_triton_kernel(probs, logprobs, sampling_metadata,\n    #                                   sampling_tensors)\n\n\ndef _get_ranks(x: torch.Tensor, indices: torch.Tensor) -> torch.Tensor:\n    \"\"\"\n    This function calculates the ranks of the chosen tokens in a logprob tensor.\n\n    Args:\n        x (torch.Tensor): 2D logprob tensor of shape (N, M)\n                        where N is the no. of tokens and M is the vocab dim.\n        indices (torch.Tensor): List of chosen token indices.\n\n    Returns:\n        torch.Tensor: 1D tensor of shape (N,) where N is the no. of tokens.\n                    Each element in the returned tensor represents the rank \n                    of the chosen token in the input logprob tensor.\n    \"\"\"\n    vals = x[torch.arange(0, len(x), device=x.device, dtype=indices.dtype),\n             indices]\n    return (x > vals[:, None]).long().sum(1).add_(1)\n\n\ndef _get_logprobs(\n    logprobs: torch.Tensor,\n    sampling_metadata: SamplingMetadata,\n    sample_results: SampleResultType,\n) -> Tuple[List[Optional[PromptLogprobs]], List[SampleLogprobs]]:\n    \"\"\"Return sample lobprobs and prompt logprobs.\n\n    The logic consists of 3 parts.\n    - Select indices to compute logprob from, ranks of token ids, and\n        the top k token ids from logprobs.\n    - Compute prompt logprobs if required.\n    - Compute sample logprobs if required.\n\n    Args:\n        logprobs: (num_query_tokens_across_batch, num_vocab). Each query token's\n            logprob per vocab. Sequence groups' query tokens are batched in a\n            single flattened tensor. For example, assuming there are N\n            seq groups, it is sorted by prefill tokens for seq_group_1 (if\n            prompt logprob is enabled), decode tokens for seq_group_1 (if\n            sampling is required), prefill tokens for seq_group_2, ...\n        sampling_metadata: The sampling metadata.\n        sample_results: (num_seq_groups) The tuple of (next_token_ids,\n            parent_ids) for each sequence group. When beam search is enabled,\n            sample_results can contain different number of seq_ids from\n            sampling_metadata.seq_groups. It is because beam search creates\n            2 * BEAM_WIDTH number of samples (whereas there are only up to\n            BEAM_WIDTH number of seq_ids).\n\n    Returns:\n        A tuple of prompt and sample logprobs per sequence group in a batch.\n    \"\"\"\n    # The index of query token to calculate logprobs. It includes both\n    # prompt and sample logprob indices.\n    query_indices: List[int] = []\n    # The next token ids to get the logprob value from.\n    next_token_ids: List[int] = []\n    # The largest requested number of logprobs. We find logprobs as many as the\n    # largest num logprobs in this API.\n    largest_num_logprobs = 1\n\n    # Select indices to compute logprob from, ranks of token ids, and the top\n    # k token ids from logprobs.\n    for (seq_group, sample_result) in zip(sampling_metadata.seq_groups,\n                                          sample_results):\n        sampling_params = seq_group.sampling_params\n\n        # Update indices and tokens for prompt logprobs.\n        if (seq_group.is_prompt\n                and sampling_params.prompt_logprobs is not None):\n            largest_num_logprobs = max(largest_num_logprobs,\n                                       sampling_params.prompt_logprobs)\n            next_prompt_tokens = _get_next_prompt_tokens(seq_group)\n            query_indices.extend(seq_group.prompt_logprob_indices)\n            next_token_ids.extend(next_prompt_tokens)\n\n        # Update indices and next tokenes for sample logprob.\n        if seq_group.do_sample:\n            token_ids, parent_seq_ids = sample_result\n            # NOTE: We cannot directly use sample_indices because\n            # sample_indices only contain parent seq_ids of a previous step.\n            # The current step may have different number of seq_ids, and\n            # we can obtain it from `sample_result[1]`.\n            query_idx = seq_group.sample_indices[0]\n            query_indices.extend(\n                [query_idx + parent_id for parent_id in parent_seq_ids])\n            next_token_ids.extend(token_ids)\n\n            if sampling_params.logprobs is not None:\n                largest_num_logprobs = max(largest_num_logprobs,\n                                           sampling_params.logprobs)\n\n        assert len(next_token_ids) == len(query_indices)\n\n    if len(query_indices) == 0:\n        empty_sampled_logprob: SampleLogprobs = []\n        empty_prompt_logprob: Optional[PromptLogprobs] = None\n        return [empty_prompt_logprob], [empty_sampled_logprob]\n\n    query_indices_gpu = torch.tensor(query_indices, device=logprobs.device)\n    next_token_ids_gpu = torch.tensor(next_token_ids, device=logprobs.device)\n\n    # (num_selected_query_tokens, num_logprobs). Note that query_indices can\n    # contain duplicates if beam search is enabled.\n    selected_logprobs = logprobs[[\n        query_indices_gpu,\n        next_token_ids_gpu,\n    ]]\n    ranks = _get_ranks(\n        logprobs[query_indices_gpu],\n        next_token_ids_gpu,\n    )\n    assert selected_logprobs.shape[0] == ranks.shape[0]\n\n    # Logprobs of topk tokens for a batch of sequence groups.\n    # (num_query_tokens_across_batch).\n    if largest_num_logprobs > 0:\n        top_logprobs, top_token_ids = torch.topk(logprobs,\n                                                 largest_num_logprobs,\n                                                 dim=-1)\n        top_logprobs = top_logprobs.cpu()\n        top_token_ids = top_token_ids.cpu()\n    else:\n        top_logprobs, top_token_ids = None, None\n\n    selected_logprobs = selected_logprobs.cpu()\n    ranks = ranks.cpu()\n\n    # Find prompt/sample logprobs.\n    prompt_logprobs_per_seq_group: List[Optional[PromptLogprobs]] = []\n    sample_logprobs_per_seq_group: List[SampleLogprobs] = []\n    top_logprob_idx = 0\n    selected_logprobs_idx = 0\n\n    for seq_group, sample_result in zip(sampling_metadata.seq_groups,\n                                        sample_results):\n        (prompt_logprobs, top_logprob_idx,\n         selected_logprobs_idx) = _get_prompt_logprob_if_needed(\n             seq_group, selected_logprobs, ranks, top_token_ids, top_logprobs,\n             selected_logprobs_idx, top_logprob_idx)\n        prompt_logprobs_per_seq_group.append(prompt_logprobs)\n\n        (sampled_logprobs, top_logprob_idx,\n         selected_logprobs_idx) = _get_sampled_logprob_if_needed(\n             seq_group, sample_result, selected_logprobs, ranks, top_token_ids,\n             top_logprobs, selected_logprobs_idx, top_logprob_idx)\n        sample_logprobs_per_seq_group.append(sampled_logprobs)\n\n    return prompt_logprobs_per_seq_group, sample_logprobs_per_seq_group\n\n\ndef _get_prompt_logprob_if_needed(\n    seq_group: SequenceGroupToSample,\n    selected_logprobs: torch.Tensor,\n    ranks: torch.Tensor,\n    top_token_ids: torch.Tensor,\n    top_logprobs: torch.Tensor,\n    selected_logprobs_idx: int,\n    top_logprob_idx: int,\n):\n    \"\"\"Compute the prompt logprob from a sequence group if needed.\"\"\"\n    sampling_params = seq_group.sampling_params\n    is_prompt = seq_group.is_prompt\n\n    # Find prompt logprobs\n    prompt_logprobs: Optional[PromptLogprobs] = None\n    if (is_prompt and sampling_params.prompt_logprobs is not None):\n        prompt_logprobs = []\n        num_logprobs = sampling_params.prompt_logprobs\n        next_prompt_tokens = _get_next_prompt_tokens(seq_group)\n        for token_id in next_prompt_tokens:\n            # Calculate the prompt logprob of the real prompt tokens.\n            # Use tuple here for performance (to use to_list()).\n            # {token_id: (logprob, rank_from_vocab)}\n            prompt_logprobs_dict: Dict[int, Tuple[float, int]] = {\n                token_id: (selected_logprobs[selected_logprobs_idx].item(),\n                           ranks[selected_logprobs_idx].item())\n            }\n\n            # Add top K prompt logprobs along with its rank.\n            if num_logprobs > 0:\n                prompt_logprobs_dict.update(\n                    zip(\n                        top_token_ids[top_logprob_idx, :num_logprobs].tolist(),\n                        zip(\n                            top_logprobs[\n                                top_logprob_idx, :num_logprobs].tolist(),\n                            # This is ranks. Since top_logprob is sorted,\n                            # we can just use a range here.\n                            range(1, num_logprobs + 1))))\n            prompt_logprobs.append({\n                token_id: Logprob(*logprob_and_rank)\n                for token_id, logprob_and_rank in prompt_logprobs_dict.items()\n            })\n            # + 1 to go to the next prompt token.\n            top_logprob_idx += 1\n            selected_logprobs_idx += 1\n    return prompt_logprobs, top_logprob_idx, selected_logprobs_idx\n\n\ndef _get_sampled_logprob_if_needed(\n    seq_group: SequenceGroupToSample,\n    sample_result: Tuple[List[int], List[int]],\n    selected_logprobs: torch.Tensor,\n    ranks: torch.Tensor,\n    top_token_ids: torch.Tensor,\n    top_logprobs: torch.Tensor,\n    selected_logprobs_idx: int,\n    top_logprob_idx: int,\n):\n    \"\"\"Compute the sample logprob if needed.\"\"\"\n    seq_ids = seq_group.seq_ids\n    num_logprobs = seq_group.sampling_params.logprobs\n    if num_logprobs is None:\n        num_logprobs = 0\n    sampled_logprobs: SampleLogprobs = []\n    next_token_ids, parent_seq_ids = sample_result\n\n    if seq_group.do_sample:\n        assert len(next_token_ids) > 0\n        for (next_token_id, parent_id) in zip(next_token_ids, parent_seq_ids):\n            # Calculate the sample logprob of the real sampled tokens.\n            # Use tuple here for performance (to use to_list()).\n            # token_id: (logprob, rank_from_vocab)\n            sampled_logprobs_dict: Dict[int, Tuple[float, int]] = {\n                next_token_id:\n                (selected_logprobs[selected_logprobs_idx].item(),\n                 ranks[selected_logprobs_idx].item())\n            }\n            # +1 to go to the next sampled token. Note that\n            # selected_logprobs can contain duplicates unlike top_logprobs\n            # when beam search is enabled.\n            selected_logprobs_idx += 1\n\n            # Second, add top K logprobs along with its rank.\n            if num_logprobs >= 0:\n                sampled_logprobs_dict.update(\n                    zip(\n                        top_token_ids[top_logprob_idx +\n                                      parent_id, :num_logprobs].tolist(),\n                        zip(\n                            top_logprobs[top_logprob_idx +\n                                         parent_id, :num_logprobs].tolist(),\n                            # This is rank. Since top_logprob is sorted, we\n                            # can just use a range here.\n                            range(1, num_logprobs + 1))))\n            sampled_logprobs.append({\n                token_id: Logprob(*logprob_and_rank)\n                for token_id, logprob_and_rank in\n                sampled_logprobs_dict.items()\n            })\n        # There are len(seq_ids) number of sampled tokens for the current\n        # sequence group in top_logprobs. Jump to the next seq_group.\n        top_logprob_idx += len(seq_ids)\n    return sampled_logprobs, top_logprob_idx, selected_logprobs_idx\n\n\ndef _modify_greedy_probs_inplace(logprobs: torch.Tensor, probs: torch.Tensor,\n                                 sample_indices: torch.Tensor,\n                                 greedy_samples: torch.Tensor) -> None:\n    \"\"\"Modify the probability distributions of the greedily-sampled tokens such\n    that each sampled token has a \"probability\" of 1.0. This is required by\n    speculative decoding, which depends on the sampling method being encoded\n    within the probability distribution for correctness.\n\n    # Why do we only need to do this for greedy sampling?\n\n    vLLM's sampler performs the following steps for greedy or multinomial\n    (random) sampling:\n        1. Get logits from model.\n        2. Modify logits according to per-sequence sampling parameters.\n            - Multiply by temperature, top-k and top-p masking, penalize tokens\n                according to their frequency, etc.\n        3. Sample a token.\n            - Random sampling simply samples from the modified probability\n                distribution.\n            - Greedy sampling performs `argmax` to obtain the token with the\n                highest likelihood.\n    \n    Ignoring greedy sampling for a moment, we find that the computed probability\n    distribution has the following property: we can sample from it independently\n    and find that the token sampled by the Sampler has a frequency corresponding\n    to how often we see it in our sampling. In other words, for tokens sampled\n    with vLLM's random SamplingType, the computed probability distribution\n    encodes the sampling methodology completely.\n\n    Greedy sampling does not normally have this property. vLLM modifies logits\n    according to sampling params, then performs `argmax`, then returns the\n    sampled token and the computed probability distribution. If we sample from\n    the distribution, we'll find the likelihood of the greedily-sampled token\n    is not always 1.0.\n\n    Since lossless speculative decoding requires that the sampling methodology\n    be encoded within the probability distribution, we are motivated to modify\n    the probability distribution such that the sampled token has probability 1\n    when speculative decoding is used.\n\n    NOTE: Alternatively, we could use an extremely low temperature to achieve\n    greedy sampling using multinomial computation and unite the codepaths. This\n    has implications on the overall design of the sampler, e.g. how to record\n    accurate logprobs for the user, so this improvement is deferred to later.\n    \"\"\"\n    # NOTE: logprobs are not modified so they can be returned to the user.\n    probs[sample_indices, :] = 0\n    probs[sample_indices, greedy_samples] = 1.0\n\n\ndef _build_sampler_output(\n    sample_results: SampleResultType,\n    sampling_metadata: SamplingMetadata,\n    prompt_logprobs: List[Optional[PromptLogprobs]],\n    sample_logprobs: List[SampleLogprobs],\n    on_device_tensors: Optional[Tuple[torch.Tensor, torch.Tensor,\n                                      torch.Tensor]],\n) -> SamplerOutput:\n    \"\"\"Construct Python objects with the output of sampling.\n\n    Args:\n        on_device_tensors: Tuple containing on-device tensors with the\n            probabilities used in sampling and the sampled token ids. This\n            allows post-processing without copies to CPU/serialization, e.g. in\n            speculative decoding rejection sampling.\n    \"\"\"\n\n    sampler_output = []\n    for (seq_group, sample_result, group_prompt_logprobs,\n         group_sample_logprobs) in zip(sampling_metadata.seq_groups,\n                                       sample_results, prompt_logprobs,\n                                       sample_logprobs):\n        seq_ids = seq_group.seq_ids\n        next_token_ids, parent_ids = sample_result\n        seq_outputs = []\n        for parent_id, next_token_id, logprobs in zip(parent_ids,\n                                                      next_token_ids,\n                                                      group_sample_logprobs):\n            seq_outputs.append(\n                SequenceOutput(seq_ids[parent_id], next_token_id, logprobs))\n        sampler_output.append(\n            SequenceGroupOutput(seq_outputs, group_prompt_logprobs))\n\n    # If not specified, store None values in SamplerOutput.\n    if on_device_tensors is not None:\n        (sampled_token_probs, logprobs_tensor,\n         sampled_token_ids) = on_device_tensors\n    else:\n        sampled_token_probs, logprobs_tensor, sampled_token_ids = (None, None,\n                                                                   None)\n\n    return SamplerOutput(\n        outputs=sampler_output,\n        sampled_token_probs=sampled_token_probs,\n        sampled_token_ids=sampled_token_ids,\n        logprobs=logprobs_tensor,\n    )\n\n\ndef _get_next_prompt_tokens(seq_group: SequenceGroupToSample) -> List[int]:\n    \"\"\"Get a list of next prompt tokens to compute logprob from a\n        given sequence group.\n\n    It is used to compute prompt logprob. Imagine you have logprob for each\n    query token. Query token needs to know the next prompt token id to compute\n    prompt logprob. This is a helper to obtain next prompt token ids.\n\n    This API has to be used only when the caller knows seq_group is in prefill\n    stage.\n\n    Returns:\n        A list of next prompt tokens to compute logprob.\n    \"\"\"\n    assert seq_group.is_prompt, (\n        \"Caller should ensure the sequence group is in a prefill stage.\")\n    seq_ids = seq_group.seq_ids\n    query_len = seq_group.query_len\n    assert query_len is not None\n    # prompt has only 1 seq id.\n    assert len(seq_ids) == 1\n    seq_data = seq_group.seq_data[seq_ids[0]]\n    computed_len = seq_data.get_num_computed_tokens()\n    prompt_tokens = seq_data.prompt_token_ids\n    # +1 because we are looking for a next prompt token.\n    next_token_index_start = computed_len + 1\n    next_token_index_end = min(computed_len + query_len + 1,\n                               len(prompt_tokens))\n    next_prompt_tokens = prompt_tokens[\n        next_token_index_start:next_token_index_end]\n    return next_prompt_tokens\n",
      "diff": "diff --git a/vllm/model_executor/layers/sampler.py b/vllm/model_executor/layers/sampler.py\nindex 1f19d2053..e52e350d2 100644\n--- a/vllm/model_executor/layers/sampler.py\n+++ b/vllm/model_executor/layers/sampler.py\n@@ -782,13 +782,14 @@ def _get_logprobs(\n         top_logprobs, top_token_ids = torch.topk(logprobs,\n                                                  largest_num_logprobs,\n                                                  dim=-1)\n-        top_logprobs = top_logprobs.cpu()\n-        top_token_ids = top_token_ids.cpu()\n     else:\n         top_logprobs, top_token_ids = None, None\n \n-    selected_logprobs = selected_logprobs.cpu()\n-    ranks = ranks.cpu()\n+    selected_logprobs = selected_logprobs.to('cpu')\n+    ranks = ranks.to('cpu')\n+    if top_logprobs is not None and top_token_ids is not None:\n+        top_logprobs = top_logprobs.to('cpu')\n+        top_token_ids = top_token_ids.to('cpu')\n \n     # Find prompt/sample logprobs.\n     prompt_logprobs_per_seq_group: List[Optional[PromptLogprobs]] = []\n@@ -828,37 +829,48 @@ def _get_prompt_logprob_if_needed(\n \n     # Find prompt logprobs\n     prompt_logprobs: Optional[PromptLogprobs] = None\n-    if (is_prompt and sampling_params.prompt_logprobs is not None):\n+    if is_prompt and sampling_params.prompt_logprobs is not None:\n         prompt_logprobs = []\n         num_logprobs = sampling_params.prompt_logprobs\n         next_prompt_tokens = _get_next_prompt_tokens(seq_group)\n-        for token_id in next_prompt_tokens:\n+        # Pre-select indexes and create a list. It is faster than calling .item\n+        # repetitively.\n+        selected_logprob_items = selected_logprobs[\n+            selected_logprobs_idx:selected_logprobs_idx +\n+            len(next_prompt_tokens)].tolist()\n+        rank_items = ranks[selected_logprobs_idx:selected_logprobs_idx +\n+                           len(next_prompt_tokens)].tolist()\n+\n+        for idx, token_id in enumerate(next_prompt_tokens):\n             # Calculate the prompt logprob of the real prompt tokens.\n-            # Use tuple here for performance (to use to_list()).\n             # {token_id: (logprob, rank_from_vocab)}\n             prompt_logprobs_dict: Dict[int, Tuple[float, int]] = {\n-                token_id: (selected_logprobs[selected_logprobs_idx].item(),\n-                           ranks[selected_logprobs_idx].item())\n+                token_id: (selected_logprob_items[idx], rank_items[idx])\n             }\n \n             # Add top K prompt logprobs along with its rank.\n             if num_logprobs > 0:\n-                prompt_logprobs_dict.update(\n-                    zip(\n-                        top_token_ids[top_logprob_idx, :num_logprobs].tolist(),\n-                        zip(\n-                            top_logprobs[\n-                                top_logprob_idx, :num_logprobs].tolist(),\n-                            # This is ranks. Since top_logprob is sorted,\n-                            # we can just use a range here.\n-                            range(1, num_logprobs + 1))))\n+                top_ids = top_token_ids[\n+                    top_logprob_idx, :num_logprobs].tolist()\n+                top_probs = top_logprobs[\n+                    top_logprob_idx, :num_logprobs].tolist()\n+                # Top K is already sorted by rank, so we can use 1 ~\n+                # num_logprobs + 1 for rank.\n+                top_ranks = range(1, num_logprobs + 1)\n+                prompt_logprobs_dict.update({\n+                    top_id: (top_prob, rank)\n+                    for top_id, top_prob, rank in zip(top_ids, top_probs,\n+                                                      top_ranks)\n+                })\n             prompt_logprobs.append({\n                 token_id: Logprob(*logprob_and_rank)\n                 for token_id, logprob_and_rank in prompt_logprobs_dict.items()\n             })\n             # + 1 to go to the next prompt token.\n             top_logprob_idx += 1\n-            selected_logprobs_idx += 1\n+\n+        # + len(next_prompt_tokens) to go to the next prompt.\n+        selected_logprobs_idx += len(next_prompt_tokens)\n     return prompt_logprobs, top_logprob_idx, selected_logprobs_idx\n \n \n@@ -874,47 +886,54 @@ def _get_sampled_logprob_if_needed(\n ):\n     \"\"\"Compute the sample logprob if needed.\"\"\"\n     seq_ids = seq_group.seq_ids\n-    num_logprobs = seq_group.sampling_params.logprobs\n-    if num_logprobs is None:\n-        num_logprobs = 0\n+    num_logprobs = seq_group.sampling_params.logprobs or 0\n     sampled_logprobs: SampleLogprobs = []\n     next_token_ids, parent_seq_ids = sample_result\n \n     if seq_group.do_sample:\n         assert len(next_token_ids) > 0\n-        for (next_token_id, parent_id) in zip(next_token_ids, parent_seq_ids):\n-            # Calculate the sample logprob of the real sampled tokens.\n-            # Use tuple here for performance (to use to_list()).\n-            # token_id: (logprob, rank_from_vocab)\n-            sampled_logprobs_dict: Dict[int, Tuple[float, int]] = {\n-                next_token_id:\n-                (selected_logprobs[selected_logprobs_idx].item(),\n-                 ranks[selected_logprobs_idx].item())\n+        # Pre-select items from tensor. tolist() is faster than repetitive\n+        # `.item()` calls.\n+        selected_logprob_items = selected_logprobs[\n+            selected_logprobs_idx:selected_logprobs_idx +\n+            len(next_token_ids)].tolist()\n+        rank_items = ranks[selected_logprobs_idx:selected_logprobs_idx +\n+                           len(next_token_ids)].tolist()\n+        for idx, (next_token_id,\n+                  parent_id) in enumerate(zip(next_token_ids, parent_seq_ids)):\n+            # Get the logprob of a sampled token.\n+            sampled_logprobs_dict = {\n+                next_token_id: (selected_logprob_items[idx], rank_items[idx])\n             }\n-            # +1 to go to the next sampled token. Note that\n-            # selected_logprobs can contain duplicates unlike top_logprobs\n-            # when beam search is enabled.\n-            selected_logprobs_idx += 1\n-\n-            # Second, add top K logprobs along with its rank.\n-            if num_logprobs >= 0:\n-                sampled_logprobs_dict.update(\n-                    zip(\n-                        top_token_ids[top_logprob_idx +\n-                                      parent_id, :num_logprobs].tolist(),\n-                        zip(\n-                            top_logprobs[top_logprob_idx +\n-                                         parent_id, :num_logprobs].tolist(),\n-                            # This is rank. Since top_logprob is sorted, we\n-                            # can just use a range here.\n-                            range(1, num_logprobs + 1))))\n+            # Get top K logprobs.\n+            if num_logprobs > 0:\n+                top_ids = top_token_ids[top_logprob_idx +\n+                                        parent_id, :num_logprobs].tolist()\n+                top_probs = top_logprobs[top_logprob_idx +\n+                                         parent_id, :num_logprobs].tolist()\n+                # Top K is already sorted by rank, so we can use 1 ~\n+                # num_logprobs + 1 for rank.\n+                top_ranks = range(1, num_logprobs + 1)\n+                sampled_logprobs_dict.update({\n+                    top_id: (top_prob, rank)\n+                    for top_id, top_prob, rank in zip(top_ids, top_probs,\n+                                                      top_ranks)\n+                })\n+\n             sampled_logprobs.append({\n                 token_id: Logprob(*logprob_and_rank)\n                 for token_id, logprob_and_rank in\n                 sampled_logprobs_dict.items()\n             })\n-        # There are len(seq_ids) number of sampled tokens for the current\n-        # sequence group in top_logprobs. Jump to the next seq_group.\n+\n+        # NOTE: This part of code is not intuitive. `selected_logprobs` include\n+        # logprobs for the current step, which has len(next_token_ids) tokens\n+        # per sequence group. `logprobs` includes logprobs from the previous\n+        # steps, which has len(seq_ids) tokens per sequence group.\n+\n+        # Iterate to the next sequence group in a batch.\n+        selected_logprobs_idx += len(next_token_ids)\n+        # Iterate to the next sequence group in a batch.\n         top_logprob_idx += len(seq_ids)\n     return sampled_logprobs, top_logprob_idx, selected_logprobs_idx",
      "change_type": "modified",
      "lines_added": 69,
      "lines_removed": 50
    }
  ],
  "affected_apis": [
    "LLM.generate"
  ],
  "summary": {
    "total_files": 1,
    "files_added": 0,
    "files_deleted": 0,
    "files_modified": 1
  },
  "csv_metadata": {
    "category": "model-based",
    "json_has_tests": "FALSE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "Yes (test_sampler)",
    "is_benchmark_actually_there": "",
    "sample_clues": "none, sampler"
  }
}