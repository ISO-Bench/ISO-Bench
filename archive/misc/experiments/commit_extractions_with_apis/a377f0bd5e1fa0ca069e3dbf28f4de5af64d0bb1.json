{
  "commit_hash": "a377f0bd5e1fa0ca069e3dbf28f4de5af64d0bb1",
  "parent_hash": "e9d3aa04f6e55e2bb540f0810da97ddd0deebb13",
  "message": "[Misc]: optimize eager mode host time (#4196)\n\nCo-authored-by: xuhao <xuhao@cambricon.com>",
  "author": "functionxu123 <1229853312@qq.com>",
  "date": "2024-05-31 13:14:50 +0800",
  "files_changed": [
    {
      "file_path": "vllm/utils.py",
      "old_content": "import asyncio\nimport datetime\nimport enum\nimport gc\nimport os\nimport socket\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport uuid\nimport warnings\nfrom collections import defaultdict\nfrom functools import lru_cache, partial, wraps\nfrom platform import uname\nfrom typing import (Any, AsyncIterator, Awaitable, Callable, Dict, Generic,\n                    Hashable, List, Optional, OrderedDict, Tuple, TypeVar,\n                    Union)\n\nimport psutil\nimport torch\n\nimport vllm.envs as envs\nfrom vllm.logger import enable_trace_function_call, init_logger\n\nT = TypeVar(\"T\")\nlogger = init_logger(__name__)\n\nSTR_DTYPE_TO_TORCH_DTYPE = {\n    \"half\": torch.half,\n    \"bfloat16\": torch.bfloat16,\n    \"float\": torch.float,\n    \"fp8\": torch.uint8,\n    \"fp8_e4m3\": torch.uint8,\n    \"fp8_e5m2\": torch.uint8,\n}\n\n\nclass Device(enum.Enum):\n    GPU = enum.auto()\n    CPU = enum.auto()\n\n\nclass Counter:\n\n    def __init__(self, start: int = 0) -> None:\n        self.counter = start\n\n    def __next__(self) -> int:\n        i = self.counter\n        self.counter += 1\n        return i\n\n    def reset(self) -> None:\n        self.counter = 0\n\n\nclass LRUCache(Generic[T]):\n\n    def __init__(self, capacity: int):\n        self.cache: OrderedDict[Hashable, T] = OrderedDict()\n        self.capacity = capacity\n\n    def __contains__(self, key: Hashable) -> bool:\n        return key in self.cache\n\n    def __len__(self) -> int:\n        return len(self.cache)\n\n    def __getitem__(self, key: Hashable) -> Optional[T]:\n        return self.get(key)\n\n    def __setitem__(self, key: Hashable, value: T) -> None:\n        self.put(key, value)\n\n    def __delitem__(self, key: Hashable) -> None:\n        self.pop(key)\n\n    def touch(self, key: Hashable) -> None:\n        self.cache.move_to_end(key)\n\n    def get(self,\n            key: Hashable,\n            default_value: Optional[T] = None) -> Optional[T]:\n        if key in self.cache:\n            value: Optional[T] = self.cache[key]\n            self.cache.move_to_end(key)\n        else:\n            value = default_value\n        return value\n\n    def put(self, key: Hashable, value: T) -> None:\n        self.cache[key] = value\n        self.cache.move_to_end(key)\n        self._remove_old_if_needed()\n\n    def _on_remove(self, key: Hashable, value: Optional[T]):\n        pass\n\n    def remove_oldest(self):\n        if not self.cache:\n            return\n        key, value = self.cache.popitem(last=False)\n        self._on_remove(key, value)\n\n    def _remove_old_if_needed(self) -> None:\n        while len(self.cache) > self.capacity:\n            self.remove_oldest()\n\n    def pop(self,\n            key: Hashable,\n            default_value: Optional[T] = None) -> Optional[T]:\n        run_on_remove = key in self.cache\n        value: Optional[T] = self.cache.pop(key, default_value)\n        if run_on_remove:\n            self._on_remove(key, value)\n        return value\n\n    def clear(self):\n        while len(self.cache) > 0:\n            self.remove_oldest()\n        self.cache.clear()\n\n\ndef is_hip() -> bool:\n    return torch.version.hip is not None\n\n\n@lru_cache(maxsize=None)\ndef is_cpu() -> bool:\n    from importlib.metadata import PackageNotFoundError, version\n    try:\n        return \"cpu\" in version(\"vllm\")\n    except PackageNotFoundError:\n        return False\n\n\n@lru_cache(maxsize=None)\ndef is_neuron() -> bool:\n    try:\n        import transformers_neuronx\n    except ImportError:\n        transformers_neuronx = None\n    return transformers_neuronx is not None\n\n\n@lru_cache(maxsize=None)\ndef get_max_shared_memory_bytes(gpu: int = 0) -> int:\n    \"\"\"Returns the maximum shared memory per thread block in bytes.\"\"\"\n    # NOTE: This import statement should be executed lazily since\n    # the Neuron-X backend does not have the `cuda_utils` module.\n    from vllm._C import cuda_utils\n\n    max_shared_mem = (\n        cuda_utils.get_max_shared_memory_per_block_device_attribute(gpu))\n    # value 0 will cause MAX_SEQ_LEN become negative and test_attention.py\n    # will fail\n    assert max_shared_mem > 0, \"max_shared_mem can not be zero\"\n    return int(max_shared_mem)\n\n\ndef get_cpu_memory() -> int:\n    \"\"\"Returns the total CPU memory of the node in bytes.\"\"\"\n    return psutil.virtual_memory().total\n\n\ndef random_uuid() -> str:\n    return str(uuid.uuid4().hex)\n\n\n@lru_cache(maxsize=None)\ndef get_vllm_instance_id():\n    \"\"\"\n    If the environment variable VLLM_INSTANCE_ID is set, return it.\n    Otherwise, return a random UUID.\n    Instance id represents an instance of the VLLM. All processes in the same\n    instance should have the same instance id.\n    \"\"\"\n    return envs.VLLM_INSTANCE_ID or f\"vllm-instance-{random_uuid()}\"\n\n\n@lru_cache(maxsize=None)\ndef in_wsl() -> bool:\n    # Reference: https://github.com/microsoft/WSL/issues/4071\n    return \"microsoft\" in \" \".join(uname()).lower()\n\n\ndef make_async(func: Callable[..., T]) -> Callable[..., Awaitable[T]]:\n    \"\"\"Take a blocking function, and run it on in an executor thread.\n\n    This function prevents the blocking function from blocking the\n    asyncio event loop.\n    The code in this function needs to be thread safe.\n    \"\"\"\n\n    def _async_wrapper(*args, **kwargs) -> asyncio.Future:\n        loop = asyncio.get_event_loop()\n        p_func = partial(func, *args, **kwargs)\n        return loop.run_in_executor(executor=None, func=p_func)\n\n    return _async_wrapper\n\n\ndef merge_async_iterators(\n        *iterators: AsyncIterator[T]) -> AsyncIterator[Tuple[int, T]]:\n    \"\"\"Merge multiple asynchronous iterators into a single iterator.\n\n    This method handle the case where some iterators finish before others.\n    When it yields, it yields a tuple (i, item) where i is the index of the\n    iterator that yields the item.\n    \"\"\"\n    queue: asyncio.Queue[Union[Tuple[int, T], Exception]] = asyncio.Queue()\n\n    finished = [False] * len(iterators)\n\n    async def producer(i: int, iterator: AsyncIterator[T]):\n        try:\n            async for item in iterator:\n                await queue.put((i, item))\n        except Exception as e:\n            await queue.put(e)\n        finished[i] = True\n\n    _tasks = [\n        asyncio.create_task(producer(i, iterator))\n        for i, iterator in enumerate(iterators)\n    ]\n\n    async def consumer():\n        try:\n            while not all(finished) or not queue.empty():\n                item = await queue.get()\n                if isinstance(item, Exception):\n                    raise item\n                yield item\n        except (Exception, asyncio.CancelledError) as e:\n            for task in _tasks:\n                if sys.version_info >= (3, 9):\n                    # msg parameter only supported in Python 3.9+\n                    task.cancel(e)\n                else:\n                    task.cancel()\n            raise e\n        await asyncio.gather(*_tasks)\n\n    return consumer()\n\n\ndef get_ip() -> str:\n    host_ip = envs.VLLM_HOST_IP\n    if host_ip:\n        return host_ip\n\n    # IP is not set, try to get it from the network interface\n\n    # try ipv4\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    try:\n        s.connect((\"8.8.8.8\", 80))  # Doesn't need to be reachable\n        return s.getsockname()[0]\n    except Exception:\n        pass\n\n    # try ipv6\n    try:\n        s = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n        # Google's public DNS server, see\n        # https://developers.google.com/speed/public-dns/docs/using#addresses\n        s.connect((\"2001:4860:4860::8888\", 80))  # Doesn't need to be reachable\n        return s.getsockname()[0]\n    except Exception:\n        pass\n\n    warnings.warn(\n        \"Failed to get the IP address, using 0.0.0.0 by default.\"\n        \"The value can be set by the environment variable\"\n        \" VLLM_HOST_IP or HOST_IP.\",\n        stacklevel=2)\n    return \"0.0.0.0\"\n\n\ndef get_distributed_init_method(ip: str, port: int) -> str:\n    # Brackets are not permitted in ipv4 addresses,\n    # see https://github.com/python/cpython/issues/103848\n    return f\"tcp://[{ip}]:{port}\" if \":\" in ip else f\"tcp://{ip}:{port}\"\n\n\ndef get_open_port() -> int:\n    port = envs.VLLM_PORT\n    if port is not None:\n        return port\n    # try ipv4\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.bind((\"\", 0))\n            return s.getsockname()[1]\n    except OSError:\n        # try ipv6\n        with socket.socket(socket.AF_INET6, socket.SOCK_STREAM) as s:\n            s.bind((\"\", 0))\n            return s.getsockname()[1]\n\n\ndef update_environment_variables(envs: Dict[str, str]):\n    for k, v in envs.items():\n        if k in os.environ and os.environ[k] != v:\n            logger.warning(\n                \"Overwriting environment variable %s \"\n                \"from '%s' to '%s'\", k, os.environ[k], v)\n        os.environ[k] = v\n\n\ndef chunk_list(lst, chunk_size):\n    \"\"\"Yield successive chunk_size chunks from lst.\"\"\"\n    return [lst[i:i + chunk_size] for i in range(0, len(lst), chunk_size)]\n\n\ndef cdiv(a: int, b: int) -> int:\n    \"\"\"Ceiling division.\"\"\"\n    return -(a // -b)\n\n\ndef _generate_random_fp8(\n    tensor: torch.tensor,\n    low: float,\n    high: float,\n) -> None:\n    # NOTE(zhaoyang): Due to NaN and Inf representation for fp8 data type,\n    # it may occur Inf or NaN if we directly use torch.randint\n    # to generate random data for fp8 data.\n    # For example, s.11111.00 in fp8e5m2 format represents Inf.\n    #     | E4M3        | E5M2\n    #-----|-------------|-------------------\n    # Inf | N/A         | s.11111.00\n    # NaN | s.1111.111  | s.11111.{01,10,11}\n    from vllm import _custom_ops as ops\n    tensor_tmp = torch.empty_like(tensor, dtype=torch.float16)\n    tensor_tmp.uniform_(low, high)\n    ops.convert_fp8(tensor, tensor_tmp)\n    del tensor_tmp\n\n\ndef get_kv_cache_torch_dtype(\n        cache_dtype: Optional[Union[str, torch.dtype]],\n        model_dtype: Optional[Union[str, torch.dtype]] = None) -> torch.dtype:\n    if isinstance(cache_dtype, str):\n        if cache_dtype == \"auto\":\n            if isinstance(model_dtype, str):\n                torch_dtype = STR_DTYPE_TO_TORCH_DTYPE[model_dtype]\n            elif isinstance(model_dtype, torch.dtype):\n                torch_dtype = model_dtype\n            else:\n                raise ValueError(f\"Invalid model dtype: {model_dtype}\")\n        elif cache_dtype in [\"half\", \"bfloat16\", \"float\"]:\n            torch_dtype = STR_DTYPE_TO_TORCH_DTYPE[cache_dtype]\n        elif cache_dtype == \"fp8\":\n            torch_dtype = torch.uint8\n        else:\n            raise ValueError(f\"Invalid kv cache dtype: {cache_dtype}\")\n    elif isinstance(cache_dtype, torch.dtype):\n        torch_dtype = cache_dtype\n    else:\n        raise ValueError(f\"Invalid kv cache dtype: {cache_dtype}\")\n    return torch_dtype\n\n\ndef create_kv_caches_with_random_flash(\n    num_blocks: int,\n    block_size: int,\n    num_layers: int,\n    num_heads: int,\n    head_size: int,\n    cache_dtype: Optional[Union[str, torch.dtype]],\n    model_dtype: Optional[Union[str, torch.dtype]] = None,\n    seed: int = 0,\n    device: Optional[str] = \"cuda\",\n) -> Tuple[List[torch.Tensor], List[torch.Tensor]]:\n    assert cache_dtype != \"fp8\"\n    torch.random.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed(seed)\n\n    torch_dtype = get_kv_cache_torch_dtype(cache_dtype, model_dtype)\n    key_value_cache_shape = (num_blocks, 2, block_size, num_heads, head_size)\n    scale = head_size**-0.5\n    key_caches, value_caches = [], []\n    for _ in range(num_layers):\n        key_value_cache = torch.empty(size=key_value_cache_shape,\n                                      dtype=torch_dtype,\n                                      device=device)\n        key_value_cache.uniform_(-scale, scale)\n        key_caches.append(key_value_cache[:, 0])\n        value_caches.append(key_value_cache[:, 1])\n    return key_caches, value_caches\n\n\ndef create_kv_caches_with_random(\n    num_blocks: int,\n    block_size: int,\n    num_layers: int,\n    num_heads: int,\n    head_size: int,\n    cache_dtype: Optional[Union[str, torch.dtype]],\n    model_dtype: Optional[Union[str, torch.dtype]] = None,\n    seed: int = 0,\n    device: Optional[str] = \"cuda\",\n) -> Tuple[List[torch.Tensor], List[torch.Tensor]]:\n    torch.random.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed(seed)\n\n    torch_dtype = get_kv_cache_torch_dtype(cache_dtype, model_dtype)\n\n    scale = head_size**-0.5\n    x = 16 // torch.tensor([], dtype=torch_dtype).element_size()\n    key_cache_shape = (num_blocks, num_heads, head_size // x, block_size, x)\n    key_caches = []\n    for _ in range(num_layers):\n        key_cache = torch.empty(size=key_cache_shape,\n                                dtype=torch_dtype,\n                                device=device)\n        if cache_dtype in [\"auto\", \"half\", \"bfloat16\", \"float\"]:\n            key_cache.uniform_(-scale, scale)\n        elif cache_dtype == 'fp8':\n            _generate_random_fp8(key_cache, -scale, scale)\n        else:\n            raise ValueError(\n                f\"Does not support key cache of type {cache_dtype}\")\n        key_caches.append(key_cache)\n\n    value_cache_shape = (num_blocks, num_heads, head_size, block_size)\n    value_caches = []\n    for _ in range(num_layers):\n        value_cache = torch.empty(size=value_cache_shape,\n                                  dtype=torch_dtype,\n                                  device=device)\n        if cache_dtype in [\"auto\", \"half\", \"bfloat16\", \"float\"]:\n            value_cache.uniform_(-scale, scale)\n        elif cache_dtype == 'fp8':\n            _generate_random_fp8(value_cache, -scale, scale)\n        else:\n            raise ValueError(\n                f\"Does not support value cache of type {cache_dtype}\")\n        value_caches.append(value_cache)\n    return key_caches, value_caches\n\n\n@lru_cache\ndef print_warning_once(msg: str) -> None:\n    logger.warning(msg)\n\n\n@lru_cache(maxsize=None)\ndef is_pin_memory_available() -> bool:\n\n    if in_wsl():\n        # Pinning memory in WSL is not supported.\n        # https://docs.nvidia.com/cuda/wsl-user-guide/index.html#known-limitations-for-linux-cuda-applications\n        print_warning_once(\"Using 'pin_memory=False' as WSL is detected. \"\n                           \"This may slow down the performance.\")\n        return False\n    elif is_neuron():\n        print_warning_once(\"Pin memory is not supported on Neuron.\")\n        return False\n    elif is_cpu():\n        return False\n    return True\n\n\nclass CudaMemoryProfiler:\n\n    def __init__(self, device=None):\n        self.device = device\n\n    def current_memory_usage(self) -> float:\n        # Return the memory usage in bytes.\n        torch.cuda.reset_peak_memory_stats(self.device)\n        mem = torch.cuda.max_memory_allocated(self.device)\n        return mem\n\n    def __enter__(self):\n        self.initial_memory = self.current_memory_usage()\n        # This allows us to call methods of the context manager if needed\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.final_memory = self.current_memory_usage()\n        self.consumed_memory = self.final_memory - self.initial_memory\n\n        # Force garbage collection\n        gc.collect()\n\n\ndef str_to_int_tuple(s: str) -> Tuple[int, ...]:\n    \"\"\"Convert a string to a tuple of integers.\"\"\"\n    try:\n        return tuple(map(int, s.split(\",\")))\n    except ValueError as e:\n        raise ValueError(\n            \"String must be a series of integers separated by commas \"\n            f\"(e.g., 1, 2, 3). Given input: {s}\") from e\n\n\ndef pad_to_max_length(x: List[int], max_len: int, pad: int) -> List[int]:\n    assert len(x) <= max_len\n    return x + [pad] * (max_len - len(x))\n\n\ndef make_tensor_with_pad(\n    x: List[List[int]],\n    max_len: int,\n    pad: int,\n    dtype: torch.dtype,\n    device: Optional[Union[str, torch.device]],\n) -> torch.Tensor:\n    \"\"\"Make a padded tensor of a 2D inputs.\n\n    The padding is applied to the end of each inner list until it reaches\n    `max_len`.\n    \"\"\"\n    padded_x = [pad_to_max_length(x_i, max_len, pad) for x_i in x]\n    return torch.tensor(padded_x, dtype=dtype, device=device)\n\n\ndef async_tensor_h2d(\n    data: list,\n    dtype: torch.dtype,\n    target_device: Union[str, torch.device],\n    pin_memory: bool,\n) -> torch.Tensor:\n    \"\"\"Asynchronously create a tensor and copy it from host to device.\"\"\"\n    t = torch.tensor(data, dtype=dtype, pin_memory=pin_memory, device=\"cpu\")\n    return t.to(device=target_device, non_blocking=True)\n\n\ndef maybe_expand_dim(tensor: torch.Tensor,\n                     target_dims: int,\n                     size: int = 1) -> torch.Tensor:\n    \"\"\"Expand the tensor to the target_dims.\"\"\"\n    if tensor.ndim < target_dims:\n        tensor = tensor.view(-1, *([size] * (target_dims - tensor.ndim)))\n    return tensor\n\n\ndef merge_dicts(dict1: Dict[Any, List[Any]],\n                dict2: Dict[Any, List[Any]]) -> Dict[Any, List[Any]]:\n    \"\"\"Merge 2 dicts that have key -> List of items.\n\n    When a key conflicts, the values in dict1 is prioritized.\n    \"\"\"\n    merged_dict = defaultdict(list)\n\n    for key, value in dict1.items():\n        merged_dict[key].extend(value)\n\n    for key, value in dict2.items():\n        merged_dict[key].extend(value)\n\n    return dict(merged_dict)\n\n\ndef init_cached_hf_modules():\n    \"\"\"\n    Lazy initialization of the Hugging Face modules.\n    \"\"\"\n    from transformers.dynamic_module_utils import init_hf_modules\n    init_hf_modules()\n\n\n@lru_cache(maxsize=None)\ndef find_library(lib_name: str) -> str:\n    \"\"\"\n    Find the library file in the system.\n    `lib_name` is full filename, with both prefix and suffix.\n    This function resolves `lib_name` to the full path of the library.\n    \"\"\"\n    # Adapted from https://github.com/openai/triton/blob/main/third_party/nvidia/backend/driver.py#L19 # noqa\n    # According to https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard\n    # `/sbin/ldconfig` should exist in all Linux systems.\n    # `/sbin/ldconfig` searches the library in the system\n    libs = subprocess.check_output([\"/sbin/ldconfig\", \"-p\"]).decode()\n    # each line looks like the following:\n    # libcuda.so.1 (libc6,x86-64) => /lib/x86_64-linux-gnu/libcuda.so.1\n    locs = [line.split()[-1] for line in libs.splitlines() if lib_name in line]\n    # `LD_LIBRARY_PATH` searches the library in the user-defined paths\n    env_ld_library_path = envs.LD_LIBRARY_PATH\n    if not locs and env_ld_library_path:\n        locs = [\n            os.path.join(dir, lib_name)\n            for dir in env_ld_library_path.split(\":\")\n            if os.path.exists(os.path.join(dir, lib_name))\n        ]\n    if not locs:\n        raise ValueError(f\"Cannot find {lib_name} in the system.\")\n    return locs[0]\n\n\ndef find_nccl_library():\n    \"\"\"\n    We either use the library file specified by the `VLLM_NCCL_SO_PATH`\n    environment variable, or we find the library file brought by PyTorch.\n    After importing `torch`, `libnccl.so.2` or `librccl.so.1` can be\n    found by `ctypes` automatically.\n    \"\"\"\n    so_file = envs.VLLM_NCCL_SO_PATH\n\n    # manually load the nccl library\n    if so_file:\n        logger.info(\n            \"Found nccl from environment variable VLLM_NCCL_SO_PATH=%s\",\n            so_file)\n    else:\n        if torch.version.cuda is not None:\n            so_file = \"libnccl.so.2\"\n        elif torch.version.hip is not None:\n            so_file = \"librccl.so.1\"\n        else:\n            raise ValueError(\"NCCL only supports CUDA and ROCm backends.\")\n        logger.info(\"Found nccl from library %s\", so_file)\n    return so_file\n\n\ndef enable_trace_function_call_for_thread() -> None:\n    \"\"\"Set up function tracing for the current thread,\n    if enabled via the VLLM_TRACE_FUNCTION environment variable\n    \"\"\"\n\n    if envs.VLLM_TRACE_FUNCTION:\n        tmp_dir = tempfile.gettempdir()\n        filename = (f\"VLLM_TRACE_FUNCTION_for_process_{os.getpid()}\"\n                    f\"_thread_{threading.get_ident()}_\"\n                    f\"at_{datetime.datetime.now()}.log\").replace(\" \", \"_\")\n        log_path = os.path.join(tmp_dir, \"vllm\", get_vllm_instance_id(),\n                                filename)\n        os.makedirs(os.path.dirname(log_path), exist_ok=True)\n        enable_trace_function_call(log_path)\n\n\ndef identity(value: T) -> T:\n    return value\n\n\nF = TypeVar('F', bound=Callable[..., Any])\n\n\ndef deprecate_kwargs(\n        *kws: str,\n        is_deprecated: Union[bool, Callable[[], bool]] = True,\n        additional_message: Optional[str] = None) -> Callable[[F], F]:\n    deprecated_kws = set(kws)\n\n    if not callable(is_deprecated):\n        is_deprecated = partial(identity, is_deprecated)\n\n    def wrapper(fn: F) -> F:\n\n        @wraps(fn)\n        def inner(*args, **kwargs):\n            if is_deprecated():\n                deprecated_kwargs = kwargs.keys() & deprecated_kws\n                if deprecated_kwargs:\n                    msg = (\n                        f\"The keyword arguments {deprecated_kwargs} are \"\n                        \"deprecated and will be removed in a future update.\")\n                    if additional_message is not None:\n                        msg += f\" {additional_message}\"\n\n                    warnings.warn(\n                        DeprecationWarning(msg),\n                        stacklevel=3,  # The inner function takes up one level\n                    )\n\n            return fn(*args, **kwargs)\n\n        return inner  # type: ignore\n\n    return wrapper\n",
      "diff": "diff --git a/vllm/utils.py b/vllm/utils.py\nindex 26140e156..2781eceb7 100644\n--- a/vllm/utils.py\n+++ b/vllm/utils.py\n@@ -17,6 +17,7 @@ from typing import (Any, AsyncIterator, Awaitable, Callable, Dict, Generic,\n                     Hashable, List, Optional, OrderedDict, Tuple, TypeVar,\n                     Union)\n \n+import numpy as np\n import psutil\n import torch\n \n@@ -501,11 +502,6 @@ def str_to_int_tuple(s: str) -> Tuple[int, ...]:\n             f\"(e.g., 1, 2, 3). Given input: {s}\") from e\n \n \n-def pad_to_max_length(x: List[int], max_len: int, pad: int) -> List[int]:\n-    assert len(x) <= max_len\n-    return x + [pad] * (max_len - len(x))\n-\n-\n def make_tensor_with_pad(\n     x: List[List[int]],\n     max_len: int,\n@@ -518,7 +514,10 @@ def make_tensor_with_pad(\n     The padding is applied to the end of each inner list until it reaches\n     `max_len`.\n     \"\"\"\n-    padded_x = [pad_to_max_length(x_i, max_len, pad) for x_i in x]\n+    padded_x = np.zeros([len(x), max_len], dtype=np.int32) + pad\n+    for ind, blocktb in enumerate(x):\n+        assert len(blocktb) <= max_len\n+        padded_x[ind, :len(blocktb)] = blocktb\n     return torch.tensor(padded_x, dtype=dtype, device=device)",
      "change_type": "modified",
      "lines_added": 6,
      "lines_removed": 7
    }
  ],
  "affected_apis": [
    "vllm.utils.make_tensor_with_pad",
    "vllm.utils.pad_to_max_length"
  ],
  "summary": {
    "total_files": 1,
    "files_added": 0,
    "files_deleted": 0,
    "files_modified": 1
  },
  "csv_metadata": {
    "category": "miscellaneous",
    "json_has_tests": "FALSE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "",
    "is_benchmark_actually_there": "",
    "sample_clues": "make, pad, tensor"
  }
}