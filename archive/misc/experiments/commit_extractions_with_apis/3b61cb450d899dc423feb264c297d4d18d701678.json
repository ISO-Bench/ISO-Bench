{
  "commit_hash": "3b61cb450d899dc423feb264c297d4d18d701678",
  "parent_hash": "edc4fa31888b4a41060acb7b16250540f051ad59",
  "message": "[V1] Further reduce CPU overheads in flash-attn (#10989)\n\nSigned-off-by: Woosuk Kwon <woosuk.kwon@berkeley.edu>",
  "author": "Woosuk Kwon <woosuk.kwon@berkeley.edu>",
  "date": "2024-12-09 12:38:46 -0800",
  "files_changed": [
    {
      "file_path": "csrc/cache_kernels.cu",
      "old_content": "#include <torch/all.h>\n#include <ATen/cuda/CUDAContext.h>\n#include <c10/cuda/CUDAGuard.h>\n\n#include \"cuda_compat.h\"\n#include \"dispatch_utils.h\"\n\n#ifdef USE_ROCM\n  #include \"quantization/fp8/amd/quant_utils.cuh\"\n#else\n  #include \"quantization/fp8/nvidia/quant_utils.cuh\"\n#endif\n\n#include <algorithm>\n#include <cassert>\n#include <map>\n#include <vector>\n\n#ifdef USE_ROCM\n  #include <hip/hip_bf16.h>\ntypedef __hip_bfloat16 __nv_bfloat16;\n#endif\n\nvoid swap_blocks(torch::Tensor& src, torch::Tensor& dst,\n                 const torch::Tensor& block_mapping) {\n  torch::Device src_device = src.device();\n  torch::Device dst_device = dst.device();\n  cudaMemcpyKind memcpy_type;\n  if (src_device.is_cuda() && dst_device.is_cuda()) {\n    TORCH_CHECK(src_device.index() == dst_device.index(),\n                \"src and dst must be on the same GPU\");\n    memcpy_type = cudaMemcpyDeviceToDevice;\n  } else if (src_device.is_cuda() && dst_device.is_cpu()) {\n    memcpy_type = cudaMemcpyDeviceToHost;\n  } else if (src_device.is_cpu() && dst_device.is_cuda()) {\n    memcpy_type = cudaMemcpyHostToDevice;\n  } else {\n    TORCH_CHECK(false, \"Invalid device combination\");\n  }\n\n  // NOTE(youkaichao): keep in mind that `block_mapping` should be\n  // a cpu tensor, otherwise every `item` call will require a gpu-cpu\n  // synchronization.\n  TORCH_CHECK(block_mapping.device().is_cpu(), \"block_mapping must be on CPU\");\n\n  char* src_ptr = static_cast<char*>(src.data_ptr());\n  char* dst_ptr = static_cast<char*>(dst.data_ptr());\n\n  const int64_t block_size_in_bytes = src.element_size() * src[0].numel();\n  const at::cuda::OptionalCUDAGuard device_guard(\n      src_device.is_cuda() ? src_device : dst_device);\n  const cudaStream_t stream = at::cuda::getCurrentCUDAStream();\n  // NOTE(woosuk): This can be slow if the number of blocks is large.\n  const int64_t num_blocks = block_mapping.size(0);\n  for (size_t i = 0; i < num_blocks; i++) {\n    int64_t src_block_number = block_mapping[i][0].item<int64_t>();\n    int64_t dst_block_number = block_mapping[i][1].item<int64_t>();\n    int64_t src_offset = src_block_number * block_size_in_bytes;\n    int64_t dst_offset = dst_block_number * block_size_in_bytes;\n    cudaMemcpyAsync(dst_ptr + dst_offset, src_ptr + src_offset,\n                    block_size_in_bytes, memcpy_type, stream);\n  }\n}\n\nnamespace vllm {\n\n// Grid: (num_layers, num_pairs)\ntemplate <typename scalar_t>\n__global__ void copy_blocks_kernel(int64_t* key_cache_ptrs,\n                                   int64_t* value_cache_ptrs,\n                                   const int64_t* __restrict__ block_mapping,\n                                   const int numel_per_block) {\n  const int layer_idx = blockIdx.x;\n  const int pair_idx = blockIdx.y;\n\n  scalar_t* key_cache = reinterpret_cast<scalar_t*>(key_cache_ptrs[layer_idx]);\n  scalar_t* value_cache =\n      reinterpret_cast<scalar_t*>(value_cache_ptrs[layer_idx]);\n  int64_t src_block_number = block_mapping[2 * pair_idx];\n  int64_t dst_block_number = block_mapping[2 * pair_idx + 1];\n\n  const int64_t src_block_offset = src_block_number * numel_per_block;\n  const int64_t dst_block_offset = dst_block_number * numel_per_block;\n  for (int i = threadIdx.x; i < numel_per_block; i += blockDim.x) {\n    int64_t src_offset = src_block_offset + i;\n    int64_t dst_offset = dst_block_offset + i;\n    key_cache[dst_offset] = key_cache[src_offset];\n  }\n  for (int i = threadIdx.x; i < numel_per_block; i += blockDim.x) {\n    int64_t src_offset = src_block_offset + i;\n    int64_t dst_offset = dst_block_offset + i;\n    value_cache[dst_offset] = value_cache[src_offset];\n  }\n}\n\n}  // namespace vllm\n\n// Note: the key_caches and value_caches vectors are constant but\n// not the Tensors they contain. The vectors need to be const refs\n// in order to satisfy pytorch's C++ operator registration code.\nvoid copy_blocks(std::vector<torch::Tensor> const& key_caches,\n                 std::vector<torch::Tensor> const& value_caches,\n                 const torch::Tensor& block_mapping) {\n  int num_layers = key_caches.size();\n  TORCH_CHECK(num_layers == value_caches.size());\n  if (num_layers == 0) {\n    return;\n  }\n  torch::Device cache_device = key_caches[0].device();\n  TORCH_CHECK(cache_device.is_cuda());\n\n  // Create data structures for the kernel.\n  // Create an array of pointers to the key and value caches.\n  int64_t key_cache_ptrs[num_layers];\n  int64_t value_cache_ptrs[num_layers];\n  for (int layer_idx = 0; layer_idx < num_layers; ++layer_idx) {\n    key_cache_ptrs[layer_idx] =\n        reinterpret_cast<int64_t>(key_caches[layer_idx].data_ptr());\n    value_cache_ptrs[layer_idx] =\n        reinterpret_cast<int64_t>(value_caches[layer_idx].data_ptr());\n  }\n\n  // block_mapping is a 2D tensor with shape (num_pairs, 2).\n  int num_pairs = block_mapping.size(0);\n\n  // Move the data structures to the GPU.\n  // NOTE: This synchronizes the CPU and GPU.\n  torch::Tensor key_cache_ptrs_tensor =\n      torch::from_blob(key_cache_ptrs, {num_layers}, torch::kInt64)\n          .to(cache_device);\n  torch::Tensor value_cache_ptrs_tensor =\n      torch::from_blob(value_cache_ptrs, {num_layers}, torch::kInt64)\n          .to(cache_device);\n\n  // Launch the kernel.\n  const int numel_per_block = key_caches[0][0].numel();\n  dim3 grid(num_layers, num_pairs);\n  dim3 block(std::min(1024, numel_per_block));\n  const at::cuda::OptionalCUDAGuard device_guard(cache_device);\n  const cudaStream_t stream = at::cuda::getCurrentCUDAStream();\n  VLLM_DISPATCH_FLOATING_AND_BYTE_TYPES(\n      key_caches[0].scalar_type(), \"copy_blocks_kernel\", ([&] {\n        vllm::copy_blocks_kernel<scalar_t><<<grid, block, 0, stream>>>(\n            key_cache_ptrs_tensor.data_ptr<int64_t>(),\n            value_cache_ptrs_tensor.data_ptr<int64_t>(),\n            block_mapping.data_ptr<int64_t>(), numel_per_block);\n      }));\n}\n\nnamespace vllm {\n\ntemplate <typename scalar_t, typename cache_t, Fp8KVCacheDataType kv_dt>\n__global__ void reshape_and_cache_kernel(\n    const scalar_t* __restrict__ key,    // [num_tokens, num_heads, head_size]\n    const scalar_t* __restrict__ value,  // [num_tokens, num_heads, head_size]\n    cache_t* __restrict__ key_cache,     // [num_blocks, num_heads, head_size/x,\n                                         // block_size, x]\n    cache_t* __restrict__ value_cache,   // [num_blocks, num_heads, head_size,\n                                         // block_size]\n    const int64_t* __restrict__ slot_mapping,  // [num_tokens]\n    const int key_stride, const int value_stride, const int num_heads,\n    const int head_size, const int block_size, const int x, const float k_scale,\n    const float v_scale) {\n  const int64_t token_idx = blockIdx.x;\n  const int64_t slot_idx = slot_mapping[token_idx];\n  if (slot_idx < 0) {\n    // Padding token that should be ignored.\n    return;\n  }\n\n  const int64_t block_idx = slot_idx / block_size;\n  const int64_t block_offset = slot_idx % block_size;\n\n  const int n = num_heads * head_size;\n  for (int i = threadIdx.x; i < n; i += blockDim.x) {\n    const int64_t src_key_idx = token_idx * key_stride + i;\n    const int64_t src_value_idx = token_idx * value_stride + i;\n\n    const int head_idx = i / head_size;\n    const int head_offset = i % head_size;\n    const int x_idx = head_offset / x;\n    const int x_offset = head_offset % x;\n\n    const int64_t tgt_key_idx =\n        block_idx * num_heads * (head_size / x) * block_size * x +\n        head_idx * (head_size / x) * block_size * x + x_idx * block_size * x +\n        block_offset * x + x_offset;\n    const int64_t tgt_value_idx =\n        block_idx * num_heads * head_size * block_size +\n        head_idx * head_size * block_size + head_offset * block_size +\n        block_offset;\n    scalar_t tgt_key = key[src_key_idx];\n    scalar_t tgt_value = value[src_value_idx];\n    if constexpr (kv_dt == Fp8KVCacheDataType::kAuto) {\n      key_cache[tgt_key_idx] = tgt_key;\n      value_cache[tgt_value_idx] = tgt_value;\n    } else {\n      key_cache[tgt_key_idx] =\n          fp8::scaled_convert<cache_t, scalar_t, kv_dt>(tgt_key, k_scale);\n      value_cache[tgt_value_idx] =\n          fp8::scaled_convert<cache_t, scalar_t, kv_dt>(tgt_value, v_scale);\n    }\n  }\n}\n\ntemplate <typename scalar_t, typename cache_t, Fp8KVCacheDataType kv_dt>\n__global__ void reshape_and_cache_flash_kernel(\n    const scalar_t* __restrict__ key,    // [num_tokens, num_heads, head_size]\n    const scalar_t* __restrict__ value,  // [num_tokens, num_heads, head_size]\n    cache_t* __restrict__ key_cache,     // [num_blocks, block_size, num_heads,\n                                         // head_size]\n    cache_t* __restrict__ value_cache,   // [num_blocks, block_size, num_heads,\n                                         // head_size]\n    const int64_t* __restrict__ slot_mapping,  // [num_tokens]\n    const int block_stride, const int key_stride, const int value_stride,\n    const int num_heads, const int head_size, const int block_size,\n    const float k_scale, const float v_scale) {\n  const int64_t token_idx = blockIdx.x;\n  const int64_t slot_idx = slot_mapping[token_idx];\n  // NOTE: slot_idx can be -1 if the token is padded\n  if (slot_idx < 0) {\n    return;\n  }\n  const int64_t block_idx = slot_idx / block_size;\n  const int64_t block_offset = slot_idx % block_size;\n  const int n = num_heads * head_size;\n  for (int i = threadIdx.x; i < n; i += blockDim.x) {\n    const int64_t src_key_idx = token_idx * key_stride + i;\n    const int64_t src_value_idx = token_idx * value_stride + i;\n    const int head_idx = i / head_size;\n    const int head_offset = i % head_size;\n    const int64_t tgt_key_value_idx = block_idx * block_stride +\n                                      block_offset * num_heads * head_size +\n                                      head_idx * head_size + head_offset;\n    scalar_t tgt_key = key[src_key_idx];\n    scalar_t tgt_value = value[src_value_idx];\n    if constexpr (kv_dt == Fp8KVCacheDataType::kAuto) {\n      key_cache[tgt_key_value_idx] = tgt_key;\n      value_cache[tgt_key_value_idx] = tgt_value;\n    } else {\n      key_cache[tgt_key_value_idx] =\n          fp8::scaled_convert<cache_t, scalar_t, kv_dt>(tgt_key, k_scale);\n      value_cache[tgt_key_value_idx] =\n          fp8::scaled_convert<cache_t, scalar_t, kv_dt>(tgt_value, v_scale);\n    }\n  }\n}\n}  // namespace vllm\n\n// KV_T is the stored data type of kv-cache.\n// CACHE_T is the data type of key and value tensors.\n// KV_DTYPE is the real data type of kv-cache.\n#define CALL_RESHAPE_AND_CACHE(KV_T, CACHE_T, KV_DTYPE)               \\\n  vllm::reshape_and_cache_kernel<KV_T, CACHE_T, KV_DTYPE>             \\\n      <<<grid, block, 0, stream>>>(                                   \\\n          reinterpret_cast<KV_T*>(key.data_ptr()),                    \\\n          reinterpret_cast<KV_T*>(value.data_ptr()),                  \\\n          reinterpret_cast<CACHE_T*>(key_cache.data_ptr()),           \\\n          reinterpret_cast<CACHE_T*>(value_cache.data_ptr()),         \\\n          slot_mapping.data_ptr<int64_t>(), key_stride, value_stride, \\\n          num_heads, head_size, block_size, x, k_scale, v_scale);\n\nvoid reshape_and_cache(\n    torch::Tensor& key,    // [num_tokens, num_heads, head_size]\n    torch::Tensor& value,  // [num_tokens, num_heads, head_size]\n    torch::Tensor&\n        key_cache,  // [num_blocks, num_heads, head_size/x, block_size, x]\n    torch::Tensor&\n        value_cache,  // [num_blocks, num_heads, head_size, block_size]\n    torch::Tensor& slot_mapping,  // [num_tokens]\n    const std::string& kv_cache_dtype, const double k_scale,\n    const double v_scale) {\n  int num_tokens = key.size(0);\n  int num_heads = key.size(1);\n  int head_size = key.size(2);\n  int block_size = key_cache.size(3);\n  int x = key_cache.size(4);\n\n  int key_stride = key.stride(0);\n  int value_stride = value.stride(0);\n\n  dim3 grid(num_tokens);\n  dim3 block(std::min(num_heads * head_size, 512));\n  const at::cuda::OptionalCUDAGuard device_guard(device_of(key));\n  const cudaStream_t stream = at::cuda::getCurrentCUDAStream();\n\n  DISPATCH_BY_KV_CACHE_DTYPE(key.dtype(), kv_cache_dtype,\n                             CALL_RESHAPE_AND_CACHE)\n}\n\n// KV_T is the stored data type of kv-cache.\n// CACHE_T is the data type of key and value tensors.\n// KV_DTYPE is the real data type of kv-cache.\n#define CALL_RESHAPE_AND_CACHE_FLASH(KV_T, CACHE_T, KV_DTYPE)         \\\n  vllm::reshape_and_cache_flash_kernel<KV_T, CACHE_T, KV_DTYPE>       \\\n      <<<grid, block, 0, stream>>>(                                   \\\n          reinterpret_cast<KV_T*>(key.data_ptr()),                    \\\n          reinterpret_cast<KV_T*>(value.data_ptr()),                  \\\n          reinterpret_cast<CACHE_T*>(key_cache.data_ptr()),           \\\n          reinterpret_cast<CACHE_T*>(value_cache.data_ptr()),         \\\n          slot_mapping.data_ptr<int64_t>(), block_stride, key_stride, \\\n          value_stride, num_heads, head_size, block_size, k_scale, v_scale);\n\nvoid reshape_and_cache_flash(\n    torch::Tensor& key,        // [num_tokens, num_heads, head_size]\n    torch::Tensor& value,      // [num_tokens, num_heads, head_size]\n    torch::Tensor& key_cache,  // [num_blocks, block_size, num_heads, head_size]\n    torch::Tensor&\n        value_cache,  // [num_blocks, block_size, num_heads, head_size]\n    torch::Tensor& slot_mapping,  // [num_tokens]\n    const std::string& kv_cache_dtype, const double k_scale,\n    const double v_scale) {\n  int num_tokens = key.size(0);\n  int num_heads = key.size(1);\n  int head_size = key.size(2);\n  int block_size = key_cache.size(1);\n\n  int key_stride = key.stride(0);\n  int value_stride = value.stride(0);\n  int block_stride = key_cache.stride(0);\n  TORCH_CHECK(key_cache.stride(0) == value_cache.stride(0));\n\n  dim3 grid(num_tokens);\n  dim3 block(std::min(num_heads * head_size, 512));\n  const at::cuda::OptionalCUDAGuard device_guard(device_of(key));\n  const cudaStream_t stream = at::cuda::getCurrentCUDAStream();\n\n  DISPATCH_BY_KV_CACHE_DTYPE(key.dtype(), kv_cache_dtype,\n                             CALL_RESHAPE_AND_CACHE_FLASH);\n}\n\nnamespace vllm {\n\ntemplate <typename Tout, typename Tin, Fp8KVCacheDataType kv_dt>\n__global__ void convert_fp8_kernel(const Tin* __restrict__ src_cache,\n                                   Tout* __restrict__ dst_cache,\n                                   const float scale,\n                                   const int64_t block_stride) {\n  const int64_t block_idx = blockIdx.x;\n  for (int i = threadIdx.x; i < block_stride; i += blockDim.x) {\n    int64_t idx = block_idx * block_stride + i;\n    dst_cache[idx] =\n        fp8::scaled_convert<Tout, Tin, kv_dt>(src_cache[idx], scale);\n  }\n}\n\n}  // namespace vllm\n\n#define CALL_CONVERT_FP8(Tout, Tin, KV_DTYPE)                                \\\n  vllm::convert_fp8_kernel<Tout, Tin, KV_DTYPE><<<grid, block, 0, stream>>>( \\\n      reinterpret_cast<Tin*>(src_cache.data_ptr()),                          \\\n      reinterpret_cast<Tout*>(dst_cache.data_ptr()), scale, block_stride);\n\n// Only for testing.\nvoid convert_fp8(torch::Tensor& dst_cache, torch::Tensor& src_cache,\n                 const double scale, const std::string& kv_cache_dtype) {\n  torch::Device src_device = src_cache.device();\n  torch::Device dst_device = dst_cache.device();\n  TORCH_CHECK(src_device.is_cuda(), \"src must be on a GPU\")\n  TORCH_CHECK(dst_device.is_cuda(), \"dst must be on a GPU\")\n  TORCH_CHECK(src_device.index() == dst_device.index(),\n              \"src and dst must be on the same GPU\");\n  at::cuda::OptionalCUDAGuard device_guard(src_device);\n\n  int64_t num_blocks = src_cache.size(0);\n  int64_t block_stride = src_cache.stride(0);\n\n  dim3 grid(num_blocks);\n  dim3 block(std::min(block_stride, int64_t(512)));\n  const cudaStream_t stream = at::cuda::getCurrentCUDAStream();\n\n  if (kv_cache_dtype == \"auto\") {\n    if (src_cache.dtype() == at::ScalarType::Float) {\n      CALL_CONVERT_FP8(uint8_t, float, vllm::Fp8KVCacheDataType::kAuto);\n    } else if (src_cache.dtype() == at::ScalarType::Half) {\n      CALL_CONVERT_FP8(uint8_t, uint16_t, vllm::Fp8KVCacheDataType::kAuto);\n    } else if (src_cache.dtype() == at::ScalarType::BFloat16) {\n      CALL_CONVERT_FP8(uint8_t, __nv_bfloat16, vllm::Fp8KVCacheDataType::kAuto);\n    } else if (dst_cache.dtype() == at::ScalarType::Float) {\n      CALL_CONVERT_FP8(float, uint8_t, vllm::Fp8KVCacheDataType::kAuto);\n    } else if (dst_cache.dtype() == at::ScalarType::Half) {\n      CALL_CONVERT_FP8(uint16_t, uint8_t, vllm::Fp8KVCacheDataType::kAuto);\n    } else if (dst_cache.dtype() == at::ScalarType::BFloat16) {\n      CALL_CONVERT_FP8(__nv_bfloat16, uint8_t, vllm::Fp8KVCacheDataType::kAuto);\n    }\n  } else if (kv_cache_dtype == \"fp8\" || kv_cache_dtype == \"fp8_e4m3\") {\n    if (src_cache.dtype() == at::ScalarType::Float) {\n      CALL_CONVERT_FP8(uint8_t, float, vllm::Fp8KVCacheDataType::kFp8E4M3);\n    } else if (src_cache.dtype() == at::ScalarType::Half) {\n      CALL_CONVERT_FP8(uint8_t, uint16_t, vllm::Fp8KVCacheDataType::kFp8E4M3);\n    } else if (src_cache.dtype() == at::ScalarType::BFloat16) {\n      CALL_CONVERT_FP8(uint8_t, __nv_bfloat16,\n                       vllm::Fp8KVCacheDataType::kFp8E4M3);\n    } else if (dst_cache.dtype() == at::ScalarType::Float) {\n      CALL_CONVERT_FP8(float, uint8_t, vllm::Fp8KVCacheDataType::kFp8E4M3);\n    } else if (dst_cache.dtype() == at::ScalarType::Half) {\n      CALL_CONVERT_FP8(uint16_t, uint8_t, vllm::Fp8KVCacheDataType::kFp8E4M3);\n    } else if (dst_cache.dtype() == at::ScalarType::BFloat16) {\n      CALL_CONVERT_FP8(__nv_bfloat16, uint8_t,\n                       vllm::Fp8KVCacheDataType::kFp8E4M3);\n    }\n  } else {\n    TORCH_CHECK(false, \"Unsupported data type: \", kv_cache_dtype);\n  }\n}\n",
      "diff": "diff --git a/csrc/cache_kernels.cu b/csrc/cache_kernels.cu\nindex 1be806bbf..8a95279f9 100644\n--- a/csrc/cache_kernels.cu\n+++ b/csrc/cache_kernels.cu\n@@ -307,10 +307,20 @@ void reshape_and_cache_flash(\n     torch::Tensor& key_cache,  // [num_blocks, block_size, num_heads, head_size]\n     torch::Tensor&\n         value_cache,  // [num_blocks, block_size, num_heads, head_size]\n-    torch::Tensor& slot_mapping,  // [num_tokens]\n+    torch::Tensor& slot_mapping,  // [num_tokens] or [num_actual_tokens]\n     const std::string& kv_cache_dtype, const double k_scale,\n     const double v_scale) {\n-  int num_tokens = key.size(0);\n+  // NOTE(woosuk): In vLLM V1, key.size(0) can be different from\n+  // slot_mapping.size(0) because of padding for CUDA graphs.\n+  // In vLLM V0, key.size(0) is always equal to slot_mapping.size(0) because\n+  // both include padding.\n+  // In vLLM V1, however, key.size(0) can be larger than slot_mapping.size(0)\n+  // since key includes padding for CUDA graphs, while slot_mapping does not.\n+  // In this case, slot_mapping.size(0) represents the actual number of tokens\n+  // before padding.\n+  // For compatibility with both cases, we use slot_mapping.size(0) as the\n+  // number of tokens.\n+  int num_tokens = slot_mapping.size(0);\n   int num_heads = key.size(1);\n   int head_size = key.size(2);\n   int block_size = key_cache.size(1);",
      "change_type": "modified",
      "lines_added": 13,
      "lines_removed": 3
    },
    {
      "file_path": "vllm/v1/attention/backends/flash_attn.py",
      "old_content": "\"\"\"Attention layer with FlashAttention.\"\"\"\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, List, Optional, Tuple, Type\n\nimport torch\n\nfrom vllm.attention.backends.abstract import (AttentionBackend, AttentionImpl,\n                                              AttentionMetadata, AttentionType)\nfrom vllm.vllm_flash_attn import flash_attn_varlen_func\n\n\nclass FlashAttentionBackend(AttentionBackend):\n\n    @staticmethod\n    def get_supported_head_sizes() -> List[int]:\n        return [32, 64, 96, 128, 160, 192, 224, 256]\n\n    @staticmethod\n    def get_name() -> str:\n        return \"FLASH_ATTN_VLLM_V1\"\n\n    @staticmethod\n    def get_impl_cls() -> Type[\"FlashAttentionImpl\"]:\n        return FlashAttentionImpl\n\n    @staticmethod\n    def get_metadata_cls() -> Type[\"AttentionMetadata\"]:\n        return FlashAttentionMetadata\n\n    @staticmethod\n    def get_kv_cache_shape(\n        num_blocks: int,\n        block_size: int,\n        num_kv_heads: int,\n        head_size: int,\n    ) -> Tuple[int, ...]:\n        if block_size % 16 != 0:\n            raise ValueError(\"Block size must be a multiple of 16.\")\n        return (2, num_blocks, block_size, num_kv_heads, head_size)\n\n\n@dataclass\nclass FlashAttentionMetadata:\n    # NOTE(sang): Definition of context_len, query_len, and seq_len.\n    # |---------- N-1 iteration --------|\n    # |---------------- N iteration ---------------------|\n    # |- tokenA -|......................|-- newTokens ---|\n    # |---------- context_len ----------|\n    # |-------------------- seq_len ---------------------|\n    #                                   |-- query_len ---|\n\n    num_actual_tokens: int  # Number of tokens excluding padding.\n    max_query_len: int\n    query_start_loc: torch.Tensor\n    max_seq_len: int\n    seq_start_loc: torch.Tensor\n    block_table: torch.Tensor\n    slot_mapping: torch.Tensor\n\n\nclass FlashAttentionImpl(AttentionImpl):\n\n    def __init__(\n        self,\n        num_heads: int,\n        head_size: int,\n        scale: float,\n        num_kv_heads: int,\n        alibi_slopes: Optional[List[float]],\n        sliding_window: Optional[int],\n        kv_cache_dtype: str,\n        blocksparse_params: Optional[Dict[str, Any]] = None,\n        logits_soft_cap: Optional[float] = None,\n    ) -> None:\n        if blocksparse_params is not None:\n            raise ValueError(\n                \"FlashAttention does not support block-sparse attention.\")\n        self.num_heads = num_heads\n        self.head_size = head_size\n        self.scale = float(scale)\n        self.num_kv_heads = num_kv_heads\n        if alibi_slopes is not None:\n            alibi_slopes = torch.tensor(alibi_slopes, dtype=torch.float32)\n        self.alibi_slopes = alibi_slopes\n        if sliding_window is None:\n            self.sliding_window = (-1, -1)\n        else:\n            self.sliding_window = (sliding_window - 1, 0)\n        self.kv_cache_dtype = kv_cache_dtype\n        if logits_soft_cap is None:\n            # In flash-attn, setting logits_soft_cap as 0 means no soft cap.\n            logits_soft_cap = 0\n        self.logits_soft_cap = logits_soft_cap\n\n        assert self.num_heads % self.num_kv_heads == 0\n        self.num_queries_per_kv = self.num_heads // self.num_kv_heads\n\n        support_head_sizes = FlashAttentionBackend.get_supported_head_sizes()\n        if head_size not in support_head_sizes:\n            raise ValueError(\n                f\"Head size {head_size} is not supported by FlashAttention. \"\n                f\"Supported head sizes are: {support_head_sizes}.\")\n\n    def forward(\n        self,\n        query: torch.Tensor,\n        key: torch.Tensor,\n        value: torch.Tensor,\n        kv_cache: torch.Tensor,\n        attn_metadata: FlashAttentionMetadata,\n        k_scale: float = 1.0,\n        v_scale: float = 1.0,\n        attn_type: AttentionType = AttentionType.DECODER,\n        output: Optional[torch.Tensor] = None,\n    ) -> torch.Tensor:\n        \"\"\"Forward pass with FlashAttention.\n\n        Args:\n            query: shape = [num_tokens, num_heads, head_size]\n            key: shape = [num_tokens, num_kv_heads, head_size]\n            value: shape = [num_tokens, num_kv_heads, head_size]\n            kv_cache = [2, num_blocks, block_size, num_kv_heads, head_size]\n            attn_metadata: Metadata for attention.\n        Returns:\n            shape = [num_tokens, num_heads * head_size]\n        \"\"\"\n        if attn_type != AttentionType.DECODER:\n            raise NotImplementedError(\"Encoder self-attention and \"\n                                      \"encoder/decoder cross-attention \"\n                                      \"are not implemented for \"\n                                      \"FlashAttentionImpl\")\n\n        # NOTE(woosuk): FlashAttention does not support FP8 KV cache.\n        assert k_scale == 1.0 and v_scale == 1.0, (\n            \"key/v_scale is not supported in FlashAttention.\")\n\n        if attn_metadata is None:\n            # Profiling run.\n            return output\n\n        num_actual_tokens = attn_metadata.num_actual_tokens\n\n        # Reshape the input keys and values and store them in the cache.\n        key_cache = kv_cache[0]\n        value_cache = kv_cache[1]\n        torch.ops._C_cache_ops.reshape_and_cache_flash(\n            key[:num_actual_tokens],\n            value[:num_actual_tokens],\n            key_cache,\n            value_cache,\n            attn_metadata.slot_mapping,\n            self.kv_cache_dtype,\n            k_scale,\n            v_scale,\n        )\n\n        # Compute attention and update output up to `num_actual_tokens`.\n        flash_attn_varlen_func(\n            q=query[:num_actual_tokens],\n            k=key_cache,\n            v=value_cache,\n            out=output[:num_actual_tokens],\n            cu_seqlens_q=attn_metadata.query_start_loc,\n            max_seqlen_q=attn_metadata.max_query_len,\n            cu_seqlens_k=attn_metadata.seq_start_loc,\n            max_seqlen_k=attn_metadata.max_seq_len,\n            softmax_scale=self.scale,\n            causal=True,\n            alibi_slopes=self.alibi_slopes,\n            window_size=self.sliding_window,\n            block_table=attn_metadata.block_table,\n            softcap=self.logits_soft_cap,\n        )\n\n        return output\n",
      "diff": "diff --git a/vllm/v1/attention/backends/flash_attn.py b/vllm/v1/attention/backends/flash_attn.py\nindex d37989055..251a103e6 100644\n--- a/vllm/v1/attention/backends/flash_attn.py\n+++ b/vllm/v1/attention/backends/flash_attn.py\n@@ -138,14 +138,25 @@ class FlashAttentionImpl(AttentionImpl):\n             # Profiling run.\n             return output\n \n-        num_actual_tokens = attn_metadata.num_actual_tokens\n+        # IMPORTANT!\n+        # NOTE(woosuk): With piece-wise CUDA graphs, this method is executed in\n+        # eager-mode PyTorch. Thus, we need to be careful about any CPU overhead\n+        # in this method. For example, `view` and `slice` (or `[:n]`) operations\n+        # are surprisingly slow even in the case they do not invoke any GPU ops.\n+        # Minimize the PyTorch ops in this method as much as possible.\n+        # Whenever making a change in this method, please benchmark the\n+        # performance to make sure it does not introduce any overhead.\n \n+        num_actual_tokens = attn_metadata.num_actual_tokens\n         # Reshape the input keys and values and store them in the cache.\n-        key_cache = kv_cache[0]\n-        value_cache = kv_cache[1]\n+        # NOTE(woosuk): Here, key and value are padded while slot_mapping is\n+        # not padded. However, we don't need to do key[:num_actual_tokens] and\n+        # value[:num_actual_tokens] because the reshape_and_cache_flash op uses\n+        # the slot_mapping's shape to determine the number of actual tokens.\n+        key_cache, value_cache = kv_cache.unbind(0)\n         torch.ops._C_cache_ops.reshape_and_cache_flash(\n-            key[:num_actual_tokens],\n-            value[:num_actual_tokens],\n+            key,\n+            value,\n             key_cache,\n             value_cache,\n             attn_metadata.slot_mapping,",
      "change_type": "modified",
      "lines_added": 17,
      "lines_removed": 6
    }
  ],
  "affected_apis": [
    "torch.ops._C_cache_ops.reshape_and_cache_flash",
    "vllm.v1.attention.backends.flash_attn.FlashAttentionImpl"
  ],
  "summary": {
    "total_files": 2,
    "files_added": 0,
    "files_deleted": 0,
    "files_modified": 2
  },
  "csv_metadata": {
    "category": "kernel-based",
    "json_has_tests": "FALSE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "NO (cpu)",
    "is_benchmark_actually_there": "",
    "sample_clues": "and, attention, attn"
  }
}