{
  "commit_hash": "886936837ca89e5645bc1f71cc0e1492b65b1590",
  "parent_hash": "6d917d0eebd03990edf2443780a5f2506026ea78",
  "message": "[Performance][Core] Optimize the performance of evictor v1 and v2 by applying a priority queue and lazy deletion (#7209)",
  "author": "Sungjae Lee <33976427+llsj14@users.noreply.github.com>",
  "date": "2024-12-14 11:38:10 -0800",
  "files_changed": [
    {
      "file_path": "vllm/core/evictor.py",
      "old_content": "import enum\nfrom abc import ABC, abstractmethod\nfrom typing import OrderedDict, Tuple\n\n\nclass EvictionPolicy(enum.Enum):\n    \"\"\"Enum for eviction policy used by make_evictor to instantiate the correct\n       Evictor subclass.\n    \"\"\"\n    LRU = enum.auto()\n\n\nclass Evictor(ABC):\n    \"\"\"The Evictor subclasses should be used by the BlockAllocator class to\n    handle eviction of freed PhysicalTokenBlocks.\n    \"\"\"\n\n    @abstractmethod\n    def __init__(self):\n        pass\n\n    @abstractmethod\n    def __contains__(self, block_id: int) -> bool:\n        pass\n\n    @abstractmethod\n    def evict(self) -> Tuple[int, int]:\n        \"\"\"Runs the eviction algorithm and returns the evicted block's\n        content hash along with physical block id along with physical block id\n        \"\"\"\n        pass\n\n    @abstractmethod\n    def add(self, block_id: int, content_hash: int, num_hashed_tokens: int,\n            last_accessed: float):\n        \"\"\"Adds block to the evictor, making it a candidate for eviction\"\"\"\n        pass\n\n    @abstractmethod\n    def update(self, block_id: int, last_accessed: float):\n        \"\"\"Update corresponding block's access time in metadata\"\"\"\n        pass\n\n    @abstractmethod\n    def remove(self, block_id: int):\n        \"\"\"Remove a given block id from the cache.\"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def num_blocks(self) -> int:\n        pass\n\n\nclass BlockMetaData:\n    \"\"\"Data structure for storing key data describe cached block, so that\n    evitor could use to make its decision which one to choose for eviction\n\n    Here we use physical block id as the dict key, as there maybe several\n    blocks with the same content hash, but their physical id is unique.\n    \"\"\"\n\n    def __init__(self, content_hash: int, num_hashed_tokens: int,\n                 last_accessed: float):\n        self.content_hash = content_hash\n        self.num_hashed_tokens = num_hashed_tokens\n        self.last_accessed = last_accessed\n\n\nclass LRUEvictor(Evictor):\n    \"\"\"Evicts in a least-recently-used order using the last_accessed timestamp\n    that's recorded in the PhysicalTokenBlock. If there are multiple blocks with\n    the same last_accessed time, then the one with the largest num_hashed_tokens\n    will be evicted. If two blocks each have the lowest last_accessed time and\n    highest num_hashed_tokens value, then one will be chose arbitrarily\n    \"\"\"\n\n    def __init__(self):\n        self.free_table: OrderedDict[int, BlockMetaData] = OrderedDict()\n\n    def __contains__(self, block_id: int) -> bool:\n        return block_id in self.free_table\n\n    def evict(self) -> Tuple[int, int]:\n        if len(self.free_table) == 0:\n            raise ValueError(\"No usable cache memory left\")\n\n        evicted_block, evicted_block_id = None, None\n        # The blocks with the lowest timestamps should be placed consecutively\n        # at the start of OrderedDict. Loop through all these blocks to\n        # find the one with maximum number of hashed tokens.\n        for _id, block in self.free_table.items():\n            if evicted_block is None:\n                evicted_block, evicted_block_id = block, _id\n                continue\n            if evicted_block.last_accessed < block.last_accessed:\n                break\n            if evicted_block.num_hashed_tokens < block.num_hashed_tokens:\n                evicted_block, evicted_block_id = block, _id\n\n        assert evicted_block is not None\n        assert evicted_block_id is not None\n        self.free_table.pop(evicted_block_id)\n\n        return evicted_block_id, evicted_block.content_hash\n\n    def add(self, block_id: int, content_hash: int, num_hashed_tokens: int,\n            last_accessed: float):\n        self.free_table[block_id] = BlockMetaData(content_hash,\n                                                  num_hashed_tokens,\n                                                  last_accessed)\n\n    def update(self, block_id: int, last_accessed: float):\n        self.free_table[block_id].last_accessed = last_accessed\n\n    def remove(self, block_id: int):\n        if block_id not in self.free_table:\n            raise ValueError(\n                \"Attempting to remove block that's not in the evictor\")\n        self.free_table.pop(block_id)\n\n    @property\n    def num_blocks(self) -> int:\n        return len(self.free_table)\n\n\ndef make_evictor(eviction_policy: EvictionPolicy) -> Evictor:\n    if eviction_policy == EvictionPolicy.LRU:\n        return LRUEvictor()\n    else:\n        raise ValueError(f\"Unknown cache eviction policy: {eviction_policy}\")\n",
      "diff": "diff --git a/vllm/core/evictor.py b/vllm/core/evictor.py\nindex ed7e06cab..44adc4158 100644\n--- a/vllm/core/evictor.py\n+++ b/vllm/core/evictor.py\n@@ -1,6 +1,7 @@\n import enum\n+import heapq\n from abc import ABC, abstractmethod\n-from typing import OrderedDict, Tuple\n+from typing import Dict, List, Tuple\n \n \n class EvictionPolicy(enum.Enum):\n@@ -75,8 +76,14 @@ class LRUEvictor(Evictor):\n     highest num_hashed_tokens value, then one will be chose arbitrarily\n     \"\"\"\n \n+    # CLEANUP_THRESHOLD determines the maximum allowable size of the priority\n+    # queue relative to the free table size. When this threshold is exceeded,\n+    # a cleanup operation is triggered to reduce memory usage.\n+    CLEANUP_THRESHOLD = 50\n+\n     def __init__(self):\n-        self.free_table: OrderedDict[int, BlockMetaData] = OrderedDict()\n+        self.free_table: Dict[int, BlockMetaData] = {}\n+        self.priority_queue = []\n \n     def __contains__(self, block_id: int) -> bool:\n         return block_id in self.free_table\n@@ -85,34 +92,50 @@ class LRUEvictor(Evictor):\n         if len(self.free_table) == 0:\n             raise ValueError(\"No usable cache memory left\")\n \n-        evicted_block, evicted_block_id = None, None\n-        # The blocks with the lowest timestamps should be placed consecutively\n-        # at the start of OrderedDict. Loop through all these blocks to\n-        # find the one with maximum number of hashed tokens.\n-        for _id, block in self.free_table.items():\n-            if evicted_block is None:\n-                evicted_block, evicted_block_id = block, _id\n-                continue\n-            if evicted_block.last_accessed < block.last_accessed:\n-                break\n-            if evicted_block.num_hashed_tokens < block.num_hashed_tokens:\n-                evicted_block, evicted_block_id = block, _id\n-\n-        assert evicted_block is not None\n-        assert evicted_block_id is not None\n-        self.free_table.pop(evicted_block_id)\n-\n-        return evicted_block_id, evicted_block.content_hash\n+        while self.priority_queue:\n+            # We do not remove outdated entries from the priority queue at the\n+            # time of updating the last_accessed timestamp. Instead, outdated\n+            # entries are filtered out here during eviction. Outdated entries\n+            # would either not in the free table, or have older last accessed\n+            # time.\n+            last_accessed, _, block_id, content_hash = heapq.heappop(\n+                self.priority_queue)\n+            if (block_id in self.free_table and\n+                    self.free_table[block_id].last_accessed == last_accessed):\n+                self.free_table.pop(block_id)\n+                return block_id, content_hash\n+\n+        raise ValueError(\"No usable cache memory left\")\n \n     def add(self, block_id: int, content_hash: int, num_hashed_tokens: int,\n             last_accessed: float):\n         self.free_table[block_id] = BlockMetaData(content_hash,\n                                                   num_hashed_tokens,\n                                                   last_accessed)\n+        heapq.heappush(\n+            self.priority_queue,\n+            (last_accessed, -num_hashed_tokens, block_id, content_hash))\n+        self._cleanup_if_necessary()\n \n     def update(self, block_id: int, last_accessed: float):\n         self.free_table[block_id].last_accessed = last_accessed\n \n+    def _cleanup_if_necessary(self):\n+        if len(self.priority_queue) > LRUEvictor.CLEANUP_THRESHOLD * len(\n+                self.free_table):\n+            self._cleanup()\n+\n+    def _cleanup(self):\n+        new_priority_queue: List[Tuple[float, int, int, int]] = []\n+\n+        for block_id, block in self.free_table.items():\n+            new_priority_queue.append(\n+                (block.last_accessed, -block.num_hashed_tokens, block_id,\n+                 block.content_hash))\n+        heapq.heapify(new_priority_queue)\n+\n+        self.priority_queue = new_priority_queue\n+\n     def remove(self, block_id: int):\n         if block_id not in self.free_table:\n             raise ValueError(",
      "change_type": "modified",
      "lines_added": 44,
      "lines_removed": 21
    }
  ],
  "affected_apis": [
    "LRUEvictor.evict",
    "LRUEvictor.add",
    "LRUEvictor.update",
    "LRUEvictor.remove",
    "LRUEvictor.__init__"
  ],
  "summary": {
    "total_files": 1,
    "files_added": 0,
    "files_deleted": 0,
    "files_modified": 1
  },
  "csv_metadata": {
    "category": "miscellaneous",
    "json_has_tests": "FALSE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "NO (evictor)",
    "is_benchmark_actually_there": "",
    "sample_clues": "add, core, evict"
  }
}