{
  "commit_hash": "a0dce9383ab7de0015060fb9fedadeb7d8ffdfb9",
  "parent_hash": "35e9c12bfaf8f273281af897b7208dfba53f103c",
  "message": "[Misc] Add compressed-tensors to optimized quant list (#7006)",
  "author": "Michael Goin <michael@neuralmagic.com>",
  "date": "2024-07-31 14:40:44 -0700",
  "files_changed": [
    {
      "file_path": "vllm/config.py",
      "old_content": "import enum\nimport json\nfrom dataclasses import dataclass, field, fields\nfrom typing import TYPE_CHECKING, ClassVar, List, Optional, Tuple, Type, Union\n\nimport torch\nfrom transformers import PretrainedConfig\n\nfrom vllm.logger import init_logger\nfrom vllm.model_executor.layers.quantization import QUANTIZATION_METHODS\nfrom vllm.model_executor.models import ModelRegistry\nfrom vllm.tracing import is_otel_installed\nfrom vllm.transformers_utils.config import get_config, get_hf_text_config\nfrom vllm.utils import (cuda_device_count_stateless, get_cpu_memory, is_cpu,\n                        is_hip, is_neuron, is_openvino, is_tpu, is_xpu,\n                        print_warning_once)\n\nif TYPE_CHECKING:\n    from ray.util.placement_group import PlacementGroup\n\n    from vllm.executor.executor_base import ExecutorBase\n    from vllm.model_executor.model_loader.loader import BaseModelLoader\n    from vllm.transformers_utils.tokenizer_group.base_tokenizer_group import (\n        BaseTokenizerGroup)\n\nlogger = init_logger(__name__)\n\n_GB = 1 << 30\n_EMBEDDING_MODEL_MAX_NUM_BATCHED_TOKENS = 32768\n\n_PP_SUPPORTED_MODELS = [\n    \"AquilaModel\",\n    \"AquilaForCausalLM\",\n    \"DeepseekV2ForCausalLM\",\n    \"InternLMForCausalLM\",\n    \"LlamaForCausalLM\",\n    \"LLaMAForCausalLM\",\n    \"MistralForCausalLM\",\n    \"Phi3ForCausalLM\",\n    \"GPT2LMHeadModel\",\n    \"MixtralForCausalLM\",\n    \"NemotronForCausalLM\",\n]\n\n\nclass ModelConfig:\n    \"\"\"Configuration for the model.\n\n    Args:\n        model: Name or path of the huggingface model to use.\n            It is also used as the content for `model_name` tag in metrics \n            output when `served_model_name` is not specified. \n        tokenizer: Name or path of the huggingface tokenizer to use.\n        tokenizer_mode: Tokenizer mode. \"auto\" will use the fast tokenizer if\n            available, and \"slow\" will always use the slow tokenizer.\n        trust_remote_code: Trust remote code (e.g., from HuggingFace) when\n            downloading the model and tokenizer.\n        dtype: Data type for model weights and activations. The \"auto\" option\n            will use FP16 precision for FP32 and FP16 models, and BF16 precision\n            for BF16 models.\n        seed: Random seed for reproducibility.\n        revision: The specific model version to use. It can be a branch name,\n            a tag name, or a commit id. If unspecified, will use the default\n            version.\n        code_revision: The specific revision to use for the model code on\n            Hugging Face Hub. It can be a branch name, a tag name, or a\n            commit id. If unspecified, will use the default version.\n        rope_scaling: Dictionary containing the scaling configuration for the\n            RoPE embeddings. When using this flag, don't update\n            `max_position_embeddings` to the expected new maximum.\n        tokenizer_revision: The specific tokenizer version to use. It can be a\n            branch name, a tag name, or a commit id. If unspecified, will use\n            the default version.\n        max_model_len: Maximum length of a sequence (including prompt and\n            output). If None, will be derived from the model.\n        quantization: Quantization method that was used to quantize the model\n            weights. If None, we assume the model weights are not quantized.\n        quantization_param_path: Path to JSON file containing scaling factors.\n            Used to load KV cache scaling factors into the model when KV cache\n            type is FP8_E4M3 on ROCm (AMD GPU). In the future these will also\n            be used to load activation and weight scaling factors when the\n            model dtype is FP8_E4M3 on ROCm.\n        enforce_eager: Whether to enforce eager execution. If True, we will\n            disable CUDA graph and always execute the model in eager mode.\n            If False, we will use CUDA graph and eager execution in hybrid.\n        max_context_len_to_capture: Maximum context len covered by CUDA graphs.\n            When a sequence has context length larger than this, we fall back\n            to eager mode (DEPRECATED. Use max_seq_len_to_capture instead).\n        max_seq_len_to_capture: Maximum sequence len covered by CUDA graphs.\n            When a sequence has context length larger than this, we fall back\n            to eager mode\n        disable_sliding_window: Whether to disable sliding window. If True,\n            we will disable the sliding window functionality of the model.\n            If the model does not support sliding window, this argument is\n            ignored.\n        skip_tokenizer_init: If true, skip initialization of tokenizer and\n            detokenizer.\n        served_model_name: The model name used in metrics tag `model_name`,\n            matches the model name exposed via the APIs. If multiple model \n            names provided, the first name will be used. If not specified, \n            the model name will be the same as `model`.\n    \"\"\"\n\n    def __init__(\n        self,\n        model: str,\n        tokenizer: str,\n        tokenizer_mode: str,\n        trust_remote_code: bool,\n        dtype: Union[str, torch.dtype],\n        seed: int,\n        revision: Optional[str] = None,\n        code_revision: Optional[str] = None,\n        rope_scaling: Optional[dict] = None,\n        rope_theta: Optional[float] = None,\n        tokenizer_revision: Optional[str] = None,\n        max_model_len: Optional[int] = None,\n        quantization: Optional[str] = None,\n        quantization_param_path: Optional[str] = None,\n        enforce_eager: bool = False,\n        max_context_len_to_capture: Optional[int] = None,\n        max_seq_len_to_capture: Optional[int] = None,\n        max_logprobs: int = 20,\n        disable_sliding_window: bool = False,\n        skip_tokenizer_init: bool = False,\n        served_model_name: Optional[Union[str, List[str]]] = None,\n        multimodal_config: Optional[\"MultiModalConfig\"] = None,\n    ) -> None:\n        self.model = model\n        self.tokenizer = tokenizer\n        self.tokenizer_mode = tokenizer_mode\n        self.trust_remote_code = trust_remote_code\n        self.seed = seed\n        self.revision = revision\n        self.code_revision = code_revision\n        self.rope_scaling = rope_scaling\n        self.rope_theta = rope_theta\n        # The tokenizer version is consistent with the model version by default.\n        if tokenizer_revision is None:\n            self.tokenizer_revision = revision\n        else:\n            self.tokenizer_revision = tokenizer_revision\n        self.quantization = quantization\n        self.quantization_param_path = quantization_param_path\n        self.enforce_eager = enforce_eager\n        if max_context_len_to_capture is not None:\n            raise ValueError(\"`max_context_len_to_capture` is deprecated. \"\n                             \"Use `max_seq_len_to_capture` instead.\")\n        self.max_seq_len_to_capture = max_seq_len_to_capture\n        self.max_logprobs = max_logprobs\n        self.disable_sliding_window = disable_sliding_window\n        self.skip_tokenizer_init = skip_tokenizer_init\n\n        self.hf_config = get_config(self.model, trust_remote_code, revision,\n                                    code_revision, rope_scaling, rope_theta)\n        self.hf_text_config = get_hf_text_config(self.hf_config)\n        self.dtype = _get_and_verify_dtype(self.hf_text_config, dtype)\n\n        if (not self.disable_sliding_window\n                and self.hf_text_config.model_type == \"gemma2\"\n                and self.hf_text_config.sliding_window is not None):\n            print_warning_once(\n                \"Gemma 2 uses sliding window attention for every odd layer, \"\n                \"which is currently not supported by vLLM. Disabling sliding \"\n                \"window and capping the max length to the sliding window size \"\n                f\"({self.hf_text_config.sliding_window}).\")\n            self.disable_sliding_window = True\n\n        self.max_model_len = _get_and_verify_max_len(\n            hf_config=self.hf_text_config,\n            max_model_len=max_model_len,\n            disable_sliding_window=self.disable_sliding_window,\n            sliding_window_len=self.get_hf_config_sliding_window())\n        self.served_model_name = get_served_model_name(model,\n                                                       served_model_name)\n        self.multimodal_config = multimodal_config\n\n        if not self.skip_tokenizer_init:\n            self._verify_tokenizer_mode()\n        self._verify_embedding_mode()\n        self._verify_quantization()\n        self._verify_cuda_graph()\n\n    def _verify_tokenizer_mode(self) -> None:\n        tokenizer_mode = self.tokenizer_mode.lower()\n        if tokenizer_mode not in [\"auto\", \"slow\"]:\n            raise ValueError(\n                f\"Unknown tokenizer mode: {self.tokenizer_mode}. Must be \"\n                \"either 'auto' or 'slow'.\")\n        self.tokenizer_mode = tokenizer_mode\n\n    def _verify_embedding_mode(self) -> None:\n        architectures = getattr(self.hf_config, \"architectures\", [])\n        self.embedding_mode = any(\n            ModelRegistry.is_embedding_model(arch) for arch in architectures)\n\n    def _parse_quant_hf_config(self):\n        quant_cfg = getattr(self.hf_config, \"quantization_config\", None)\n        if quant_cfg is None:\n            # compress-tensors uses a \"compression_config\" key\n            quant_cfg = getattr(self.hf_config, \"compression_config\", None)\n        return quant_cfg\n\n    def _verify_quantization(self) -> None:\n        supported_quantization = [*QUANTIZATION_METHODS]\n        rocm_supported_quantization = [\"gptq\", \"squeezellm\"]\n        if self.quantization is not None:\n            self.quantization = self.quantization.lower()\n\n        # Parse quantization method from the HF model config, if available.\n        quant_cfg = self._parse_quant_hf_config()\n\n        if quant_cfg is not None:\n            quant_method = quant_cfg.get(\"quant_method\", \"\").lower()\n\n            # Detect which checkpoint is it\n            for _, method in QUANTIZATION_METHODS.items():\n                quantization_override = method.override_quantization_method(\n                    quant_cfg, self.quantization)\n                if quantization_override:\n                    quant_method = quantization_override\n                    self.quantization = quantization_override\n                    break\n\n            # Verify quantization configurations.\n            if self.quantization is None:\n                self.quantization = quant_method\n            elif self.quantization != quant_method:\n                raise ValueError(\n                    \"Quantization method specified in the model config \"\n                    f\"({quant_method}) does not match the quantization \"\n                    f\"method specified in the `quantization` argument \"\n                    f\"({self.quantization}).\")\n\n        if self.quantization is not None:\n            if self.quantization not in supported_quantization:\n                raise ValueError(\n                    f\"Unknown quantization method: {self.quantization}. Must \"\n                    f\"be one of {supported_quantization}.\")\n            if is_hip(\n            ) and self.quantization not in rocm_supported_quantization:\n                raise ValueError(\n                    f\"{self.quantization} quantization is currently not \"\n                    f\"supported in ROCm.\")\n            if (self.quantization\n                    not in (\"fp8\", \"marlin\", \"gptq_marlin_24\", \"gptq_marlin\",\n                            \"awq_marlin\", \"fbgemm_fp8\", \"compressed_tensors\")):\n                logger.warning(\n                    \"%s quantization is not fully \"\n                    \"optimized yet. The speed can be slower than \"\n                    \"non-quantized models.\", self.quantization)\n\n    def _verify_cuda_graph(self) -> None:\n        if self.max_seq_len_to_capture is None:\n            self.max_seq_len_to_capture = self.max_model_len\n        self.max_seq_len_to_capture = min(self.max_seq_len_to_capture,\n                                          self.max_model_len)\n\n    def verify_with_parallel_config(\n        self,\n        parallel_config: \"ParallelConfig\",\n    ) -> None:\n        total_num_attention_heads = getattr(self.hf_text_config,\n                                            \"num_attention_heads\", 0)\n        tensor_parallel_size = parallel_config.tensor_parallel_size\n        if total_num_attention_heads % tensor_parallel_size != 0:\n            raise ValueError(\n                f\"Total number of attention heads ({total_num_attention_heads})\"\n                \" must be divisible by tensor parallel size \"\n                f\"({tensor_parallel_size}).\")\n\n        pipeline_parallel_size = parallel_config.pipeline_parallel_size\n        architectures = getattr(self.hf_config, \"architectures\", [])\n        if not all(arch in _PP_SUPPORTED_MODELS\n                   for arch in architectures) and pipeline_parallel_size > 1:\n            raise NotImplementedError(\n                \"Pipeline parallelism is only supported for the following \"\n                f\" architectures: {_PP_SUPPORTED_MODELS}.\")\n\n        if self.quantization == \"bitsandbytes\" and (\n                parallel_config.tensor_parallel_size > 1\n                or parallel_config.pipeline_parallel_size > 1):\n            raise ValueError(\n                \"BitAndBytes quantization with TP or PP is not supported yet.\")\n\n        if self.quantization == \"bitsandbytes\" and self.enforce_eager is False:\n            raise ValueError(\n                \"BitAndBytes with enforce_eager = False is not supported yet.\")\n\n    def get_hf_config_sliding_window(self) -> Optional[int]:\n        \"\"\"Get the sliding window size, or None if disabled.\"\"\"\n\n        # Some models, like Qwen2 and Qwen1.5, use `use_sliding_window` in\n        # addition to sliding window size. We check if that field is present\n        # and if it's False, return None.\n        if (hasattr(self.hf_text_config, \"use_sliding_window\")\n                and not self.hf_text_config.use_sliding_window):\n            return None\n        return getattr(self.hf_text_config, \"sliding_window\", None)\n\n    def get_sliding_window(self) -> Optional[int]:\n        \"\"\"Get the sliding window size, or None if disabled.\n        \"\"\"\n        # If user disables sliding window, return None.\n        if self.disable_sliding_window:\n            return None\n        # Otherwise get the value from the hf config.\n        return self.get_hf_config_sliding_window()\n\n    def get_vocab_size(self) -> int:\n        return self.hf_text_config.vocab_size\n\n    def get_hidden_size(self) -> int:\n        return self.hf_text_config.hidden_size\n\n    def get_head_size(self) -> int:\n        # TODO remove hard code\n        if hasattr(self.hf_text_config, \"model_type\"\n                   ) and self.hf_text_config.model_type == 'deepseek_v2':\n            # FlashAttention supports only head_size 32, 64, 128, 256,\n            # we need to pad head_size 192 to 256\n            return 256\n        if hasattr(self.hf_text_config, \"head_dim\"):\n            return self.hf_text_config.head_dim\n        # FIXME(woosuk): This may not be true for all models.\n        return (self.hf_text_config.hidden_size //\n                self.hf_text_config.num_attention_heads)\n\n    def get_total_num_kv_heads(self) -> int:\n        \"\"\"Returns the total number of KV heads.\"\"\"\n        # For GPTBigCode & Falcon:\n        # NOTE: for falcon, when new_decoder_architecture is True, the\n        # multi_query flag is ignored and we use n_head_kv for the number of\n        # KV heads.\n        falcon_model_types = [\"falcon\", \"RefinedWeb\", \"RefinedWebModel\"]\n        new_decoder_arch_falcon = (\n            self.hf_config.model_type in falcon_model_types\n            and getattr(self.hf_config, \"new_decoder_architecture\", False))\n        if not new_decoder_arch_falcon and getattr(self.hf_text_config,\n                                                   \"multi_query\", False):\n            # Multi-query attention, only one KV head.\n            # Currently, tensor parallelism is not supported in this case.\n            return 1\n\n        # For DBRX and MPT\n        if self.hf_config.model_type == \"mpt\":\n            if \"kv_n_heads\" in self.hf_config.attn_config:\n                return self.hf_config.attn_config[\"kv_n_heads\"]\n            return self.hf_config.num_attention_heads\n        if self.hf_config.model_type == \"dbrx\":\n            return getattr(self.hf_config.attn_config, \"kv_n_heads\",\n                           self.hf_config.num_attention_heads)\n\n        attributes = [\n            # For Falcon:\n            \"n_head_kv\",\n            \"num_kv_heads\",\n            # For LLaMA-2:\n            \"num_key_value_heads\",\n            # For ChatGLM:\n            \"multi_query_group_num\",\n        ]\n        for attr in attributes:\n            num_kv_heads = getattr(self.hf_text_config, attr, None)\n            if num_kv_heads is not None:\n                return num_kv_heads\n\n        # For non-grouped-query attention models, the number of KV heads is\n        # equal to the number of attention heads.\n        return self.hf_text_config.num_attention_heads\n\n    def get_num_kv_heads(self, parallel_config: \"ParallelConfig\") -> int:\n        \"\"\"Returns the number of KV heads per GPU.\"\"\"\n        total_num_kv_heads = self.get_total_num_kv_heads()\n        # If tensor parallelism is used, we divide the number of KV heads by\n        # the tensor parallel size. We will replicate the KV heads in the\n        # case where the number of KV heads is smaller than the tensor\n        # parallel size so each GPU has at least one KV head.\n        return max(1,\n                   total_num_kv_heads // parallel_config.tensor_parallel_size)\n\n    def get_num_attention_heads(self,\n                                parallel_config: \"ParallelConfig\") -> int:\n        num_heads = getattr(self.hf_text_config, \"num_attention_heads\", 0)\n        return num_heads // parallel_config.tensor_parallel_size\n\n    def get_num_layers(self, parallel_config: \"ParallelConfig\") -> int:\n        from vllm.distributed.utils import get_pp_indices\n        total_num_hidden_layers = getattr(self.hf_text_config,\n                                          \"num_hidden_layers\", 0)\n        pp_rank = parallel_config.rank // parallel_config.tensor_parallel_size\n        pp_size = parallel_config.pipeline_parallel_size\n        start, end = get_pp_indices(total_num_hidden_layers, pp_rank, pp_size)\n        return end - start\n\n    def contains_seqlen_agnostic_layers(\n            self, parallel_config: \"ParallelConfig\") -> bool:\n        \"\"\"True for Mamba/SSM models (Jamba)\"\"\"\n        return self._get_num_seqlen_agnostic_layers(parallel_config) > 0\n\n    def get_layers_block_type(self,\n                              parallel_config: \"ParallelConfig\") -> List[str]:\n        num_layers = self.get_num_layers(parallel_config)\n        # Transformers supports layers_block_type @property\n        return getattr(self.hf_config, \"layers_block_type\",\n                       [\"attention\"] * num_layers)\n\n    def get_num_attention_layers(self,\n                                 parallel_config: \"ParallelConfig\") -> int:\n        return len([\n            t for t in self.get_layers_block_type(parallel_config)\n            if t == \"attention\"\n        ])\n\n    def _get_num_seqlen_agnostic_layers(\n            self, parallel_config: \"ParallelConfig\") -> int:\n        return len([\n            t for t in self.get_layers_block_type(parallel_config)\n            if t != \"attention\"\n        ])\n\n\nclass CacheConfig:\n    \"\"\"Configuration for the KV cache.\n\n    Args:\n        block_size: Size of a cache block in number of tokens.\n        gpu_memory_utilization: Fraction of GPU memory to use for the\n            vLLM execution.\n        swap_space: Size of the CPU swap space per GPU (in GiB).\n        cache_dtype: Data type for kv cache storage.\n        num_gpu_blocks_override: Number of GPU blocks to use. This overrides the\n            profiled num_gpu_blocks if specified. Does nothing if None.\n    \"\"\"\n\n    def __init__(\n        self,\n        block_size: int,\n        gpu_memory_utilization: float,\n        swap_space: int,\n        cache_dtype: str,\n        num_gpu_blocks_override: Optional[int] = None,\n        sliding_window: Optional[int] = None,\n        enable_prefix_caching: bool = False,\n        cpu_offload_gb: float = 0,\n    ) -> None:\n        self.block_size = block_size\n        self.gpu_memory_utilization = gpu_memory_utilization\n        self.swap_space_bytes = swap_space * _GB\n        self.num_gpu_blocks_override = num_gpu_blocks_override\n        self.cache_dtype = cache_dtype\n        self.sliding_window = sliding_window\n        self.enable_prefix_caching = enable_prefix_caching\n        self.cpu_offload_gb = cpu_offload_gb\n        self._verify_args()\n        self._verify_cache_dtype()\n        self._verify_prefix_caching()\n\n        # Will be set after profiling.\n        self.num_gpu_blocks = None\n        self.num_cpu_blocks = None\n\n    def metrics_info(self):\n        # convert cache_config to dict(key: str, value: str) for prometheus\n        # metrics info\n        return {key: str(value) for key, value in self.__dict__.items()}\n\n    def _verify_args(self) -> None:\n        if self.gpu_memory_utilization > 1.0:\n            raise ValueError(\n                \"GPU memory utilization must be less than 1.0. Got \"\n                f\"{self.gpu_memory_utilization}.\")\n\n    def _verify_cache_dtype(self) -> None:\n        if self.cache_dtype == \"auto\":\n            pass\n        elif self.cache_dtype in (\"fp8\", \"fp8_e4m3\", \"fp8_e5m2\"):\n            logger.info(\n                \"Using fp8 data type to store kv cache. It reduces the GPU \"\n                \"memory footprint and boosts the performance. \"\n                \"Meanwhile, it may cause accuracy drop without a proper \"\n                \"scaling factor\")\n        else:\n            raise ValueError(f\"Unknown kv cache dtype: {self.cache_dtype}\")\n\n    def _verify_prefix_caching(self) -> None:\n        if not self.enable_prefix_caching:\n            return\n\n        if self.sliding_window is not None:\n            raise NotImplementedError(\n                \"Prefix caching is not supported with sliding window. \"\n                \"Run with --disable-sliding-window to use prefix caching.\")\n        if self.cache_dtype == \"fp8\":\n            raise NotImplementedError(\n                \"Prefix caching is not supported for fp8 cache_dtype. \"\n                \"Run with --kv-cache-dtype auto to use prefix caching.\")\n\n    def verify_with_parallel_config(\n        self,\n        parallel_config: \"ParallelConfig\",\n    ) -> None:\n        total_cpu_memory = get_cpu_memory()\n        # FIXME(woosuk): Here, it is assumed that the GPUs in a tensor parallel\n        # group are in the same node. However, the GPUs may span multiple nodes.\n        num_gpus_per_node = parallel_config.tensor_parallel_size\n        cpu_memory_usage = self.swap_space_bytes * num_gpus_per_node\n\n        msg = (f\"{cpu_memory_usage / _GB:.2f} GiB out of \"\n               f\"the {total_cpu_memory / _GB:.2f} GiB total CPU memory is \"\n               \"allocated for the swap space.\")\n        if cpu_memory_usage > 0.7 * total_cpu_memory:\n            raise ValueError(\"Too large swap space. \" + msg)\n        elif cpu_memory_usage > 0.4 * total_cpu_memory:\n            logger.warning(\"Possibly too large swap space. %s\", msg)\n\n\n@dataclass\nclass TokenizerPoolConfig:\n    \"\"\"Configuration for the tokenizer pool.\n\n    Args:\n        pool_size: Number of tokenizer workers in the pool.\n        pool_type: Type of the pool.\n        extra_config: Additional config for the pool.\n            The way the config will be used depends on the\n            pool type.\n    \"\"\"\n    pool_size: int\n    pool_type: Union[str, Type[\"BaseTokenizerGroup\"]]\n    extra_config: dict\n\n    def __post_init__(self):\n        if self.pool_type not in (\"ray\", ) and not isinstance(\n                self.pool_type, type):\n            raise ValueError(f\"Unknown pool type: {self.pool_type}\")\n        if not isinstance(self.extra_config, dict):\n            raise ValueError(\"extra_config must be a dictionary.\")\n\n    @classmethod\n    def create_config(\n        cls, tokenizer_pool_size: int, tokenizer_pool_type: str,\n        tokenizer_pool_extra_config: Optional[Union[str, dict]]\n    ) -> Optional[\"TokenizerPoolConfig\"]:\n        \"\"\"Create a TokenizerPoolConfig from the given parameters.\n\n        If tokenizer_pool_size is 0, return None.\n\n        Args:\n            tokenizer_pool_size: Number of tokenizer workers in the pool.\n            tokenizer_pool_type: Type of the pool.\n            tokenizer_pool_extra_config: Additional config for the pool.\n                The way the config will be used depends on the\n                pool type. This can be a JSON string (will be parsed).\n        \"\"\"\n        if tokenizer_pool_size:\n            if isinstance(tokenizer_pool_extra_config, str):\n                tokenizer_pool_extra_config_parsed = json.loads(\n                    tokenizer_pool_extra_config)\n            else:\n                tokenizer_pool_extra_config_parsed = (\n                    tokenizer_pool_extra_config or {})\n            tokenizer_pool_config = cls(tokenizer_pool_size,\n                                        tokenizer_pool_type,\n                                        tokenizer_pool_extra_config_parsed)\n        else:\n            tokenizer_pool_config = None\n        return tokenizer_pool_config\n\n\nclass LoadFormat(str, enum.Enum):\n    AUTO = \"auto\"\n    PT = \"pt\"\n    SAFETENSORS = \"safetensors\"\n    NPCACHE = \"npcache\"\n    DUMMY = \"dummy\"\n    TENSORIZER = \"tensorizer\"\n    SHARDED_STATE = \"sharded_state\"\n    BITSANDBYTES = \"bitsandbytes\"\n\n\n@dataclass\nclass LoadConfig:\n    \"\"\"\n        download_dir: Directory to download and load the weights, default to the\n            default cache directory of huggingface.\n        load_format: The format of the model weights to load:\n            \"auto\" will try to load the weights in the safetensors format and\n                fall back to the pytorch bin format if safetensors format is\n                not available.\n            \"pt\" will load the weights in the pytorch bin format.\n            \"safetensors\" will load the weights in the safetensors format.\n            \"npcache\" will load the weights in pytorch format and store\n                a numpy cache to speed up the loading.\n            \"dummy\" will initialize the weights with random values, which is\n                mainly for profiling.\n            \"tensorizer\" will use CoreWeave's tensorizer library for\n                fast weight loading.\n            \"bitsandbytes\" will load nf4 type weights.\n        ignore_patterns: The list of patterns to ignore when loading the model.\n            Default to \"original/**/*\" to avoid repeated loading of llama's \n            checkpoints.\n            \n    \"\"\"\n\n    load_format: Union[str, LoadFormat, \"BaseModelLoader\"] = LoadFormat.AUTO\n    download_dir: Optional[str] = None\n    model_loader_extra_config: Optional[Union[str, dict]] = field(\n        default_factory=dict)\n    ignore_patterns: Optional[Union[List[str], str]] = None\n\n    def __post_init__(self):\n        model_loader_extra_config = self.model_loader_extra_config or {}\n        if isinstance(model_loader_extra_config, str):\n            self.model_loader_extra_config = json.loads(\n                model_loader_extra_config)\n        self._verify_load_format()\n\n        if self.ignore_patterns is not None and len(self.ignore_patterns) > 0:\n            logger.info(\n                \"Ignoring the following patterns when downloading weights: %s\",\n                self.ignore_patterns)\n        else:\n            self.ignore_patterns = [\"original/**/*\"]\n\n    def _verify_load_format(self) -> None:\n        if not isinstance(self.load_format, str):\n            return\n\n        load_format = self.load_format.lower()\n        self.load_format = LoadFormat(load_format)\n\n        rocm_not_supported_load_format: List[str] = []\n        if is_hip() and load_format in rocm_not_supported_load_format:\n            rocm_supported_load_format = [\n                f for f in LoadFormat.__members__\n                if (f not in rocm_not_supported_load_format)\n            ]\n            raise ValueError(\n                f\"load format '{load_format}' is not supported in ROCm. \"\n                f\"Supported load formats are \"\n                f\"{rocm_supported_load_format}\")\n\n\nclass ParallelConfig:\n    \"\"\"Configuration for the distributed execution.\n\n    Args:\n        pipeline_parallel_size: Number of pipeline parallel groups.\n        tensor_parallel_size: Number of tensor parallel groups.\n        worker_use_ray: Deprecated, use distributed_executor_backend instead.\n        max_parallel_loading_workers: Maximum number of multiple batches\n            when load model sequentially. To avoid RAM OOM when using tensor\n            parallel and large models.\n        disable_custom_all_reduce: Disable the custom all-reduce kernel and\n            fall back to NCCL.\n        tokenizer_pool_config: Config for the tokenizer pool.\n            If None, will use synchronous tokenization.\n        ray_workers_use_nsight: Whether to profile Ray workers with nsight, see\n            https://docs.ray.io/en/latest/ray-observability/user-guides/profiling.html#profiling-nsight-profiler.\n        placement_group: ray distributed model workers placement group.\n        distributed_executor_backend: Backend to use for distributed model\n            workers, either \"ray\" or \"mp\" (multiprocessing). If either\n            pipeline_parallel_size or tensor_parallel_size is greater than 1,\n            will default to \"ray\" if Ray is installed or \"mp\" otherwise.\n    \"\"\"\n\n    def __init__(\n        self,\n        pipeline_parallel_size: int,\n        tensor_parallel_size: int,\n        worker_use_ray: Optional[bool] = None,\n        max_parallel_loading_workers: Optional[int] = None,\n        disable_custom_all_reduce: bool = False,\n        tokenizer_pool_config: Optional[TokenizerPoolConfig] = None,\n        ray_workers_use_nsight: bool = False,\n        placement_group: Optional[\"PlacementGroup\"] = None,\n        distributed_executor_backend: Optional[Union[\n            str, Type[\"ExecutorBase\"]]] = None,\n    ) -> None:\n        self.pipeline_parallel_size = pipeline_parallel_size\n        self.tensor_parallel_size = tensor_parallel_size\n        self.distributed_executor_backend = distributed_executor_backend\n        self.max_parallel_loading_workers = max_parallel_loading_workers\n        self.disable_custom_all_reduce = disable_custom_all_reduce\n        self.tokenizer_pool_config = tokenizer_pool_config\n        self.ray_workers_use_nsight = ray_workers_use_nsight\n        self.placement_group = placement_group\n\n        self.world_size = pipeline_parallel_size * self.tensor_parallel_size\n        if worker_use_ray:\n            if self.distributed_executor_backend is None:\n                self.distributed_executor_backend = \"ray\"\n            elif not self.use_ray:\n                raise ValueError(f\"worker-use-ray can't be used with \"\n                                 f\"distributed executor backend \"\n                                 f\"'{self.distributed_executor_backend}'.\")\n\n        if self.distributed_executor_backend is None and self.world_size > 1:\n            # We use multiprocessing by default if world_size fits on the\n            # current node and we aren't in a ray placement group.\n\n            from vllm.executor import ray_utils\n            backend = \"mp\"\n            ray_found = ray_utils.ray_is_available()\n            if cuda_device_count_stateless() < self.world_size:\n                if not ray_found:\n                    raise ValueError(\"Unable to load Ray which is \"\n                                     \"required for multi-node inference, \"\n                                     \"please install Ray with `pip install \"\n                                     \"ray`.\") from ray_utils.ray_import_err\n                backend = \"ray\"\n            elif ray_found:\n                if self.placement_group:\n                    backend = \"ray\"\n                else:\n                    from ray import is_initialized as ray_is_initialized\n                    if ray_is_initialized():\n                        from ray.util import get_current_placement_group\n                        if get_current_placement_group():\n                            backend = \"ray\"\n            self.distributed_executor_backend = backend\n            logger.info(\"Defaulting to use %s for distributed inference\",\n                        backend)\n\n        self._verify_args()\n        self.rank: int = 0\n\n    @property\n    def use_ray(self) -> bool:\n        return self.distributed_executor_backend == \"ray\" or (\n            isinstance(self.distributed_executor_backend, type)\n            and self.distributed_executor_backend.uses_ray)\n\n    def _verify_args(self) -> None:\n        # Lazy import to avoid circular import\n        from vllm.executor.executor_base import ExecutorBase\n\n        if self.distributed_executor_backend not in (\n                \"ray\", \"mp\", None) and not (isinstance(\n                    self.distributed_executor_backend, type) and issubclass(\n                        self.distributed_executor_backend, ExecutorBase)):\n            raise ValueError(\n                \"Unrecognized distributed executor backend \"\n                f\"{self.distributed_executor_backend}. Supported \"\n                \"values are 'ray', 'mp' or custom ExecutorBase subclass.\")\n        if self.use_ray:\n            from vllm.executor import ray_utils\n            ray_utils.assert_ray_available()\n        if is_hip():\n            self.disable_custom_all_reduce = True\n            logger.info(\n                \"Disabled the custom all-reduce kernel because it is not \"\n                \"supported on AMD GPUs.\")\n        if self.ray_workers_use_nsight and not self.use_ray:\n            raise ValueError(\"Unable to use nsight profiling unless workers \"\n                             \"run with Ray.\")\n\n\nclass SchedulerConfig:\n    \"\"\"Scheduler configuration.\n\n    Args:\n        max_num_batched_tokens: Maximum number of tokens to be processed in\n            a single iteration.\n        max_num_seqs: Maximum number of sequences to be processed in a single\n            iteration.\n        max_model_len: Maximum length of a sequence (including prompt\n            and generated text).\n        use_v2_block_manager: Whether to use the BlockSpaceManagerV2 or not.\n        num_lookahead_slots: The number of slots to allocate per sequence per\n            step, beyond the known token ids. This is used in speculative\n            decoding to store KV activations of tokens which may or may not be\n            accepted.\n        delay_factor: Apply a delay (of delay factor multiplied by previous\n            prompt latency) before scheduling next prompt.\n        enable_chunked_prefill: If True, prefill requests can be chunked based\n            on the remaining max_num_batched_tokens.\n        embedding_mode: Whether the running model is for embedding.\n        preemption_mode: Whether to perform preemption by swapping or \n            recomputation. If not specified, we determine the mode as follows:\n            We use recomputation by default since it incurs lower overhead than\n            swapping. However, when the sequence group has multiple sequences\n            (e.g., beam search), recomputation is not currently supported. In\n            such a case, we use swapping instead.\n    \"\"\"\n\n    def __init__(self,\n                 max_num_batched_tokens: Optional[int],\n                 max_num_seqs: int,\n                 max_model_len: int,\n                 use_v2_block_manager: bool = False,\n                 num_lookahead_slots: int = 0,\n                 delay_factor: float = 0.0,\n                 enable_chunked_prefill: bool = False,\n                 embedding_mode: Optional[bool] = False,\n                 preemption_mode: Optional[str] = None) -> None:\n        if max_num_batched_tokens is not None:\n            self.max_num_batched_tokens = max_num_batched_tokens\n        else:\n            if enable_chunked_prefill:\n                # It is the values that have the best balance between ITL\n                # and TTFT on A100. Note it is not optimized for throughput.\n                self.max_num_batched_tokens = 512\n            elif embedding_mode:\n                # For embedding, choose specific value for higher throughput\n                self.max_num_batched_tokens = max(\n                    max_model_len, _EMBEDDING_MODEL_MAX_NUM_BATCHED_TOKENS)\n            else:\n                # If max_model_len is too short, use 2048 as the default value\n                # for higher throughput.\n                self.max_num_batched_tokens = max(max_model_len, 2048)\n        if enable_chunked_prefill:\n            logger.info(\n                \"Chunked prefill is enabled with max_num_batched_tokens=%d.\",\n                self.max_num_batched_tokens)\n\n        self.max_num_seqs = max_num_seqs\n        self.max_model_len = max_model_len\n        self.use_v2_block_manager = use_v2_block_manager\n        self.num_lookahead_slots = num_lookahead_slots\n        self.delay_factor = delay_factor\n        self.chunked_prefill_enabled = enable_chunked_prefill\n        self.embedding_mode = embedding_mode\n        self.preemption_mode = preemption_mode\n        self._verify_args()\n\n    def _verify_args(self) -> None:\n        if (self.max_num_batched_tokens < self.max_model_len\n                and not self.chunked_prefill_enabled):\n            raise ValueError(\n                f\"max_num_batched_tokens ({self.max_num_batched_tokens}) is \"\n                f\"smaller than max_model_len ({self.max_model_len}). \"\n                \"This effectively limits the maximum sequence length to \"\n                \"max_num_batched_tokens and makes vLLM reject longer \"\n                \"sequences. Please increase max_num_batched_tokens or \"\n                \"decrease max_model_len.\")\n\n        if self.max_num_batched_tokens < self.max_num_seqs:\n            raise ValueError(\n                f\"max_num_batched_tokens ({self.max_num_batched_tokens}) must \"\n                \"be greater than or equal to max_num_seqs \"\n                f\"({self.max_num_seqs}).\")\n\n        if self.num_lookahead_slots < 0:\n            raise ValueError(\n                \"num_lookahead_slots \"\n                f\"({self.num_lookahead_slots}) must be greater than or \"\n                \"equal to 0.\")\n\n\nclass DeviceConfig:\n    device: Optional[torch.device]\n\n    def __init__(self, device: str = \"auto\") -> None:\n        if device == \"auto\":\n            # Automated device type detection\n            if is_neuron():\n                self.device_type = \"neuron\"\n            elif is_openvino():\n                self.device_type = \"openvino\"\n            elif is_tpu():\n                self.device_type = \"tpu\"\n            elif is_cpu():\n                self.device_type = \"cpu\"\n            elif is_xpu():\n                self.device_type = \"xpu\"\n            else:\n                # We don't call torch.cuda.is_available() here to\n                # avoid initializing CUDA before workers are forked\n                self.device_type = \"cuda\"\n        else:\n            # Device type is assigned explicitly\n            self.device_type = device\n\n        # Some device types require processing inputs on CPU\n        if self.device_type in [\"neuron\", \"openvino\"]:\n            self.device = torch.device(\"cpu\")\n        elif self.device_type in [\"tpu\"]:\n            self.device = None\n        else:\n            # Set device with device type\n            self.device = torch.device(self.device_type)\n\n\nclass SpeculativeConfig:\n    \"\"\"Configuration for speculative decoding.\n\n    The configuration is currently specialized to draft-model speculative\n    decoding with top-1 proposals.\n    \"\"\"\n\n    @staticmethod\n    def maybe_create_spec_config(\n        target_model_config: ModelConfig,\n        target_parallel_config: ParallelConfig,\n        target_dtype: str,\n        speculative_model: Optional[str],\n        speculative_draft_tensor_parallel_size: Optional[int],\n        num_speculative_tokens: Optional[int],\n        speculative_max_model_len: Optional[int],\n        enable_chunked_prefill: bool,\n        use_v2_block_manager: bool,\n        speculative_disable_by_batch_size: Optional[int],\n        ngram_prompt_lookup_max: Optional[int],\n        ngram_prompt_lookup_min: Optional[int],\n        draft_token_acceptance_method: str,\n        typical_acceptance_sampler_posterior_threshold: Optional[float],\n        typical_acceptance_sampler_posterior_alpha: Optional[float],\n        disable_logprobs: Optional[bool],\n    ) -> Optional[\"SpeculativeConfig\"]:\n        \"\"\"Create a SpeculativeConfig if possible, else return None.\n\n        This function attempts to create a SpeculativeConfig object based on the\n        provided parameters. If the necessary conditions are met, it returns an\n        instance of SpeculativeConfig. Otherwise, it returns None.\n\n        Args:\n            target_model_config (ModelConfig): The configuration of the target\n                model.\n            target_parallel_config (ParallelConfig): The parallel configuration\n                for the target model.\n            target_dtype (str): The data type used for the target model.\n            speculative_model (Optional[str]): The name of the speculative\n                model, if provided.\n            speculative_draft_tensor_parallel_size (Optional[int]): The degree\n                of the tensor parallelism for the draft model.\n            num_speculative_tokens (Optional[int]): The number of speculative\n                tokens, if provided. Will default to the number in the draft\n                model config if present, otherwise is required.\n            speculative_max_model_len (Optional[int]): The maximum model len of\n                the speculative model. Used when testing the ability to skip\n                speculation for some sequences.\n            enable_chunked_prefill (bool): Whether vLLM is configured to use\n                chunked prefill or not. Used for raising an error since its not\n                yet compatible with spec decode.\n            use_v2_block_manager (bool): Whether vLLM is configured to use the\n                v2 block manager or not. Used for raising an error since the v2\n                block manager is required with spec decode.\n            speculative_disable_by_batch_size (Optional[int]): Disable\n                speculative decoding for new incoming requests when the number\n                of enqueue requests  is larger than this value, if provided.\n            ngram_prompt_lookup_max (Optional[int]): Max size of ngram token\n                window, if provided.\n            ngram_prompt_lookup_min (Optional[int]): Min size of ngram token\n                window, if provided.\n            draft_token_acceptance_method (str): The method to use for\n                accepting draft tokens. This can take two possible\n                values 'rejection_sampler' and 'typical_acceptance_sampler'\n                for RejectionSampler and TypicalAcceptanceSampler\n                respectively.\n            typical_acceptance_sampler_posterior_threshold (Optional[float]):\n                A threshold value that sets a lower bound on the posterior\n                probability of a token in the target model for it to be\n                accepted. This threshold is used only when we use the \n                TypicalAcceptanceSampler for token acceptance.\n            typical_acceptance_sampler_posterior_alpha (Optional[float]):\n                A scaling factor for the entropy-based threshold in the\n                TypicalAcceptanceSampler.\n            disable_logprobs (Optional[bool]): If set to True, token log\n                probabilities are not returned during speculative decoding.\n                If set to False, token log probabilities are returned\n                according to the log probability settings in SamplingParams.\n                If not specified, it defaults to True.\n    \n        Returns:\n            Optional[\"SpeculativeConfig\"]: An instance of SpeculativeConfig if\n                the necessary conditions are met, else None.\n        \"\"\"\n\n        if speculative_model is None:\n            if num_speculative_tokens is not None:\n                raise ValueError(\"num_speculative_tokens was provided without \"\n                                 \"speculative_model.\")\n            return None\n\n        if (speculative_disable_by_batch_size is not None\n                and speculative_disable_by_batch_size < 2):\n            raise ValueError(\"Expect the batch size threshold of disabling \"\n                             \"speculative decoding is > 1, but got \"\n                             f\"{speculative_disable_by_batch_size=}\")\n\n        if enable_chunked_prefill:\n            raise ValueError(\n                \"Speculative decoding and chunked prefill are \"\n                f\"currently mutually exclusive ({enable_chunked_prefill=}).\")\n\n        if not use_v2_block_manager:\n            raise ValueError(\n                \"Speculative decoding requires usage of the V2 \"\n                \"block manager. Enable it with --use-v2-block-manager.\")\n\n        # TODO: The user should be able to specify revision/quantization/max\n        # model len for the draft model. It is not currently supported.\n        draft_revision = None\n        draft_code_revision = None\n        draft_quantization = None\n\n        if speculative_model == \"[ngram]\":\n            if ngram_prompt_lookup_min is None:\n                ngram_prompt_lookup_min = 1\n            if ngram_prompt_lookup_max is None or ngram_prompt_lookup_max < 1:\n                raise ValueError(f\"{ngram_prompt_lookup_max=} must be > 0\")\n            if ngram_prompt_lookup_min < 1:\n                raise ValueError(f\"{ngram_prompt_lookup_min=} must be > 0\")\n            if ngram_prompt_lookup_min > ngram_prompt_lookup_max:\n                raise ValueError(f\"{ngram_prompt_lookup_min=} cannot be \"\n                                 f\"larger than {ngram_prompt_lookup_max=}\")\n\n            # TODO: current we still need extract vocab_size from target model\n            # config, in future, we may try refactor it out, and set\n            # draft related config as None here.\n            draft_model_config = target_model_config\n            draft_parallel_config = target_parallel_config\n        else:\n            ngram_prompt_lookup_max = 0\n            ngram_prompt_lookup_min = 0\n            draft_model_config = ModelConfig(\n                model=speculative_model,\n                tokenizer=target_model_config.tokenizer,\n                tokenizer_mode=target_model_config.tokenizer_mode,\n                trust_remote_code=target_model_config.trust_remote_code,\n                dtype=target_model_config.dtype,\n                seed=target_model_config.seed,\n                revision=draft_revision,\n                code_revision=draft_code_revision,\n                tokenizer_revision=target_model_config.tokenizer_revision,\n                max_model_len=None,\n                quantization=draft_quantization,\n                enforce_eager=target_model_config.enforce_eager,\n                max_seq_len_to_capture=target_model_config.\n                max_seq_len_to_capture,\n                max_logprobs=target_model_config.max_logprobs,\n            )\n\n            draft_hf_config = draft_model_config.hf_config\n\n            if (num_speculative_tokens is not None\n                    and hasattr(draft_hf_config, \"num_lookahead_tokens\")):\n                draft_hf_config.num_lookahead_tokens = num_speculative_tokens\n\n            n_predict = getattr(draft_hf_config, \"n_predict\", None)\n            if n_predict is not None:\n                if num_speculative_tokens is None:\n                    # Default to max value defined in draft model config.\n                    num_speculative_tokens = n_predict\n                elif num_speculative_tokens > n_predict:\n                    # Verify provided value doesn't exceed the maximum\n                    # supported by the draft model.\n                    raise ValueError(\n                        \"This speculative model supports a maximum of \"\n                        f\"num_speculative_tokens={n_predict}, but \"\n                        f\"{num_speculative_tokens=} was provided.\")\n\n            draft_model_config.max_model_len = (\n                SpeculativeConfig._maybe_override_draft_max_model_len(\n                    speculative_max_model_len,\n                    draft_model_config.max_model_len,\n                    target_model_config.max_model_len,\n                ))\n\n            draft_parallel_config = (\n                SpeculativeConfig.create_draft_parallel_config(\n                    target_parallel_config,\n                    speculative_draft_tensor_parallel_size))\n\n        if num_speculative_tokens is None:\n            raise ValueError(\n                \"num_speculative_tokens must be provided with \"\n                \"speculative_model unless the draft model config contains an \"\n                \"n_predict parameter.\")\n\n        if typical_acceptance_sampler_posterior_threshold is None:\n            typical_acceptance_sampler_posterior_threshold = 0.09\n        if typical_acceptance_sampler_posterior_alpha is None:\n            typical_acceptance_sampler_posterior_alpha = 0.3\n        if disable_logprobs is None:\n            disable_logprobs = True\n\n        return SpeculativeConfig(\n            draft_model_config,\n            draft_parallel_config,\n            num_speculative_tokens,\n            speculative_disable_by_batch_size,\n            ngram_prompt_lookup_max,\n            ngram_prompt_lookup_min,\n            draft_token_acceptance_method=draft_token_acceptance_method,\n            typical_acceptance_sampler_posterior_threshold=\\\n                typical_acceptance_sampler_posterior_threshold,\n            typical_acceptance_sampler_posterior_alpha=\\\n                typical_acceptance_sampler_posterior_alpha,\n            disable_logprobs=disable_logprobs\n        )\n\n    @staticmethod\n    def _maybe_override_draft_max_model_len(\n        speculative_max_model_len: Optional[int],\n        draft_max_model_len: int,\n        target_max_model_len: int,\n    ) -> int:\n        \"\"\"Determine the max sequence len for the draft model. This is usually\n        the draft_max_model_len, but may be the target_max_model_len if it is\n        less than the draft_max_model_len, or may be speculative_max_model_len\n        if it is specified.\n\n        This is necessary so that sequences do not exceed the capacity of the\n        draft model or the target model.\n\n        speculative_max_model_len is mainly used for testing that sequences can\n        skip speculation.\n        \"\"\"\n\n        if speculative_max_model_len is not None:\n\n            if speculative_max_model_len > draft_max_model_len:\n                raise ValueError(f\"{speculative_max_model_len=} cannot be \"\n                                 f\"larger than {draft_max_model_len=}\")\n\n            if speculative_max_model_len > target_max_model_len:\n                raise ValueError(f\"{speculative_max_model_len=} cannot be \"\n                                 f\"larger than {target_max_model_len=}\")\n\n            return speculative_max_model_len\n\n        return min(\n            draft_max_model_len,\n            target_max_model_len,\n        )\n\n    @staticmethod\n    def create_draft_parallel_config(\n        target_parallel_config: ParallelConfig,\n        speculative_draft_tensor_parallel_size: Optional[int]\n    ) -> ParallelConfig:\n        \"\"\"Create a parallel config for use by the draft worker.\n\n        This is mostly a copy of the target parallel config, except the tp_size.\n        \"\"\"\n        if speculative_draft_tensor_parallel_size is None:\n            speculative_draft_tensor_parallel_size = \\\n                  target_parallel_config.tensor_parallel_size\n        elif speculative_draft_tensor_parallel_size != 1:\n            # TODO(wooyeon): allow tp values larger than 1\n            raise ValueError(\n                f\"{speculative_draft_tensor_parallel_size=} cannot be\"\n                f\"other value than 1\")\n\n        draft_parallel_config = ParallelConfig(\n            pipeline_parallel_size=target_parallel_config.\n            pipeline_parallel_size,\n            tensor_parallel_size=speculative_draft_tensor_parallel_size,\n            distributed_executor_backend=target_parallel_config.\n            distributed_executor_backend,\n            max_parallel_loading_workers=target_parallel_config.\n            max_parallel_loading_workers,\n            disable_custom_all_reduce=target_parallel_config.\n            disable_custom_all_reduce,\n            tokenizer_pool_config=target_parallel_config.tokenizer_pool_config,\n            ray_workers_use_nsight=target_parallel_config.\n            ray_workers_use_nsight,\n            placement_group=target_parallel_config.placement_group,\n        )\n\n        return draft_parallel_config\n\n    def __init__(\n        self,\n        draft_model_config: ModelConfig,\n        draft_parallel_config: ParallelConfig,\n        num_speculative_tokens: int,\n        speculative_disable_by_batch_size: Optional[int],\n        ngram_prompt_lookup_max: Optional[int],\n        ngram_prompt_lookup_min: Optional[int],\n        draft_token_acceptance_method: str,\n        typical_acceptance_sampler_posterior_threshold: float,\n        typical_acceptance_sampler_posterior_alpha: float,\n        disable_logprobs: bool,\n    ):\n        \"\"\"Create a SpeculativeConfig object.\n\n        Args:\n            draft_model_config: ModelConfig for the draft model.\n            draft_parallel_config: ParallelConfig for the draft model.\n            num_speculative_tokens: The number of tokens to sample from the\n                draft model before scoring with the target model.\n            speculative_disable_by_batch_size: Disable speculative\n                decoding for new incoming requests when the number of\n                enqueue requests is larger than this value.\n            ngram_prompt_lookup_max: Max size of ngram token window.\n            ngram_prompt_lookup_min: Min size of ngram token window.\n            draft_token_acceptance_method (str): The method to use for\n                accepting draft tokens. This can take two possible\n                values 'rejection_sampler' and 'typical_acceptance_sampler'\n                for RejectionSampler and TypicalAcceptanceSampler\n                respectively.\n            typical_acceptance_sampler_posterior_threshold (Optional[float]):\n                A threshold value that sets a lower bound on the posterior\n                probability of a token in the target model for it to be\n                accepted. This threshold is used only when we use the \n                TypicalAcceptanceSampler for token acceptance.\n            typical_acceptance_sampler_posterior_alpha (Optional[float]):\n                A scaling factor for the entropy-based threshold in the\n                TypicalAcceptanceSampler.\n            disable_logprobs: If set to True, token log probabilities will not\n                be returned even if requested by sampling parameters. This \n                reduces latency by skipping logprob calculation in proposal\n                sampling, target sampling, and after accepted tokens are\n                determined. If set to False, log probabilities will be\n                returned.\n        \"\"\"\n        self.draft_model_config = draft_model_config\n        self.draft_parallel_config = draft_parallel_config\n        self.num_speculative_tokens = num_speculative_tokens\n        self.speculative_disable_by_batch_size = \\\n            speculative_disable_by_batch_size\n        self.ngram_prompt_lookup_max = ngram_prompt_lookup_max or 0\n        self.ngram_prompt_lookup_min = ngram_prompt_lookup_min or 0\n        self.draft_token_acceptance_method = draft_token_acceptance_method\n        self.typical_acceptance_sampler_posterior_threshold = \\\n            typical_acceptance_sampler_posterior_threshold\n        self.typical_acceptance_sampler_posterior_alpha = \\\n            typical_acceptance_sampler_posterior_alpha\n        self.disable_logprobs = disable_logprobs\n\n        self._verify_args()\n\n    def _verify_args(self) -> None:\n        if self.num_speculative_tokens <= 0:\n            raise ValueError(\"Expected num_speculative_tokens to be greater \"\n                             f\"than zero ({self.num_speculative_tokens}).\")\n\n        if self.draft_model_config:\n            self.draft_model_config.verify_with_parallel_config(\n                self.draft_parallel_config)\n            # Validate and set draft token acceptance related settings.\n\n        if (self.draft_token_acceptance_method is None):\n            raise ValueError(\"draft_token_acceptance_method is not set. \"\n                             \"Expected values are rejection_sampler or \"\n                             \"typical_acceptance_sampler.\")\n\n        if (self.draft_token_acceptance_method != 'rejection_sampler'\n                and self.draft_token_acceptance_method !=\n                'typical_acceptance_sampler'):\n            raise ValueError(\n                \"Expected draft_token_acceptance_method to be either \"\n                \"rejection_sampler or typical_acceptance_sampler. Instead it \"\n                f\"is {self.draft_token_acceptance_method}\")\n\n        if (self.typical_acceptance_sampler_posterior_threshold < 0\n                or self.typical_acceptance_sampler_posterior_alpha < 0):\n            raise ValueError(\n                \"Expected typical_acceptance_sampler_posterior_threshold \"\n                \"and typical_acceptance_sampler_posterior_alpha to be > 0. \"\n                \"Instead found \"\n                f\"typical_acceptance_sampler_posterior_threshold = \"\n                f\"{self.typical_acceptance_sampler_posterior_threshold} and \"\n                f\"typical_acceptance_sampler_posterior_alpha = \"\n                f\"{self.typical_acceptance_sampler_posterior_alpha}\")\n\n    @property\n    def num_lookahead_slots(self) -> int:\n        \"\"\"The number of additional slots the scheduler should allocate per\n        step, in addition to the slots allocated for each known token.\n\n        This is equal to the number of speculative tokens, as each speculative\n        token must be scored.\n        \"\"\"\n        return self.num_speculative_tokens\n\n    def __repr__(self) -> str:\n        if self.ngram_prompt_lookup_max > 0:\n            draft_model = \"[ngram]\"\n        else:\n            draft_model = self.draft_model_config.model\n        num_spec_tokens = self.num_speculative_tokens\n        return f\"SpeculativeConfig({draft_model=}, {num_spec_tokens=})\"\n\n\n@dataclass\nclass LoRAConfig:\n    max_lora_rank: int\n    max_loras: int\n    fully_sharded_loras: bool = False\n    max_cpu_loras: Optional[int] = None\n    lora_dtype: Optional[torch.dtype] = None\n    lora_extra_vocab_size: int = 256\n    # This is a constant.\n    lora_vocab_padding_size: ClassVar[int] = 256\n    long_lora_scaling_factors: Optional[Tuple[float]] = None\n\n    def __post_init__(self):\n        # Keep this in sync with csrc/punica/bgmv/bgmv_config.h\n        possible_max_ranks = (8, 16, 32, 64)\n        possible_lora_extra_vocab_size = (0, 256, 512)\n        if self.max_lora_rank not in possible_max_ranks:\n            raise ValueError(\n                f\"max_lora_rank ({self.max_lora_rank}) must be one of \"\n                f\"{possible_max_ranks}.\")\n        if self.lora_extra_vocab_size not in possible_lora_extra_vocab_size:\n            raise ValueError(\n                f\"lora_extra_vocab_size ({self.lora_extra_vocab_size}) \"\n                f\"must be one of {possible_lora_extra_vocab_size}.\")\n        if self.max_loras < 1:\n            raise ValueError(f\"max_loras ({self.max_loras}) must be >= 1.\")\n        if self.max_cpu_loras is None:\n            self.max_cpu_loras = self.max_loras\n        elif self.max_cpu_loras < self.max_loras:\n            raise ValueError(\n                f\"max_cpu_loras ({self.max_cpu_loras}) must be >= \"\n                f\"max_loras ({self.max_loras})\")\n\n    def verify_with_model_config(self, model_config: ModelConfig):\n        if self.lora_dtype in (None, \"auto\"):\n            self.lora_dtype = model_config.dtype\n        elif isinstance(self.lora_dtype, str):\n            self.lora_dtype = getattr(torch, self.lora_dtype)\n        if model_config.quantization and model_config.quantization not in [\n                \"awq\", \"gptq\"\n        ]:\n            # TODO support marlin and squeezellm\n            logger.warning(\"%s quantization is not tested with LoRA yet.\",\n                           model_config.quantization)\n\n    def verify_with_scheduler_config(self, scheduler_config: SchedulerConfig):\n        if scheduler_config.max_num_batched_tokens > 65528:\n            raise ValueError(\n                \"Due to limitations of the custom LoRA CUDA kernel, \"\n                \"max_num_batched_tokens must be <= 65528 when \"\n                \"LoRA is enabled.\")\n        if scheduler_config.chunked_prefill_enabled:\n            raise ValueError(\"LoRA is not supported with chunked prefill yet.\")\n\n\n@dataclass\nclass PromptAdapterConfig:\n    max_prompt_adapters: int\n    max_prompt_adapter_token: int\n    max_cpu_prompt_adapters: Optional[int] = None\n    prompt_adapter_dtype: Optional[torch.dtype] = None\n\n    def __post_init__(self):\n        library_name = 'peft'\n        try:\n            __import__(library_name)\n        except ImportError as e:\n            raise ImportError(\n                f\"'{library_name}' is not installed for prompt adapter support.\"\n                f\"Please install it using 'pip install {library_name}'.\"\n            ) from e\n\n        if self.max_prompt_adapters < 1:\n            raise ValueError(f\"max_prompt_adapters \"\n                             f\"({self.max_prompt_adapters}) must be >= 1.\")\n        if self.max_prompt_adapter_token == 0:\n            raise ValueError(\"max_prompt_adapter_token must be set.\")\n        if self.max_cpu_prompt_adapters is None:\n            self.max_cpu_prompt_adapters = self.max_prompt_adapters\n\n    def verify_with_model_config(self, model_config: ModelConfig):\n        if self.prompt_adapter_dtype in (None, \"auto\"):\n            self.prompt_adapter_dtype = model_config.dtype\n        elif isinstance(self.prompt_adapter_dtype, str):\n            self.prompt_adapter_dtype = getattr(torch,\n                                                self.prompt_adapter_dtype)\n\n\n@dataclass\nclass MultiModalConfig:\n    \"\"\"Configs the input data format and how models should run for\n    multimodal models.\"\"\"\n    # TODO: Add configs to init vision tower or not.\n    pass\n\n\n_STR_DTYPE_TO_TORCH_DTYPE = {\n    \"half\": torch.float16,\n    \"float16\": torch.float16,\n    \"float\": torch.float32,\n    \"float32\": torch.float32,\n    \"bfloat16\": torch.bfloat16,\n}\n\n_ROCM_NOT_SUPPORTED_DTYPE: List[str] = []  #\n\n\ndef _get_and_verify_dtype(\n    config: PretrainedConfig,\n    dtype: Union[str, torch.dtype],\n) -> torch.dtype:\n    # NOTE: getattr(config, \"torch_dtype\", torch.float32) is not correct\n    # because config.torch_dtype can be None.\n    config_dtype = getattr(config, \"torch_dtype\", None)\n    if config_dtype is None:\n        config_dtype = torch.float32\n\n    if isinstance(dtype, str):\n        dtype = dtype.lower()\n        if dtype == \"auto\":\n            if config_dtype == torch.float32:\n                if config.model_type == \"gemma2\":\n                    logger.info(\n                        \"For Gemma 2, we downcast float32 to bfloat16 instead \"\n                        \"of float16 by default. Please specify `dtype` if you \"\n                        \"want to use float16.\")\n                    torch_dtype = torch.bfloat16\n                else:\n                    # Following the common practice, we use float16 for float32\n                    # models.\n                    torch_dtype = torch.float16\n            else:\n                torch_dtype = config_dtype\n        else:\n            if dtype not in _STR_DTYPE_TO_TORCH_DTYPE:\n                raise ValueError(f\"Unknown dtype: {dtype}\")\n            torch_dtype = _STR_DTYPE_TO_TORCH_DTYPE[dtype]\n    elif isinstance(dtype, torch.dtype):\n        torch_dtype = dtype\n    else:\n        raise ValueError(f\"Unknown dtype: {dtype}\")\n\n    # Verify the dtype.\n    if torch_dtype != config_dtype:\n        if torch_dtype == torch.float32:\n            # Upcasting to float32 is allowed.\n            logger.info(\"Upcasting %s to %s.\", config_dtype, torch_dtype)\n            pass\n        elif config_dtype == torch.float32:\n            # Downcasting from float32 to float16 or bfloat16 is allowed.\n            logger.info(\"Downcasting %s to %s.\", config_dtype, torch_dtype)\n            pass\n        else:\n            # Casting between float16 and bfloat16 is allowed with a warning.\n            logger.warning(\"Casting %s to %s.\", config_dtype, torch_dtype)\n\n    return torch_dtype\n\n\ndef _get_and_verify_max_len(\n    hf_config: PretrainedConfig,\n    max_model_len: Optional[int],\n    disable_sliding_window: bool,\n    sliding_window_len: Optional[int],\n) -> int:\n    \"\"\"Get and verify the model's maximum length.\"\"\"\n    derived_max_model_len = float(\"inf\")\n    possible_keys = [\n        # OPT\n        \"max_position_embeddings\",\n        # GPT-2\n        \"n_positions\",\n        # MPT\n        \"max_seq_len\",\n        # ChatGLM2\n        \"seq_length\",\n        # Command-R\n        \"model_max_length\",\n        # Others\n        \"max_sequence_length\",\n        \"max_seq_length\",\n        \"seq_len\",\n    ]\n    # Choose the smallest \"max_length\" from the possible keys.\n    max_len_key = None\n    for key in possible_keys:\n        max_len = getattr(hf_config, key, None)\n        if max_len is not None:\n            max_len_key = key if max_len < derived_max_model_len \\\n                else max_len_key\n            derived_max_model_len = min(derived_max_model_len, max_len)\n\n    # If sliding window is manually disabled, max_length should be less\n    # than the sliding window length in the model config.\n    if disable_sliding_window and sliding_window_len is not None:\n        max_len_key = \"sliding_window\" \\\n            if sliding_window_len < derived_max_model_len else max_len_key\n        derived_max_model_len = min(derived_max_model_len, sliding_window_len)\n\n    # If none of the keys were found in the config, use a default and\n    # log a warning.\n    if derived_max_model_len == float(\"inf\"):\n        if max_model_len is not None:\n            # If max_model_len is specified, we use it.\n            return max_model_len\n\n        default_max_len = 2048\n        logger.warning(\n            \"The model's config.json does not contain any of the following \"\n            \"keys to determine the original maximum length of the model: \"\n            \"%s. Assuming the model's maximum length is %d.\", possible_keys,\n            default_max_len)\n        derived_max_model_len = default_max_len\n\n    rope_scaling = getattr(hf_config, \"rope_scaling\", None)\n    if rope_scaling is not None:\n        if \"type\" in rope_scaling:\n            rope_type = rope_scaling[\"type\"]\n        elif \"rope_type\" in rope_scaling:\n            rope_type = rope_scaling[\"rope_type\"]\n        else:\n            raise ValueError(\n                \"rope_scaling must have a 'type' or 'rope_type' key.\")\n\n        # The correct one should be \"longrope\", kept \"su\" here\n        # to be backward compatible\n        if rope_type not in (\"su\", \"longrope\", \"llama3\"):\n            if disable_sliding_window:\n                # TODO(robertgshaw): Find a model that supports rope_scaling\n                # with sliding window to see if this case should be allowed.\n                raise NotImplementedError(\n                    \"Disabling sliding window is not supported for models \"\n                    \"with rope_scaling. Please raise an issue so we can \"\n                    \"investigate.\")\n\n            assert \"factor\" in rope_scaling\n            scaling_factor = rope_scaling[\"factor\"]\n            if rope_type == \"yarn\":\n                derived_max_model_len = rope_scaling[\n                    \"original_max_position_embeddings\"]\n            derived_max_model_len *= scaling_factor\n\n    # If the user specified a max length, make sure it is smaller than the\n    # derived length from the HF model config.\n    if max_model_len is None:\n        max_model_len = int(derived_max_model_len)\n    elif max_model_len > derived_max_model_len:\n        # Some models might have a separate key for specifying model_max_length\n        # that will be bigger than derived_max_model_len. We compare user input\n        # with model_max_length and allow this override when it's smaller.\n        model_max_length = getattr(hf_config, \"model_max_length\", None)\n        if model_max_length is not None and max_model_len <= model_max_length:\n            if disable_sliding_window:\n                # TODO(robertgshaw): Find a model that has model_max_length\n                # with sliding window to see if this case should be allowed.\n                raise NotImplementedError(\n                    \"Disabling sliding window is not supported for models \"\n                    \"model_max_length in the config. Please raise an issue \"\n                    \"so we can investigate.\")\n            pass\n        else:\n            raise ValueError(\n                f\"User-specified max_model_len ({max_model_len}) is greater \"\n                \"than the derived max_model_len \"\n                f\"({max_len_key}={derived_max_model_len} or model_max_length=\"\n                f\"{model_max_length} in model's config.json). This may lead \"\n                \"to incorrect model outputs or CUDA errors. Make sure the \"\n                \"value is correct and within the model context size.\")\n    return int(max_model_len)\n\n\ndef get_served_model_name(model: str,\n                          served_model_name: Optional[Union[str, List[str]]]):\n    \"\"\"\n    If the input is a non-empty list, the first model_name in \n    `served_model_name` is taken. \n    If the input is a non-empty string, it is used directly. \n    For cases where the input is either an empty string or an \n    empty list, the fallback is to use `self.model`.\n    \"\"\"\n    if not served_model_name:\n        return model\n    if isinstance(served_model_name, list):\n        return served_model_name[0]\n    return served_model_name\n\n\n@dataclass\nclass DecodingConfig:\n    \"\"\"Dataclass which contains the decoding strategy of the engine\"\"\"\n\n    # Which guided decoding algo to use. 'outlines' / 'lm-format-enforcer'\n    guided_decoding_backend: str = 'outlines'\n\n    def __post_init__(self):\n        valid_guided_backends = ['outlines', 'lm-format-enforcer']\n        backend = self.guided_decoding_backend\n        if backend not in valid_guided_backends:\n            raise ValueError(f\"Invalid guided_decoding_backend '{backend},\"\n                             f\"must be one of {valid_guided_backends}\")\n\n\n@dataclass\nclass ObservabilityConfig:\n    \"\"\"Configuration for observability.\"\"\"\n    otlp_traces_endpoint: Optional[str] = None\n\n    def __post_init__(self):\n        if not is_otel_installed() and self.otlp_traces_endpoint is not None:\n            raise ValueError(\"OpenTelemetry packages must be installed before \"\n                             \"configuring 'otlp_traces_endpoint'\")\n\n\n@dataclass(frozen=True)\nclass EngineConfig:\n    \"\"\"Dataclass which contains all engine-related configuration. This\n    simplifies passing around the distinct configurations in the codebase.\n    \"\"\"\n\n    model_config: ModelConfig\n    cache_config: CacheConfig\n    parallel_config: ParallelConfig\n    scheduler_config: SchedulerConfig\n    device_config: DeviceConfig\n    load_config: LoadConfig\n    lora_config: Optional[LoRAConfig]\n    multimodal_config: Optional[MultiModalConfig]\n    speculative_config: Optional[SpeculativeConfig]\n    decoding_config: Optional[DecodingConfig]\n    observability_config: Optional[ObservabilityConfig]\n    prompt_adapter_config: Optional[PromptAdapterConfig]\n\n    def __post_init__(self):\n        \"\"\"Verify configs are valid & consistent with each other.\n        \"\"\"\n        self.model_config.verify_with_parallel_config(self.parallel_config)\n        self.cache_config.verify_with_parallel_config(self.parallel_config)\n\n        if self.lora_config:\n            self.lora_config.verify_with_model_config(self.model_config)\n            self.lora_config.verify_with_scheduler_config(\n                self.scheduler_config)\n        if self.prompt_adapter_config:\n            self.prompt_adapter_config.verify_with_model_config(\n                self.model_config)\n\n    def to_dict(self):\n        \"\"\"Return the configs as a dictionary, for use in **kwargs.\n        \"\"\"\n        return dict(\n            (field.name, getattr(self, field.name)) for field in fields(self))\n",
      "diff": "diff --git a/vllm/config.py b/vllm/config.py\nindex fd48cc3a6..de5d0402a 100644\n--- a/vllm/config.py\n+++ b/vllm/config.py\n@@ -197,13 +197,17 @@ class ModelConfig:\n     def _parse_quant_hf_config(self):\n         quant_cfg = getattr(self.hf_config, \"quantization_config\", None)\n         if quant_cfg is None:\n-            # compress-tensors uses a \"compression_config\" key\n+            # compressed-tensors uses a \"compression_config\" key\n             quant_cfg = getattr(self.hf_config, \"compression_config\", None)\n         return quant_cfg\n \n     def _verify_quantization(self) -> None:\n         supported_quantization = [*QUANTIZATION_METHODS]\n         rocm_supported_quantization = [\"gptq\", \"squeezellm\"]\n+        optimized_quantization_methods = [\n+            \"fp8\", \"marlin\", \"gptq_marlin_24\", \"gptq_marlin\", \"awq_marlin\",\n+            \"fbgemm_fp8\", \"compressed_tensors\", \"compressed-tensors\"\n+        ]\n         if self.quantization is not None:\n             self.quantization = self.quantization.lower()\n \n@@ -242,9 +246,7 @@ class ModelConfig:\n                 raise ValueError(\n                     f\"{self.quantization} quantization is currently not \"\n                     f\"supported in ROCm.\")\n-            if (self.quantization\n-                    not in (\"fp8\", \"marlin\", \"gptq_marlin_24\", \"gptq_marlin\",\n-                            \"awq_marlin\", \"fbgemm_fp8\", \"compressed_tensors\")):\n+            if self.quantization not in optimized_quantization_methods:\n                 logger.warning(\n                     \"%s quantization is not fully \"\n                     \"optimized yet. The speed can be slower than \"",
      "change_type": "modified",
      "lines_added": 7,
      "lines_removed": 5
    }
  ],
  "affected_apis": [
    "ModelConfig._parse_quant_hf_config",
    "ModelConfig._verify_quantization"
  ],
  "summary": {
    "total_files": 1,
    "files_added": 0,
    "files_deleted": 0,
    "files_modified": 1
  },
  "csv_metadata": {
    "category": "miscellaneous",
    "json_has_tests": "FALSE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "",
    "is_benchmark_actually_there": "",
    "sample_clues": "config, modelconfig, parse"
  }
}