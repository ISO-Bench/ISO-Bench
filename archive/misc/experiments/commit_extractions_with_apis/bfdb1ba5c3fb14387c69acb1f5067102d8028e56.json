{
  "commit_hash": "bfdb1ba5c3fb14387c69acb1f5067102d8028e56",
  "parent_hash": "cf2f084d56a1293cb08da2393984cdc7685ac019",
  "message": "[Core] Improve detokenization performance for prefill (#3469)\n\nCo-authored-by: MeloYang <meloyang05@gmail.com>",
  "author": "Antoni Baum <antoni.baum@protonmail.com>",
  "date": "2024-03-22 13:44:12 -0700",
  "files_changed": [
    {
      "file_path": "tests/tokenization/test_detokenize.py",
      "old_content": "import pytest\n\nfrom transformers import AutoTokenizer\n\nfrom vllm.transformers_utils.tokenizer import detokenize_incrementally\n\nTRUTH = [\n    \"Hello here, this is a simple test\",  # noqa: E501\n    \"vLLM is a high-throughput and memory-efficient inference and serving engine for LLMs. It is designed to be used in production environments, where inference and serving\",  # noqa: E501\n    \"我很感谢你的热情\"  # noqa: E501\n]\nTOKENIZERS = [\n    \"facebook/opt-125m\",\n    \"gpt2\",\n    \"bigcode/tiny_starcoder_py\",\n    \"EleutherAI/gpt-j-6b\",\n    \"EleutherAI/pythia-70m\",\n    \"bigscience/bloom-560m\",\n    \"mosaicml/mpt-7b\",\n    \"tiiuae/falcon-7b\",\n    \"meta-llama/Llama-2-7b-hf\",\n    \"codellama/CodeLlama-7b-hf\",\n]\n\n\ndef _run_incremental_decode(tokenizer, all_input_ids,\n                            skip_special_tokens: bool):\n    decoded_text = \"\"\n    offset = 0\n    token_offset = 0\n    prev_tokens = None\n    for i in range(len(all_input_ids)):\n        new_tokens, text, offset, token_offset = detokenize_incrementally(\n            tokenizer,\n            all_input_ids[:i + 1],\n            prev_tokens,\n            offset,\n            token_offset,\n            skip_special_tokens=skip_special_tokens)\n        decoded_text += text\n        if prev_tokens is None:\n            prev_tokens = new_tokens\n        else:\n            prev_tokens += new_tokens\n    return decoded_text\n\n\n@pytest.mark.parametrize(\"truth\", TRUTH)\n@pytest.mark.parametrize(\"tokenizer_id\", TOKENIZERS)\n@pytest.mark.parametrize(\"skip_special_tokens\", (True, False))\ndef test_decode_streaming(tokenizer_id, truth, skip_special_tokens):\n    tokenizer = AutoTokenizer.from_pretrained(tokenizer_id)\n    all_input_ids = tokenizer(truth, add_special_tokens=False)[\"input_ids\"]\n    if skip_special_tokens:\n        all_input_ids = ([tokenizer.bos_token_id]\n                         if tokenizer.bos_token_id is not None else\n                         []) + all_input_ids + [tokenizer.eos_token_id]\n\n    decoded_text = _run_incremental_decode(\n        tokenizer, all_input_ids, skip_special_tokens=skip_special_tokens)\n\n    assert decoded_text == truth\n",
      "diff": "diff --git a/tests/tokenization/test_detokenize.py b/tests/tokenization/test_detokenize.py\nindex 442173939..082034083 100644\n--- a/tests/tokenization/test_detokenize.py\n+++ b/tests/tokenization/test_detokenize.py\n@@ -1,13 +1,17 @@\n import pytest\n \n from transformers import AutoTokenizer\n+from typing import List, Dict\n \n+from vllm.sequence import Sequence, Logprob, SamplingParams, SequenceGroup\n+from vllm.transformers_utils.tokenizer_group import get_tokenizer_group\n from vllm.transformers_utils.tokenizer import detokenize_incrementally\n+from vllm.transformers_utils.detokenizer import Detokenizer\n \n TRUTH = [\n-    \"Hello here, this is a simple test\",  # noqa: E501\n-    \"vLLM is a high-throughput and memory-efficient inference and serving engine for LLMs. It is designed to be used in production environments, where inference and serving\",  # noqa: E501\n-    \"我很感谢你的热情\"  # noqa: E501\n+    \"Hello here, this is a simple test\",\n+    \"vLLM is a high-throughput and memory-efficient inference and serving engine for LLMs. It is designed to be used in production environments, where inference and serving\",  # noqa\n+    \"我很感谢你的热情\"\n ]\n TOKENIZERS = [\n     \"facebook/opt-125m\",\n@@ -24,12 +28,12 @@ TOKENIZERS = [\n \n \n def _run_incremental_decode(tokenizer, all_input_ids,\n-                            skip_special_tokens: bool):\n+                            skip_special_tokens: bool, starting_index: int):\n     decoded_text = \"\"\n     offset = 0\n     token_offset = 0\n     prev_tokens = None\n-    for i in range(len(all_input_ids)):\n+    for i in range(starting_index, len(all_input_ids)):\n         new_tokens, text, offset, token_offset = detokenize_incrementally(\n             tokenizer,\n             all_input_ids[:i + 1],\n@@ -46,17 +50,152 @@ def _run_incremental_decode(tokenizer, all_input_ids,\n \n \n @pytest.mark.parametrize(\"truth\", TRUTH)\n+@pytest.mark.parametrize(\"with_prompt\", [True, False])\n @pytest.mark.parametrize(\"tokenizer_id\", TOKENIZERS)\n @pytest.mark.parametrize(\"skip_special_tokens\", (True, False))\n-def test_decode_streaming(tokenizer_id, truth, skip_special_tokens):\n+def test_decode_streaming(tokenizer_id, truth, with_prompt,\n+                          skip_special_tokens):\n     tokenizer = AutoTokenizer.from_pretrained(tokenizer_id)\n-    all_input_ids = tokenizer(truth, add_special_tokens=False)[\"input_ids\"]\n+    if with_prompt:\n+        truth_tokens = tokenizer(truth, add_special_tokens=False)[\"input_ids\"]\n+        prompt_input_ids = truth_tokens[:len(truth) // 2]\n+        generated_input_ids = truth_tokens[len(truth) // 2:]\n+        all_input_ids = prompt_input_ids + generated_input_ids\n+        starting_index = len(prompt_input_ids)\n+        prompt = tokenizer.decode(prompt_input_ids,\n+                                  skip_special_tokens=skip_special_tokens)\n+        generated = truth[len(prompt):]\n+    else:\n+        generated = truth\n+        starting_index = 0\n+        all_input_ids = tokenizer(truth, add_special_tokens=False)[\"input_ids\"]\n     if skip_special_tokens:\n-        all_input_ids = ([tokenizer.bos_token_id]\n-                         if tokenizer.bos_token_id is not None else\n-                         []) + all_input_ids + [tokenizer.eos_token_id]\n+        if tokenizer.bos_token_id is not None:\n+            all_input_ids = [tokenizer.bos_token_id] + all_input_ids\n+            starting_index += 1\n+        all_input_ids = all_input_ids + [tokenizer.eos_token_id]\n \n     decoded_text = _run_incremental_decode(\n-        tokenizer, all_input_ids, skip_special_tokens=skip_special_tokens)\n+        tokenizer,\n+        all_input_ids,\n+        skip_special_tokens=skip_special_tokens,\n+        starting_index=starting_index)\n \n-    assert decoded_text == truth\n+    assert decoded_text == generated\n+\n+\n+@pytest.fixture\n+def detokenizer(tokenizer_name: str) -> Detokenizer:\n+    init_kwargs = dict(\n+        tokenizer_id=tokenizer_name,\n+        enable_lora=False,\n+        max_num_seqs=100,\n+        max_input_length=None,\n+        tokenizer_mode=\"auto\",\n+        trust_remote_code=False,\n+        revision=None,\n+    )\n+\n+    tokenizer_group = get_tokenizer_group(\n+        None,\n+        **init_kwargs,\n+    )\n+\n+    return Detokenizer(tokenizer_group)\n+\n+\n+@pytest.fixture(name=\"complete_sequence_token_ids\")\n+def create_complete_sequence_token_ids(complete_sequence: str,\n+                                       tokenizer_name: str) -> List[int]:\n+    tokenizer = AutoTokenizer.from_pretrained(tokenizer_name)\n+    complete_sequence_token_ids = tokenizer(complete_sequence)[\"input_ids\"]\n+    return complete_sequence_token_ids\n+\n+\n+def create_sequence(prompt_token_ids=None):\n+    prompt_token_ids = prompt_token_ids or [1]\n+    return Sequence(\n+        seq_id=0,\n+        prompt=\"<s>\",\n+        prompt_token_ids=prompt_token_ids,\n+        block_size=16,\n+    )\n+\n+\n+def create_dummy_logprobs(\n+        complete_sequence_token_ids: List[int]) -> List[Dict[int, Logprob]]:\n+    return [{\n+        token_id: Logprob(logprob=0.0),\n+        token_id + 1: Logprob(logprob=0.1)\n+    } for token_id in complete_sequence_token_ids]\n+\n+\n+@pytest.mark.parametrize(\"complete_sequence\", TRUTH)\n+@pytest.mark.parametrize(\"tokenizer_name\", TOKENIZERS)\n+@pytest.mark.parametrize(\"skip_special_tokens\", [True, False])\n+def test_decode_sequence_logprobs(complete_sequence: str,\n+                                  complete_sequence_token_ids: List[int],\n+                                  detokenizer: Detokenizer,\n+                                  skip_special_tokens: bool):\n+    \"\"\"Verify Detokenizer decodes logprobs correctly.\"\"\"\n+    sampling_params = SamplingParams(skip_special_tokens=skip_special_tokens,\n+                                     logprobs=2)\n+\n+    # Run sequentially.\n+    seq = create_sequence()\n+    dummy_logprobs = create_dummy_logprobs(complete_sequence_token_ids)\n+    sequential_logprobs_text_chosen_token = []\n+    sequential_logprobs_text_other_token = []\n+    for new_token, logprobs in zip(complete_sequence_token_ids,\n+                                   dummy_logprobs):\n+        seq.append_token_id(new_token, logprobs)\n+        detokenizer.decode_sequence_inplace(seq, sampling_params)\n+        sequential_logprobs_text_chosen_token.append(\n+            seq.output_logprobs[-1][new_token].decoded_token)\n+        sequential_logprobs_text_other_token.append(\n+            seq.output_logprobs[-1][new_token + 1].decoded_token)\n+    sequential_result = seq.output_text\n+\n+    assert sequential_result == \"\".join(sequential_logprobs_text_chosen_token)\n+    assert sequential_result != \"\".join(sequential_logprobs_text_other_token)\n+\n+    if skip_special_tokens:\n+        # Text for logprobs for the chosen token should be the same as the\n+        # generated text. Note that this will only be true if we skip\n+        # special tokens.\n+        assert sequential_result == complete_sequence\n+\n+\n+@pytest.mark.parametrize(\"complete_sequence\", TRUTH)\n+@pytest.mark.parametrize(\"tokenizer_name\", TOKENIZERS)\n+@pytest.mark.parametrize(\"skip_special_tokens\", [True])\n+def test_decode_prompt_logprobs(complete_sequence: str,\n+                                complete_sequence_token_ids: List[int],\n+                                detokenizer: Detokenizer,\n+                                skip_special_tokens: bool):\n+    \"\"\"Verify Detokenizer decodes prompt logprobs correctly.\"\"\"\n+    sampling_params = SamplingParams(skip_special_tokens=skip_special_tokens,\n+                                     prompt_logprobs=1)\n+\n+    # Run sequentially.\n+    seq = create_sequence(complete_sequence_token_ids)\n+    seq_group = SequenceGroup(request_id=\"1\",\n+                              seqs=[seq],\n+                              sampling_params=sampling_params,\n+                              arrival_time=0.0)\n+    dummy_logprobs = create_dummy_logprobs(complete_sequence_token_ids)\n+    detokenizer.decode_prompt_logprobs_inplace(seq_group, dummy_logprobs)\n+    decoded_prompt_logprobs = dummy_logprobs\n+\n+    if skip_special_tokens:\n+        # Text for logprobs for the chosen token should be the same as the\n+        # prompt text. Note that this will only be true if we skip\n+        # special tokens.\n+        assert complete_sequence == \"\".join([\n+            logprobs[token_id].decoded_token for token_id, logprobs in zip(\n+                complete_sequence_token_ids, decoded_prompt_logprobs)\n+        ])\n+        assert complete_sequence != \"\".join([\n+            logprobs[token_id + 1].decoded_token for token_id, logprobs in zip(\n+                complete_sequence_token_ids, decoded_prompt_logprobs)\n+        ])",
      "change_type": "modified",
      "lines_added": 152,
      "lines_removed": 13
    },
    {
      "file_path": "vllm/engine/llm_engine.py",
      "old_content": "import time\nfrom typing import Dict, Iterable, List, Optional, Tuple, Type, Union\n\nfrom transformers import PreTrainedTokenizer\n\nimport vllm\nfrom vllm.lora.request import LoRARequest\nfrom vllm.config import (CacheConfig, DeviceConfig, ModelConfig,\n                         ParallelConfig, SchedulerConfig, LoRAConfig)\nfrom vllm.core.scheduler import Scheduler, SchedulerOutputs\nfrom vllm.engine.arg_utils import EngineArgs\nfrom vllm.executor.executor_base import ExecutorBase\nfrom vllm.engine.metrics import StatLogger, Stats\nfrom vllm.engine.ray_utils import initialize_ray_cluster\nfrom vllm.logger import init_logger\nfrom vllm.outputs import RequestOutput\nfrom vllm.sampling_params import SamplingParams\nfrom vllm.sequence import (Logprob, SamplerOutput, Sequence, SequenceGroup,\n                           SequenceGroupOutput, SequenceOutput, SequenceStatus)\nfrom vllm.transformers_utils.tokenizer import detokenize_incrementally\nfrom vllm.transformers_utils.tokenizer_group import (BaseTokenizerGroup,\n                                                     get_tokenizer_group)\nfrom vllm.utils import Counter\n\nlogger = init_logger(__name__)\n_LOCAL_LOGGING_INTERVAL_SEC = 5\n\n\nclass LLMEngine:\n    \"\"\"An LLM engine that receives requests and generates texts.\n\n    This is the main class for the vLLM engine. It receives requests\n    from clients and generates texts from the LLM. It includes a tokenizer, a\n    language model (possibly distributed across multiple GPUs), and GPU memory\n    space allocated for intermediate states (aka KV cache). This class utilizes\n    iteration-level scheduling and efficient memory management to maximize the\n    serving throughput.\n\n    The `LLM` class wraps this class for offline batched inference and the\n    `AsyncLLMEngine` class wraps this class for online serving.\n\n    NOTE: The config arguments are derived from the `EngineArgs` class. For the\n    comprehensive list of arguments, see `EngineArgs`.\n\n    Args:\n        model_config: The configuration related to the LLM model.\n        cache_config: The configuration related to the KV cache memory\n            management.\n        parallel_config: The configuration related to distributed execution.\n        scheduler_config: The configuration related to the request scheduler.\n        device_config: The configuration related to the device.\n        executor_class: The model executor class for managing distributed\n            execution.\n        log_stats: Whether to log statistics.\n    \"\"\"\n\n    def __init__(\n        self,\n        model_config: ModelConfig,\n        cache_config: CacheConfig,\n        parallel_config: ParallelConfig,\n        scheduler_config: SchedulerConfig,\n        device_config: DeviceConfig,\n        lora_config: Optional[LoRAConfig],\n        executor_class: Type[ExecutorBase],\n        log_stats: bool,\n    ) -> None:\n        logger.info(\n            f\"Initializing an LLM engine (v{vllm.__version__}) with config: \"\n            f\"model={model_config.model!r}, \"\n            f\"tokenizer={model_config.tokenizer!r}, \"\n            f\"tokenizer_mode={model_config.tokenizer_mode}, \"\n            f\"revision={model_config.revision}, \"\n            f\"tokenizer_revision={model_config.tokenizer_revision}, \"\n            f\"trust_remote_code={model_config.trust_remote_code}, \"\n            f\"dtype={model_config.dtype}, \"\n            f\"max_seq_len={model_config.max_model_len}, \"\n            f\"download_dir={model_config.download_dir!r}, \"\n            f\"load_format={model_config.load_format}, \"\n            f\"tensor_parallel_size={parallel_config.tensor_parallel_size}, \"\n            f\"disable_custom_all_reduce=\"\n            f\"{parallel_config.disable_custom_all_reduce}, \"\n            f\"quantization={model_config.quantization}, \"\n            f\"enforce_eager={model_config.enforce_eager}, \"\n            f\"kv_cache_dtype={cache_config.cache_dtype}, \"\n            f\"device_config={device_config.device}, \"\n            f\"seed={model_config.seed})\")\n        # TODO(woosuk): Print more configs in debug mode.\n\n        self.model_config = model_config\n        self.cache_config = cache_config\n        self.lora_config = lora_config\n        self.parallel_config = parallel_config\n        self.scheduler_config = scheduler_config\n        self.device_config = device_config\n        self.log_stats = log_stats\n        self._verify_args()\n\n        self._init_tokenizer()\n        self.seq_counter = Counter()\n\n        self.model_executor = executor_class(model_config, cache_config,\n                                             parallel_config, scheduler_config,\n                                             device_config, lora_config)\n\n        # Ping the tokenizer to ensure liveness if it runs in a\n        # different process.\n        self.tokenizer.ping()\n\n        # Create the scheduler.\n        # NOTE: the cache_config here have been updated with the numbers of\n        # GPU and CPU blocks, which are profiled in the distributed executor.\n        self.scheduler = Scheduler(scheduler_config, cache_config, lora_config)\n\n        # Metric Logging.\n        if self.log_stats:\n            self.stat_logger = StatLogger(\n                local_interval=_LOCAL_LOGGING_INTERVAL_SEC,\n                labels=dict(model_name=model_config.model))\n            self.stat_logger.info(\"cache_config\", self.cache_config)\n\n    @classmethod\n    def from_engine_args(cls, engine_args: EngineArgs) -> \"LLMEngine\":\n        \"\"\"Creates an LLM engine from the engine arguments.\"\"\"\n        # Create the engine configs.\n        engine_configs = engine_args.create_engine_configs()\n        parallel_config = engine_configs[2]\n        device_config = engine_configs[4]\n\n        # Initialize the cluster and specify the executor class.\n        if device_config.device_type == \"neuron\":\n            from vllm.executor.neuron_executor import NeuronExecutor\n            executor_class = NeuronExecutor\n        elif parallel_config.worker_use_ray:\n            initialize_ray_cluster(parallel_config)\n            from vllm.executor.ray_gpu_executor import RayGPUExecutor\n            executor_class = RayGPUExecutor\n        else:\n            assert parallel_config.world_size == 1, (\n                \"Ray is required if parallel_config.world_size > 1.\")\n            from vllm.executor.gpu_executor import GPUExecutor\n            executor_class = GPUExecutor\n\n        # Create the LLM engine.\n        engine = cls(*engine_configs,\n                     executor_class=executor_class,\n                     log_stats=not engine_args.disable_log_stats)\n        return engine\n\n    def __reduce__(self):\n        # This is to ensure that the LLMEngine is not referenced in\n        # the closure used to initialize Ray worker actors\n        raise RuntimeError(\"LLMEngine should not be pickled!\")\n\n    def get_tokenizer(self) -> \"PreTrainedTokenizer\":\n        return self.tokenizer.get_lora_tokenizer()\n\n    def get_tokenizer_for_seq(self,\n                              sequence: Sequence) -> \"PreTrainedTokenizer\":\n        return self.tokenizer.get_lora_tokenizer(sequence.lora_request)\n\n    def _init_tokenizer(self, **tokenizer_init_kwargs):\n        init_kwargs = dict(\n            tokenizer_id=self.model_config.tokenizer,\n            enable_lora=bool(self.lora_config),\n            max_num_seqs=self.scheduler_config.max_num_seqs,\n            max_input_length=None,\n            tokenizer_mode=self.model_config.tokenizer_mode,\n            trust_remote_code=self.model_config.trust_remote_code,\n            revision=self.model_config.tokenizer_revision)\n        init_kwargs.update(tokenizer_init_kwargs)\n\n        self.tokenizer: BaseTokenizerGroup = get_tokenizer_group(\n            self.parallel_config.tokenizer_pool_config, **init_kwargs)\n\n        if len(self.get_tokenizer()) != self.model_config.get_vocab_size():\n            logger.warning(\n                f\"The tokenizer's vocabulary size {len(self.get_tokenizer())}\"\n                f\" does not match the model's vocabulary size \"\n                f\"{self.model_config.get_vocab_size()}. This might \"\n                f\"cause an error in decoding. Please change config.json \"\n                \"to match the tokenizer's vocabulary size.\")\n\n    def _verify_args(self) -> None:\n        self.model_config.verify_with_parallel_config(self.parallel_config)\n        self.cache_config.verify_with_parallel_config(self.parallel_config)\n        if self.lora_config:\n            self.lora_config.verify_with_model_config(self.model_config)\n            self.lora_config.verify_with_scheduler_config(\n                self.scheduler_config)\n\n    def encode_request(\n        self,\n        request_id: str,  # pylint: disable=unused-argument\n        prompt: Optional[str],\n        prompt_token_ids: Optional[List[int]] = None,\n        lora_request: Optional[LoRARequest] = None,\n    ):\n        if prompt_token_ids is None:\n            assert prompt is not None\n            prompt_token_ids = self.tokenizer.encode(request_id=request_id,\n                                                     prompt=prompt,\n                                                     lora_request=lora_request)\n        return prompt_token_ids\n\n    def add_request(\n        self,\n        request_id: str,\n        prompt: Optional[str],\n        sampling_params: SamplingParams,\n        prompt_token_ids: Optional[List[int]] = None,\n        arrival_time: Optional[float] = None,\n        lora_request: Optional[LoRARequest] = None,\n    ) -> None:\n        \"\"\"Add a request to the engine's request pool.\n\n        The request is added to the request pool and will be processed by the\n        scheduler as `engine.step()` is called. The exact scheduling policy is\n        determined by the scheduler.\n\n        Args:\n            request_id: The unique ID of the request.\n            prompt: The prompt string. Can be None if prompt_token_ids is\n                provided.\n            sampling_params: The sampling parameters for text generation.\n            prompt_token_ids: The token IDs of the prompt. If None, we\n                use the tokenizer to convert the prompts to token IDs.\n            arrival_time: The arrival time of the request. If None, we use\n                the current monotonic time.\n\n        Details:\n            - Set arrival_time to the current time if it is None.\n            - Set prompt_token_ids to the encoded prompt if it is None.\n            - Create `best_of` number of :class:`~vllm.Sequence` objects.\n            - Create a :class:`~vllm.SequenceGroup` object\n              from the list of :class:`~vllm.Sequence`.\n            - Add the :class:`~vllm.SequenceGroup` object to the scheduler.\n\n        Example:\n            >>> # initialize engine\n            >>> engine = LLMEngine.from_engine_args(engine_args)\n            >>> # set request arguments\n            >>> example_prompt = \"Who is the president of the United States?\"\n            >>> sampling_params = SamplingParams(temperature=0.0)\n            >>> request_id = 0\n            >>>\n            >>> # add the request to the engine\n            >>> engine.add_request(\n            >>>    str(request_id),\n            >>>    example_prompt,\n            >>>    SamplingParams(temperature=0.0))\n            >>> # continue the request processing\n            >>> ...\n        \"\"\"\n        if lora_request is not None and not self.lora_config:\n            raise ValueError(f\"Got lora_request {lora_request} but LoRA is \"\n                             \"not enabled!\")\n        max_logprobs = self.get_model_config().max_logprobs\n        if (sampling_params.logprobs\n                and sampling_params.logprobs > max_logprobs) or (\n                    sampling_params.prompt_logprobs\n                    and sampling_params.prompt_logprobs > max_logprobs):\n            raise ValueError(f\"Cannot request more than \"\n                             f\"{max_logprobs} logprobs.\")\n        if arrival_time is None:\n            arrival_time = time.time()\n        prompt_token_ids = self.encode_request(\n            request_id=request_id,\n            prompt=prompt,\n            prompt_token_ids=prompt_token_ids,\n            lora_request=lora_request)\n\n        # Create the sequences.\n        block_size = self.cache_config.block_size\n        seq_id = next(self.seq_counter)\n        eos_token_id = self.tokenizer.get_lora_tokenizer(\n            lora_request).eos_token_id\n        seq = Sequence(seq_id, prompt, prompt_token_ids, block_size,\n                       eos_token_id, lora_request)\n\n        # Defensive copy of SamplingParams, which are used by the sampler,\n        # this doesn't deep-copy LogitsProcessor objects\n        sampling_params = sampling_params.clone()\n\n        # Create the sequence group.\n        seq_group = SequenceGroup(request_id, [seq], sampling_params,\n                                  arrival_time, lora_request)\n\n        # Add the sequence group to the scheduler.\n        self.scheduler.add_seq_group(seq_group)\n\n    def abort_request(self, request_id: Union[str, Iterable[str]]) -> None:\n        \"\"\"Aborts a request(s) with the given ID.\n\n        Args:\n            request_id: The ID(s) of the request to abort.\n\n        Details:\n            - Refer to the\n              :meth:`~vllm.core.scheduler.Scheduler.abort_seq_group`\n              from class :class:`~vllm.core.scheduler.Scheduler`.\n\n        Example:\n            >>> # initialize engine and add a request with request_id\n            >>> request_id = str(0)\n            >>> # abort the request\n            >>> engine.abort_request(request_id)\n        \"\"\"\n        self.scheduler.abort_seq_group(request_id)\n\n    def get_model_config(self) -> ModelConfig:\n        \"\"\"Gets the model configuration.\"\"\"\n        return self.model_config\n\n    def get_num_unfinished_requests(self) -> int:\n        \"\"\"Gets the number of unfinished requests.\"\"\"\n        return self.scheduler.get_num_unfinished_seq_groups()\n\n    def has_unfinished_requests(self) -> bool:\n        \"\"\"Returns True if there are unfinished requests.\"\"\"\n        return self.scheduler.has_unfinished_seqs()\n\n    def _check_beam_search_early_stopping(\n        self,\n        early_stopping: Union[bool, str],\n        sampling_params: SamplingParams,\n        best_running_seq: Sequence,\n        current_worst_seq: Sequence,\n    ) -> bool:\n        assert sampling_params.use_beam_search\n        length_penalty = sampling_params.length_penalty\n        if early_stopping is True:\n            return True\n\n        current_worst_score = current_worst_seq.get_beam_search_score(\n            length_penalty=length_penalty,\n            eos_token_id=current_worst_seq.eos_token_id)\n        if early_stopping is False:\n            highest_attainable_score = best_running_seq.get_beam_search_score(\n                length_penalty=length_penalty,\n                eos_token_id=best_running_seq.eos_token_id)\n        else:\n            assert early_stopping == \"never\"\n            if length_penalty > 0.0:\n                # If length_penalty > 0.0, beam search will prefer longer\n                # sequences. The highest attainable score calculation is\n                # based on the longest possible sequence length in this case.\n                max_possible_length = max(\n                    best_running_seq.get_prompt_len() +\n                    sampling_params.max_tokens,\n                    self.scheduler_config.max_model_len)\n                highest_attainable_score = (\n                    best_running_seq.get_beam_search_score(\n                        length_penalty=length_penalty,\n                        eos_token_id=best_running_seq.eos_token_id,\n                        seq_len=max_possible_length))\n            else:\n                # Otherwise, beam search will prefer shorter sequences. The\n                # highest attainable score calculation is based on the current\n                # sequence length.\n                highest_attainable_score = (\n                    best_running_seq.get_beam_search_score(\n                        length_penalty=length_penalty,\n                        eos_token_id=best_running_seq.eos_token_id))\n        return current_worst_score >= highest_attainable_score\n\n    def _process_sequence_group_outputs(self, seq_group: SequenceGroup,\n                                        outputs: SequenceGroupOutput) -> None:\n\n        # Process prompt logprobs\n        prompt_logprobs = outputs.prompt_logprobs\n        if prompt_logprobs is not None:\n            # We can pick any sequence for the prompt.\n            seq = next(iter(seq_group.seqs_dict.values()))\n            all_token_ids = seq.get_token_ids()\n            for i, prompt_logprobs_for_token in enumerate(prompt_logprobs):\n                self._decode_logprobs(seq, seq_group.sampling_params,\n                                      prompt_logprobs_for_token,\n                                      all_token_ids[:i])\n            seq_group.prompt_logprobs = prompt_logprobs\n\n        # Process samples\n        samples = outputs.samples\n        parent_seqs = seq_group.get_seqs(status=SequenceStatus.RUNNING)\n        existing_finished_seqs = seq_group.get_finished_seqs()\n        parent_child_dict = {\n            parent_seq.seq_id: []\n            for parent_seq in parent_seqs\n        }\n        for sample in samples:\n            parent_child_dict[sample.parent_seq_id].append(sample)\n        # List of (child, parent)\n        child_seqs: List[Tuple[Sequence, Sequence]] = []\n\n        # Process the child samples for each parent sequence\n        for parent in parent_seqs:\n            child_samples: List[SequenceOutput] = parent_child_dict[\n                parent.seq_id]\n            if len(child_samples) == 0:\n                # This parent sequence has no children samples. Remove\n                # the parent sequence from the sequence group since it will\n                # not be used in the future iterations.\n                parent.status = SequenceStatus.FINISHED_ABORTED\n                seq_group.remove(parent.seq_id)\n                self.scheduler.free_seq(parent)\n                continue\n            # Fork the parent sequence if there are multiple child samples.\n            for child_sample in child_samples[:-1]:\n                new_child_seq_id = next(self.seq_counter)\n                child = parent.fork(new_child_seq_id)\n                child.append_token_id(child_sample.output_token,\n                                      child_sample.logprobs)\n                child_seqs.append((child, parent))\n            # Continue the parent sequence for the last child sample.\n            # We reuse the parent sequence here to reduce redundant memory\n            # copies, especially when using non-beam search sampling methods.\n            last_child_sample = child_samples[-1]\n            parent.append_token_id(last_child_sample.output_token,\n                                   last_child_sample.logprobs)\n            child_seqs.append((parent, parent))\n\n        for seq, _ in child_seqs:\n            self._decode_sequence(seq, seq_group.sampling_params)\n            self._check_stop(seq, seq_group.sampling_params)\n\n        # Non-beam search case\n        if not seq_group.sampling_params.use_beam_search:\n            # For newly created child sequences, add them to the sequence group\n            # and fork them in block manager if they are not finished.\n            for seq, parent in child_seqs:\n                if seq is not parent:\n                    seq_group.add(seq)\n                    if not seq.is_finished():\n                        self.scheduler.fork_seq(parent, seq)\n\n            # Free the finished and selected parent sequences' memory in block\n            # manager. Keep them in the sequence group as candidate output.\n            # NOTE: we need to fork the new sequences before freeing the\n            # old sequences.\n            for seq, parent in child_seqs:\n                if seq is parent and seq.is_finished():\n                    self.scheduler.free_seq(seq)\n            return\n\n        # Beam search case\n        # Select the child sequences to keep in the sequence group.\n        selected_child_seqs = []\n        unselected_child_seqs = []\n        beam_width = seq_group.sampling_params.best_of\n        length_penalty = seq_group.sampling_params.length_penalty\n\n        # Select the newly finished sequences with the highest scores\n        # to replace existing finished sequences.\n        # Tuple of (seq, parent, is_new)\n        existing_finished_seqs = [(seq, None, False)\n                                  for seq in existing_finished_seqs]\n        new_finished_seqs = [(seq, parent, True) for seq, parent in child_seqs\n                             if seq.is_finished()]\n        all_finished_seqs = existing_finished_seqs + new_finished_seqs\n        # Sort the finished sequences by their scores.\n        all_finished_seqs.sort(key=lambda x: x[0].get_beam_search_score(\n            length_penalty=length_penalty, eos_token_id=x[0].eos_token_id),\n                               reverse=True)\n        for seq, parent, is_new in all_finished_seqs[:beam_width]:\n            if is_new:\n                # A newly generated child sequence finishes and has a high\n                # score, so we will add it into the sequence group.\n                selected_child_seqs.append((seq, parent))\n        for seq, parent, is_new in all_finished_seqs[beam_width:]:\n            if is_new:\n                # A newly generated child sequence finishes but has a low\n                # score, so we will not add it into the sequence group.\n                # Additionally, if this sequence is a continuation of a\n                # parent sequence, we will need remove the parent sequence\n                # from the sequence group.\n                unselected_child_seqs.append((seq, parent))\n            else:\n                # An existing finished sequence has a low score, so we will\n                # remove it from the sequence group.\n                seq_group.remove(seq.seq_id)\n\n        # select the top beam_width sequences from the running\n        # sequences for the next iteration to continue the beam\n        # search.\n        running_child_seqs = [(seq, parent) for seq, parent in child_seqs\n                              if not seq.is_finished()]\n        # Sort the running sequences by their scores.\n        running_child_seqs.sort(key=lambda x: x[0].get_beam_search_score(\n            length_penalty=length_penalty, eos_token_id=x[0].eos_token_id),\n                                reverse=True)\n\n        # Check if we can stop the beam search.\n        if len(running_child_seqs) == 0:\n            # No running sequences, stop the beam search.\n            stop_beam_search = True\n        elif len(all_finished_seqs) < beam_width:\n            # Not enough finished sequences, continue the beam search.\n            stop_beam_search = False\n        else:\n            # Check the early stopping criteria\n            best_running_seq = running_child_seqs[0][0]\n            current_worst_seq = all_finished_seqs[beam_width - 1][0]\n            stop_beam_search = self._check_beam_search_early_stopping(\n                seq_group.sampling_params.early_stopping,\n                seq_group.sampling_params, best_running_seq, current_worst_seq)\n\n        if stop_beam_search:\n            # Stop the beam search and remove all the running sequences from\n            # the sequence group.\n            unselected_child_seqs.extend(running_child_seqs)\n        else:\n            # Continue the beam search and select the top beam_width sequences\n            # to continue the beam search.\n            selected_child_seqs.extend(running_child_seqs[:beam_width])\n            # The remaining running sequences will not be used in the next\n            # iteration. Again, if these sequences are continuations of\n            # parent sequences, we will need to remove the parent sequences\n            # from the sequence group.\n            unselected_child_seqs.extend(running_child_seqs[beam_width:])\n\n        # For newly created child sequences, add them to the sequence group\n        # and fork them in block manager if they are not finished.\n        for seq, parent in selected_child_seqs:\n            if seq is not parent:\n                seq_group.add(seq)\n                if not seq.is_finished():\n                    self.scheduler.fork_seq(parent, seq)\n\n        # Free the finished and selected parent sequences' memory in block\n        # manager. Keep them in the sequence group as candidate output.\n        for seq, parent in selected_child_seqs:\n            if seq is parent and seq.is_finished():\n                self.scheduler.free_seq(seq)\n\n        # Remove the unselected parent sequences from the sequence group and\n        # free their memory in block manager.\n        for seq, parent in unselected_child_seqs:\n            if seq is parent:\n                # Remove the parent sequence if it is not selected for next\n                # iteration\n                seq_group.remove(seq.seq_id)\n                self.scheduler.free_seq(seq)\n\n    def _process_model_outputs(\n            self, output: SamplerOutput,\n            scheduler_outputs: SchedulerOutputs) -> List[RequestOutput]:\n        now = time.time()\n        # Update the scheduled sequence groups with the model outputs.\n        scheduled_seq_groups = scheduler_outputs.scheduled_seq_groups\n\n        # If prefix caching is enabled, mark all blocks in the sequence groups\n        # as completed so that future requests don't attempt to recompute them\n        if self.cache_config.enable_prefix_caching:\n            for seq_group in scheduled_seq_groups:\n                self.scheduler.mark_blocks_as_computed(seq_group)\n\n        for seq_group, outputs in zip(scheduled_seq_groups, output):\n            self._process_sequence_group_outputs(seq_group, outputs)\n\n        # Free the finished sequence groups.\n        self.scheduler.free_finished_seq_groups()\n\n        # Create the outputs.\n        request_outputs: List[RequestOutput] = []\n        for seq_group in scheduled_seq_groups:\n            seq_group.maybe_set_first_token_time(now)\n            request_output = RequestOutput.from_seq_group(seq_group)\n            request_outputs.append(request_output)\n        for seq_group in scheduler_outputs.ignored_seq_groups:\n            request_output = RequestOutput.from_seq_group(seq_group)\n            request_outputs.append(request_output)\n\n        # Log stats.\n        if self.log_stats:\n            self.stat_logger.log(self._get_stats(scheduler_outputs))\n        return request_outputs\n\n    def step(self) -> List[RequestOutput]:\n        \"\"\"Performs one decoding iteration and returns newly generated results.\n\n        .. figure:: https://i.imgur.com/sv2HssD.png\n            :alt: Overview of the step function\n            :align: center\n\n            Overview of the step function.\n\n        Details:\n            - Step 1: Schedules the sequences to be executed in the next\n              iteration and the token blocks to be swapped in/out/copy.\n\n                - Depending on the scheduling policy,\n                  sequences may be `preempted/reordered`.\n                - A Sequence Group (SG) refer to a group of sequences\n                  that are generated from the same prompt.\n\n            - Step 2: Calls the distributed executor to execute the model.\n            - Step 3: Processes the model output. This mainly includes:\n\n                - Decodes the relevant outputs.\n                - Updates the scheduled sequence groups with model outputs\n                  based on its `sampling parameters` (`use_beam_search` or not).\n                - Frees the finished sequence groups.\n\n            - Finally, it creates and returns the newly generated results.\n\n        Example:\n            >>> # Please see the example/ folder for more detailed examples.\n            >>>\n            >>> # initialize engine and request arguments\n            >>> engine = LLMEngine.from_engine_args(engine_args)\n            >>> example_inputs = [(0, \"What is LLM?\",\n            >>>    SamplingParams(temperature=0.0))]\n            >>>\n            >>> # Start the engine with an event loop\n            >>> while True:\n            >>>     if example_inputs:\n            >>>         req_id, prompt, sampling_params = example_inputs.pop(0)\n            >>>         engine.add_request(str(req_id), prompt, sampling_params)\n            >>>\n            >>>     # continue the request processing\n            >>>     request_outputs = engine.step()\n            >>>     for request_output in request_outputs:\n            >>>         if request_output.finished:\n            >>>             # return or show the request output\n            >>>\n            >>>     if not (engine.has_unfinished_requests() or example_inputs):\n            >>>         break\n        \"\"\"\n        seq_group_metadata_list, scheduler_outputs = self.scheduler.schedule()\n\n        if not scheduler_outputs.is_empty():\n            output = self.model_executor.execute_model(\n                seq_group_metadata_list, scheduler_outputs.blocks_to_swap_in,\n                scheduler_outputs.blocks_to_swap_out,\n                scheduler_outputs.blocks_to_copy)\n        else:\n            output = []\n\n        return self._process_model_outputs(output, scheduler_outputs)\n\n    def do_log_stats(self) -> None:\n        \"\"\"Forced log when no requests active.\"\"\"\n        if self.log_stats:\n            self.stat_logger.log(self._get_stats(scheduler_outputs=None))\n\n    def _get_stats(self,\n                   scheduler_outputs: Optional[SchedulerOutputs]) -> Stats:\n        \"\"\"Get Stats to be Logged to Prometheus.\"\"\"\n        now = time.time()\n\n        # KV Cache Usage in %.\n        num_total_gpu = self.cache_config.num_gpu_blocks\n        num_free_gpu = self.scheduler.block_manager.get_num_free_gpu_blocks()\n        gpu_cache_usage = 1.0 - (num_free_gpu / num_total_gpu)\n\n        num_total_cpu = self.cache_config.num_cpu_blocks\n        cpu_cache_usage = 0.\n        if num_total_cpu > 0:\n            num_free_cpu = self.scheduler.block_manager.get_num_free_cpu_blocks(\n            )\n            cpu_cache_usage = 1.0 - (num_free_cpu / num_total_cpu)\n\n        # Scheduler State\n        num_running = len(self.scheduler.running)\n        num_swapped = len(self.scheduler.swapped)\n        num_waiting = len(self.scheduler.waiting)\n\n        # Iteration stats if we have scheduler output.\n        num_prompt_tokens = 0\n        num_generation_tokens = 0\n        time_to_first_tokens = []\n        time_per_output_tokens = []\n        time_e2e_requests = []\n        if scheduler_outputs is not None:\n            prompt_run = scheduler_outputs.prompt_run\n\n            # Number of Tokens.\n            if prompt_run:\n                num_prompt_tokens = sum(\n                    len(seq_group.prompt_token_ids)\n                    for seq_group in scheduler_outputs.scheduled_seq_groups)\n                num_generation_tokens = sum(\n                    seq_group.num_seqs()\n                    for seq_group in scheduler_outputs.scheduled_seq_groups)\n            else:\n                num_generation_tokens = scheduler_outputs.num_batched_tokens\n\n            # Latency Timings.\n            time_last_iters = []\n            for seq_group in scheduler_outputs.scheduled_seq_groups:\n                # Time since last token.\n                # (n.b. updates seq_group.metrics.last_token_time)\n                time_last_iters.append(seq_group.get_last_latency(now))\n                # Time since arrival for all finished requests.\n                if seq_group.is_finished():\n                    time_e2e_requests.append(now -\n                                             seq_group.metrics.arrival_time)\n\n            time_to_first_tokens = time_last_iters if prompt_run else []\n            time_per_output_tokens = [] if prompt_run else time_last_iters\n\n        return Stats(\n            now=now,\n            num_running=num_running,\n            num_swapped=num_swapped,\n            num_waiting=num_waiting,\n            gpu_cache_usage=gpu_cache_usage,\n            cpu_cache_usage=cpu_cache_usage,\n            num_prompt_tokens=num_prompt_tokens,\n            num_generation_tokens=num_generation_tokens,\n            time_to_first_tokens=time_to_first_tokens,\n            time_per_output_tokens=time_per_output_tokens,\n            time_e2e_requests=time_e2e_requests,\n        )\n\n    def _decode_logprobs(self, seq: Sequence, prms: SamplingParams,\n                         logprobs: Dict[int, Logprob],\n                         all_input_ids: List[int]) -> None:\n        if not logprobs:\n            return\n        for token_id, sample_logprob in logprobs.items():\n            if (sample_logprob.decoded_token is None and token_id != -1):\n                all_input_ids_with_logprob = all_input_ids[:-1] + [token_id]\n                (_, new_text, prefix_offset,\n                 read_offset) = detokenize_incrementally(\n                     self.get_tokenizer_for_seq(seq),\n                     all_input_ids=all_input_ids_with_logprob,\n                     prev_tokens=seq.tokens,\n                     prefix_offset=seq.prefix_offset,\n                     read_offset=seq.read_offset,\n                     skip_special_tokens=prms.skip_special_tokens,\n                     spaces_between_special_tokens=prms.\n                     spaces_between_special_tokens,\n                 )\n                sample_logprob.decoded_token = new_text\n\n    def _decode_sequence(self, seq: Sequence, prms: SamplingParams) -> None:\n        \"\"\"Decodes the new token for a sequence.\"\"\"\n        all_input_ids = seq.get_token_ids()\n        self._decode_logprobs(seq, prms, seq.output_logprobs[-1],\n                              all_input_ids)\n\n        (new_tokens, new_output_text, prefix_offset,\n         read_offset) = detokenize_incrementally(\n             self.get_tokenizer_for_seq(seq),\n             all_input_ids=all_input_ids,\n             prev_tokens=seq.tokens,\n             prefix_offset=seq.prefix_offset,\n             read_offset=seq.read_offset,\n             skip_special_tokens=prms.skip_special_tokens,\n             spaces_between_special_tokens=prms.spaces_between_special_tokens,\n         )\n        if seq.tokens is None:\n            seq.tokens = new_tokens\n        else:\n            seq.tokens.extend(new_tokens)\n        seq.prefix_offset = prefix_offset\n        seq.read_offset = read_offset\n        seq.output_text += new_output_text\n\n    def _check_stop(self, seq: Sequence,\n                    sampling_params: SamplingParams) -> None:\n        \"\"\"Stop the finished sequences.\"\"\"\n        for stop_str in sampling_params.stop:\n            if seq.output_text.endswith(stop_str):\n                self._finalize_sequence(seq, sampling_params, stop_str)\n                seq.status = SequenceStatus.FINISHED_STOPPED\n                return\n        if seq.get_last_token_id() in sampling_params.stop_token_ids:\n            stop_str = self.get_tokenizer_for_seq(seq).convert_ids_to_tokens(\n                seq.get_last_token_id())\n            self._finalize_sequence(seq, sampling_params, stop_str)\n            seq.status = SequenceStatus.FINISHED_STOPPED\n            return\n\n        # Check if the sequence has reached max_model_len.\n        if seq.get_len() > self.scheduler_config.max_model_len:\n            seq.status = SequenceStatus.FINISHED_LENGTH_CAPPED\n            return\n\n        # Check if the sequence has reached max_tokens.\n        if seq.get_output_len() == sampling_params.max_tokens:\n            seq.status = SequenceStatus.FINISHED_LENGTH_CAPPED\n            return\n\n        # Check if the sequence has generated the EOS token.\n        if ((not sampling_params.ignore_eos)\n                and seq.get_last_token_id() == seq.eos_token_id):\n            seq.status = SequenceStatus.FINISHED_STOPPED\n            return\n\n    def _finalize_sequence(self, seq: Sequence,\n                           sampling_params: SamplingParams,\n                           stop_string: str) -> None:\n        if sampling_params.include_stop_str_in_output:\n            return\n\n        if stop_string and seq.output_text.endswith(stop_string):\n            # Truncate the output text so that the stop string is\n            # not included in the output.\n            seq.output_text = seq.output_text[:-len(stop_string)]\n\n    def add_lora(self, lora_request: LoRARequest) -> bool:\n        return self.model_executor.add_lora(lora_request)\n\n    def remove_lora(self, lora_id: int) -> bool:\n        return self.model_executor.remove_lora(lora_id)\n\n    def list_loras(self) -> List[int]:\n        return self.model_executor.list_loras()\n\n    def check_health(self) -> None:\n        self.model_executor.check_health()\n",
      "diff": "diff --git a/vllm/engine/llm_engine.py b/vllm/engine/llm_engine.py\nindex 724782841..283b5d9ac 100644\n--- a/vllm/engine/llm_engine.py\n+++ b/vllm/engine/llm_engine.py\n@@ -1,5 +1,5 @@\n import time\n-from typing import Dict, Iterable, List, Optional, Tuple, Type, Union\n+from typing import Iterable, List, Optional, Tuple, Type, Union\n \n from transformers import PreTrainedTokenizer\n \n@@ -15,11 +15,11 @@ from vllm.engine.ray_utils import initialize_ray_cluster\n from vllm.logger import init_logger\n from vllm.outputs import RequestOutput\n from vllm.sampling_params import SamplingParams\n-from vllm.sequence import (Logprob, SamplerOutput, Sequence, SequenceGroup,\n+from vllm.sequence import (SamplerOutput, Sequence, SequenceGroup,\n                            SequenceGroupOutput, SequenceOutput, SequenceStatus)\n-from vllm.transformers_utils.tokenizer import detokenize_incrementally\n from vllm.transformers_utils.tokenizer_group import (BaseTokenizerGroup,\n                                                      get_tokenizer_group)\n+from vllm.transformers_utils.detokenizer import Detokenizer\n from vllm.utils import Counter\n \n logger = init_logger(__name__)\n@@ -97,6 +97,7 @@ class LLMEngine:\n         self._verify_args()\n \n         self._init_tokenizer()\n+        self.detokenizer = Detokenizer(self.tokenizer)\n         self.seq_counter = Counter()\n \n         self.model_executor = executor_class(model_config, cache_config,\n@@ -153,7 +154,7 @@ class LLMEngine:\n         raise RuntimeError(\"LLMEngine should not be pickled!\")\n \n     def get_tokenizer(self) -> \"PreTrainedTokenizer\":\n-        return self.tokenizer.get_lora_tokenizer()\n+        return self.tokenizer.get_lora_tokenizer(None)\n \n     def get_tokenizer_for_seq(self,\n                               sequence: Sequence) -> \"PreTrainedTokenizer\":\n@@ -370,13 +371,8 @@ class LLMEngine:\n         # Process prompt logprobs\n         prompt_logprobs = outputs.prompt_logprobs\n         if prompt_logprobs is not None:\n-            # We can pick any sequence for the prompt.\n-            seq = next(iter(seq_group.seqs_dict.values()))\n-            all_token_ids = seq.get_token_ids()\n-            for i, prompt_logprobs_for_token in enumerate(prompt_logprobs):\n-                self._decode_logprobs(seq, seq_group.sampling_params,\n-                                      prompt_logprobs_for_token,\n-                                      all_token_ids[:i])\n+            self.detokenizer.decode_prompt_logprobs_inplace(\n+                seq_group, prompt_logprobs)\n             seq_group.prompt_logprobs = prompt_logprobs\n \n         # Process samples\n@@ -420,7 +416,8 @@ class LLMEngine:\n             child_seqs.append((parent, parent))\n \n         for seq, _ in child_seqs:\n-            self._decode_sequence(seq, seq_group.sampling_params)\n+            self.detokenizer.decode_sequence_inplace(seq,\n+                                                     seq_group.sampling_params)\n             self._check_stop(seq, seq_group.sampling_params)\n \n         # Non-beam search case\n@@ -713,51 +710,6 @@ class LLMEngine:\n             time_e2e_requests=time_e2e_requests,\n         )\n \n-    def _decode_logprobs(self, seq: Sequence, prms: SamplingParams,\n-                         logprobs: Dict[int, Logprob],\n-                         all_input_ids: List[int]) -> None:\n-        if not logprobs:\n-            return\n-        for token_id, sample_logprob in logprobs.items():\n-            if (sample_logprob.decoded_token is None and token_id != -1):\n-                all_input_ids_with_logprob = all_input_ids[:-1] + [token_id]\n-                (_, new_text, prefix_offset,\n-                 read_offset) = detokenize_incrementally(\n-                     self.get_tokenizer_for_seq(seq),\n-                     all_input_ids=all_input_ids_with_logprob,\n-                     prev_tokens=seq.tokens,\n-                     prefix_offset=seq.prefix_offset,\n-                     read_offset=seq.read_offset,\n-                     skip_special_tokens=prms.skip_special_tokens,\n-                     spaces_between_special_tokens=prms.\n-                     spaces_between_special_tokens,\n-                 )\n-                sample_logprob.decoded_token = new_text\n-\n-    def _decode_sequence(self, seq: Sequence, prms: SamplingParams) -> None:\n-        \"\"\"Decodes the new token for a sequence.\"\"\"\n-        all_input_ids = seq.get_token_ids()\n-        self._decode_logprobs(seq, prms, seq.output_logprobs[-1],\n-                              all_input_ids)\n-\n-        (new_tokens, new_output_text, prefix_offset,\n-         read_offset) = detokenize_incrementally(\n-             self.get_tokenizer_for_seq(seq),\n-             all_input_ids=all_input_ids,\n-             prev_tokens=seq.tokens,\n-             prefix_offset=seq.prefix_offset,\n-             read_offset=seq.read_offset,\n-             skip_special_tokens=prms.skip_special_tokens,\n-             spaces_between_special_tokens=prms.spaces_between_special_tokens,\n-         )\n-        if seq.tokens is None:\n-            seq.tokens = new_tokens\n-        else:\n-            seq.tokens.extend(new_tokens)\n-        seq.prefix_offset = prefix_offset\n-        seq.read_offset = read_offset\n-        seq.output_text += new_output_text\n-\n     def _check_stop(self, seq: Sequence,\n                     sampling_params: SamplingParams) -> None:\n         \"\"\"Stop the finished sequences.\"\"\"",
      "change_type": "modified",
      "lines_added": 10,
      "lines_removed": 58
    },
    {
      "file_path": "vllm/transformers_utils/detokenizer.py",
      "old_content": "",
      "diff": "diff --git a/vllm/transformers_utils/detokenizer.py b/vllm/transformers_utils/detokenizer.py\nnew file mode 100644\nindex 000000000..1f322b367\n--- /dev/null\n+++ b/vllm/transformers_utils/detokenizer.py\n@@ -0,0 +1,155 @@\n+from typing import List, Dict, Optional\n+from transformers import PreTrainedTokenizer\n+from vllm.sequence import Sequence, Logprob, SequenceGroup, SamplingParams\n+from vllm.transformers_utils.tokenizer import (detokenize_incrementally,\n+                                               convert_prompt_ids_to_tokens)\n+from vllm.transformers_utils.tokenizer_group.base_tokenizer_group import (\n+    BaseTokenizerGroup)\n+\n+# Used eg. for marking rejected tokens in spec decoding.\n+INVALID_TOKEN_ID = -1\n+\n+\n+class Detokenizer:\n+    \"\"\"Provides methods to decode the output of a model into text.\"\"\"\n+\n+    def __init__(self, tokenizer_group: BaseTokenizerGroup):\n+        self.tokenizer_group = tokenizer_group\n+\n+    def get_tokenizer_for_seq(self,\n+                              sequence: Sequence) -> \"PreTrainedTokenizer\":\n+        \"\"\"Returns the HF tokenizer to use for a given sequence.\"\"\"\n+        return self.tokenizer_group.get_lora_tokenizer(sequence.lora_request)\n+\n+    def decode_prompt_logprobs_inplace(\n+            self, seq_group: SequenceGroup,\n+            prompt_logprobs: List[Optional[Dict[int, Logprob]]]) -> None:\n+        \"\"\"Decodes the logprobs for the prompt of a sequence group.\n+\n+        Args:\n+            seq_group: The sequence group to decode.\n+            prompt_logprobs: The logprobs to decode.\n+        \n+        Returns:\n+            The prompt logprobs with the decoded tokens.\n+        \"\"\"\n+        prms = seq_group.sampling_params\n+        # We can pick any sequence for the prompt.\n+        seq = next(iter(seq_group.seqs_dict.values()))\n+        # Only prompt, without the generated token.\n+        all_token_ids = seq.get_token_ids()\n+        prompt_token_ids = all_token_ids[:-1]\n+        tokenizer = self.get_tokenizer_for_seq(seq)\n+        prefix_offset = 0\n+        read_offset = 0\n+        next_iter_prefix_offset = 0\n+        next_iter_read_offset = 0\n+        next_iter_tokens = []\n+        prev_tokens = None\n+\n+        for token_position, prompt_logprobs_for_token in enumerate(\n+                prompt_logprobs):\n+            if not prompt_logprobs_for_token:\n+                continue\n+            for token_id, sample_logprob in prompt_logprobs_for_token.items():\n+                if (sample_logprob.decoded_token is None\n+                        and token_id != INVALID_TOKEN_ID):\n+                    prompt_token_ids_with_token = (\n+                        prompt_token_ids[:token_position] + [token_id])\n+                    (new_tokens, new_text, new_prefix_offset,\n+                     new_read_offset) = detokenize_incrementally(\n+                         tokenizer=tokenizer,\n+                         all_input_ids=prompt_token_ids_with_token,\n+                         prev_tokens=prev_tokens,\n+                         prefix_offset=prefix_offset,\n+                         read_offset=read_offset,\n+                         skip_special_tokens=prms.skip_special_tokens,\n+                         spaces_between_special_tokens=prms.\n+                         spaces_between_special_tokens,\n+                     )\n+\n+                    sample_logprob.decoded_token = new_text\n+\n+                    # Use the offsets & prev tokens corresponding to\n+                    # real tokens to ensure detokenization is consistent\n+                    # actual with prompt.\n+                    if token_id == all_token_ids[token_position]:\n+                        next_iter_prefix_offset = new_prefix_offset\n+                        next_iter_read_offset = new_read_offset\n+                        next_iter_tokens = new_tokens\n+\n+            # Advance to the next token position.\n+            prefix_offset = next_iter_prefix_offset\n+            read_offset = next_iter_read_offset\n+            if prev_tokens is None:\n+                prev_tokens = next_iter_tokens\n+            else:\n+                prev_tokens.extend(next_iter_tokens)\n+\n+    def decode_sequence_inplace(self, seq: Sequence,\n+                                prms: SamplingParams) -> None:\n+        \"\"\"Decodes the new token for a sequence. In-place operation.\n+\n+        Args:\n+            seq: The sequence to decode.\n+            prms: The sampling parameters used to generate the sequence.\n+        \"\"\"\n+        all_input_ids = seq.get_token_ids()\n+        token_id_generated_this_iteration = all_input_ids[-1]\n+        tokenizer = self.get_tokenizer_for_seq(seq)\n+\n+        # Convert prompt token IDs to tokens if necessary.\n+        # Do it here so that we don't have to repeat this\n+        # computation for each logprob.\n+        if seq.tokens is None:\n+            (seq.tokens, seq.prefix_offset,\n+             seq.read_offset) = convert_prompt_ids_to_tokens(\n+                 tokenizer=tokenizer,\n+                 prompt_ids=all_input_ids[:-1],\n+                 skip_special_tokens=prms.skip_special_tokens,\n+             )\n+\n+        (new_tokens, new_decoded_token_text, prefix_offset,\n+         read_offset) = detokenize_incrementally(\n+             tokenizer=tokenizer,\n+             all_input_ids=all_input_ids,\n+             prev_tokens=seq.tokens,\n+             prefix_offset=seq.prefix_offset,\n+             read_offset=seq.read_offset,\n+             skip_special_tokens=prms.skip_special_tokens,\n+             spaces_between_special_tokens=prms.spaces_between_special_tokens,\n+         )\n+\n+        # Decode logprobs\n+        logprobs = seq.output_logprobs[-1]\n+        if logprobs:\n+            previous_tokens = all_input_ids[:-1]\n+            for token_id, sample_logprob in logprobs.items():\n+                # If the token was generated this iteration,\n+                # use the provided text.\n+                if token_id == token_id_generated_this_iteration:\n+                    sample_logprob.decoded_token = new_decoded_token_text\n+                    continue\n+\n+                if (sample_logprob.decoded_token is None\n+                        and token_id != INVALID_TOKEN_ID):\n+                    all_input_ids_with_logprob = previous_tokens + [token_id]\n+                    (_, new_text, _, _) = detokenize_incrementally(\n+                        tokenizer=tokenizer,\n+                        all_input_ids=all_input_ids_with_logprob,\n+                        prev_tokens=seq.tokens,\n+                        prefix_offset=seq.prefix_offset,\n+                        read_offset=seq.read_offset,\n+                        skip_special_tokens=prms.skip_special_tokens,\n+                        spaces_between_special_tokens=prms.\n+                        spaces_between_special_tokens,\n+                    )\n+                    sample_logprob.decoded_token = new_text\n+\n+        if seq.tokens is None:\n+            seq.tokens = new_tokens\n+        else:\n+            seq.tokens.extend(new_tokens)\n+        seq.prefix_offset = prefix_offset\n+        seq.read_offset = read_offset\n+        seq.output_text += new_decoded_token_text",
      "change_type": "added",
      "lines_added": 156,
      "lines_removed": 1
    },
    {
      "file_path": "vllm/transformers_utils/tokenizer.py",
      "old_content": "from typing import List, Optional, Tuple, Union\n\nfrom transformers import (AutoTokenizer, PreTrainedTokenizer,\n                          PreTrainedTokenizerFast)\n\nfrom vllm.logger import init_logger\nfrom vllm.lora.request import LoRARequest\nfrom vllm.utils import make_async\nfrom vllm.transformers_utils.tokenizers import *\n\nlogger = init_logger(__name__)\n\n\ndef get_cached_tokenizer(\n    tokenizer: Union[PreTrainedTokenizer, PreTrainedTokenizerFast]\n) -> Union[PreTrainedTokenizer, PreTrainedTokenizerFast]:\n    \"\"\"Get tokenizer with cached properties.\n\n    This will patch the tokenizer object in place.\n\n    By default, transformers will recompute multiple tokenizer properties\n    each time they are called, leading to a significant slowdown. This\n    function caches these properties for faster access.\"\"\"\n\n    tokenizer_all_special_ids = set(tokenizer.all_special_ids)\n    tokenizer_all_special_tokens_extended = (\n        tokenizer.all_special_tokens_extended)\n    tokenizer_all_special_tokens = set(tokenizer.all_special_tokens)\n\n    class CachedTokenizer(tokenizer.__class__):\n\n        @property\n        def all_special_ids(self):\n            return tokenizer_all_special_ids\n\n        @property\n        def all_special_tokens(self):\n            return tokenizer_all_special_tokens\n\n        @property\n        def all_special_tokens_extended(self):\n            return tokenizer_all_special_tokens_extended\n\n    CachedTokenizer.__name__ = f\"Cached{tokenizer.__class__.__name__}\"\n\n    tokenizer.__class__ = CachedTokenizer\n    return tokenizer\n\n\ndef get_tokenizer(\n    tokenizer_name: str,\n    *args,\n    tokenizer_mode: str = \"auto\",\n    trust_remote_code: bool = False,\n    tokenizer_revision: Optional[str] = None,\n    **kwargs,\n) -> Union[PreTrainedTokenizer, PreTrainedTokenizerFast]:\n    \"\"\"Gets a tokenizer for the given model name via Huggingface.\"\"\"\n    if tokenizer_mode == \"slow\":\n        if kwargs.get(\"use_fast\", False):\n            raise ValueError(\n                \"Cannot use the fast tokenizer in slow tokenizer mode.\")\n        kwargs[\"use_fast\"] = False\n\n    try:\n        tokenizer = AutoTokenizer.from_pretrained(\n            tokenizer_name,\n            *args,\n            trust_remote_code=trust_remote_code,\n            tokenizer_revision=tokenizer_revision,\n            **kwargs)\n    except ValueError as e:\n        # If the error pertains to the tokenizer class not existing or not\n        # currently being imported, suggest using the --trust-remote-code flag.\n        if (not trust_remote_code and\n            (\"does not exist or is not currently imported.\" in str(e)\n             or \"requires you to execute the tokenizer file\" in str(e))):\n            err_msg = (\n                \"Failed to load the tokenizer. If the tokenizer is a custom \"\n                \"tokenizer not yet available in the HuggingFace transformers \"\n                \"library, consider setting `trust_remote_code=True` in LLM \"\n                \"or using the `--trust-remote-code` flag in the CLI.\")\n            raise RuntimeError(err_msg) from e\n        else:\n            raise e\n    except AttributeError as e:\n        if \"BaichuanTokenizer\" in str(e):\n            # This is for the error \"'BaichuanTokenizer' object has no\n            # attribute 'sp_model'\".\n            tokenizer = BaichuanTokenizer.from_pretrained(\n                tokenizer_name,\n                *args,\n                trust_remote_code=trust_remote_code,\n                tokenizer_revision=tokenizer_revision,\n                **kwargs)\n        else:\n            raise e\n\n    if not isinstance(tokenizer, PreTrainedTokenizerFast):\n        logger.warning(\n            \"Using a slow tokenizer. This might cause a significant \"\n            \"slowdown. Consider using a fast tokenizer instead.\")\n    return get_cached_tokenizer(tokenizer)\n\n\ndef get_lora_tokenizer(lora_request: LoRARequest, *args,\n                       **kwargs) -> Optional[PreTrainedTokenizer]:\n    if lora_request is None:\n        return None\n    try:\n        tokenizer = get_tokenizer(lora_request.lora_local_path, *args,\n                                  **kwargs)\n    except OSError as e:\n        # No tokenizer was found in the LoRA folder,\n        # use base model tokenizer\n        logger.warning(\n            f\"No tokenizer found in {lora_request.lora_local_path}, \"\n            \"using base model tokenizer instead. \"\n            f\"(Exception: {str(e)})\")\n        tokenizer = None\n    return tokenizer\n\n\nget_lora_tokenizer_async = make_async(get_lora_tokenizer)\n\n\ndef _convert_tokens_to_string_with_added_encoders(\n    tokenizer: Union[PreTrainedTokenizer, PreTrainedTokenizerFast],\n    output_tokens: List[str],\n    skip_special_tokens: bool,\n    spaces_between_special_tokens: bool,\n) -> str:\n    # Adapted from\n    # https://github.com/huggingface/transformers/blob/v4.28.0/src/transformers/tokenization_utils.py#L921\n    # NOTE(woosuk): The following code is slow because it runs a for loop over\n    # the output_tokens. In Python, running a for loop over a list can be slow\n    # even when the loop body is very simple.\n    sub_texts = []\n    current_sub_text = []\n    all_special_tokens = set(tokenizer.all_special_tokens)\n    for token in output_tokens:\n        if skip_special_tokens and token in all_special_tokens:\n            continue\n        if token in tokenizer.get_added_vocab():\n            if current_sub_text:\n                sub_text = tokenizer.convert_tokens_to_string(current_sub_text)\n                sub_texts.append(sub_text)\n                current_sub_text = []\n            sub_texts.append(token)\n        else:\n            current_sub_text.append(token)\n    if current_sub_text:\n        sub_text = tokenizer.convert_tokens_to_string(current_sub_text)\n        sub_texts.append(sub_text)\n    if spaces_between_special_tokens:\n        return \" \".join(sub_texts)\n    else:\n        return \"\".join(sub_texts)\n\n\n# Based on\n# https://github.com/huggingface/text-generation-inference/blob/v0.9.4/server/text_generation_server/models/model.py#L62C9-L62C15\n# under Apache 2.0 license\ndef detokenize_incrementally(\n    tokenizer: Union[PreTrainedTokenizer, PreTrainedTokenizerFast],\n    all_input_ids: List[int],\n    prev_tokens: Optional[List[str]],\n    prefix_offset: int = 0,\n    read_offset: int = 0,\n    skip_special_tokens: bool = False,\n    spaces_between_special_tokens: bool = True,\n) -> Tuple[List[str], str, int, int]:\n    new_token_id = all_input_ids[-1]\n    # This is the first iteration for this sequence\n    if prev_tokens is None:\n        new_tokens = tokenizer.convert_ids_to_tokens(\n            all_input_ids, skip_special_tokens=skip_special_tokens)\n        output_tokens = new_tokens\n        # 5 is an arbitrary value that should work for all\n        # tokenizers (bigger = more conservative).\n        # Subtract 1 extra to account for the generated token.\n        prefix_offset = max(len(output_tokens) - 6, 0)\n        # If the first new token is a special token, we can't skip 1 extra token\n        if skip_special_tokens and new_token_id in tokenizer.all_special_ids:\n            read_offset = max(len(output_tokens), 0)\n        else:\n            read_offset = max(len(output_tokens) - 1, 0)\n    else:\n        # Put new_token_id in a list so skip_special_tokens is respected\n        new_tokens = tokenizer.convert_ids_to_tokens(\n            [new_token_id], skip_special_tokens=skip_special_tokens)\n        output_tokens = prev_tokens + new_tokens\n\n    # The prefix text is necessary only to defeat cleanup algorithms in\n    # the decode which decide to add a space or not depending on the\n    # surrounding ids.\n    if tokenizer.is_fast or not tokenizer.get_added_vocab():\n        prefix_text = tokenizer.convert_tokens_to_string(\n            output_tokens[prefix_offset:read_offset])\n        new_text = tokenizer.convert_tokens_to_string(\n            output_tokens[prefix_offset:])\n    else:\n        prefix_text = _convert_tokens_to_string_with_added_encoders(\n            tokenizer,\n            output_tokens[prefix_offset:read_offset],\n            skip_special_tokens=skip_special_tokens,\n            spaces_between_special_tokens=spaces_between_special_tokens,\n        )\n        new_text = _convert_tokens_to_string_with_added_encoders(\n            tokenizer,\n            output_tokens[prefix_offset:],\n            skip_special_tokens=skip_special_tokens,\n            spaces_between_special_tokens=spaces_between_special_tokens,\n        )\n\n    if len(new_text) > len(prefix_text) and not new_text.endswith(\"�\"):\n        # utf-8 char at the end means it's a potential unfinished byte sequence\n        # from byte fallback tokenization.\n        # If it's in the middle, it's probably a real invalid id generated\n        # by the model\n        new_text = new_text[len(prefix_text):]\n        return new_tokens, new_text, read_offset, len(output_tokens)\n    else:\n        return new_tokens, \"\", prefix_offset, read_offset\n",
      "diff": "diff --git a/vllm/transformers_utils/tokenizer.py b/vllm/transformers_utils/tokenizer.py\nindex f7a1a19a8..eebdacc49 100644\n--- a/vllm/transformers_utils/tokenizer.py\n+++ b/vllm/transformers_utils/tokenizer.py\n@@ -158,6 +158,34 @@ def _convert_tokens_to_string_with_added_encoders(\n         return \"\".join(sub_texts)\n \n \n+# 5 is an arbitrary value that should work for all\n+# tokenizers (bigger = more conservative).\n+INITIAL_INCREMENTAL_DETOKENIZATION_OFFSET = 5\n+\n+\n+def convert_prompt_ids_to_tokens(\n+    tokenizer: Union[PreTrainedTokenizer, PreTrainedTokenizerFast],\n+    prompt_ids: List[int],\n+    skip_special_tokens: bool = False,\n+) -> Tuple[List[str], int, int]:\n+    \"\"\"Converts the prompt ids to tokens and returns the tokens and offsets\n+    for incremental detokenization.\n+\n+    Note that not all tokens are converted to strings. Only the tokens that\n+    are necessary for incremental detokenization are converted to strings.\n+    \"\"\"\n+    # Offset a little more in case we have special tokens.\n+    prefix_offset = max(\n+        len(prompt_ids) - INITIAL_INCREMENTAL_DETOKENIZATION_OFFSET - 2, 0)\n+    # We do not need to convert the whole prompt to tokens.\n+    new_tokens = tokenizer.convert_ids_to_tokens(\n+        prompt_ids[prefix_offset:], skip_special_tokens=skip_special_tokens)\n+    prefix_offset = max(\n+        len(new_tokens) - INITIAL_INCREMENTAL_DETOKENIZATION_OFFSET, 0)\n+    read_offset = len(new_tokens)\n+    return new_tokens, prefix_offset, read_offset\n+\n+\n # Based on\n # https://github.com/huggingface/text-generation-inference/blob/v0.9.4/server/text_generation_server/models/model.py#L62C9-L62C15\n # under Apache 2.0 license\n@@ -165,31 +193,53 @@ def detokenize_incrementally(\n     tokenizer: Union[PreTrainedTokenizer, PreTrainedTokenizerFast],\n     all_input_ids: List[int],\n     prev_tokens: Optional[List[str]],\n-    prefix_offset: int = 0,\n-    read_offset: int = 0,\n+    prefix_offset: int,\n+    read_offset: int,\n     skip_special_tokens: bool = False,\n     spaces_between_special_tokens: bool = True,\n ) -> Tuple[List[str], str, int, int]:\n+    \"\"\"Detokenizes the input ids incrementally and returns the new tokens\n+    and the new text.\n+\n+    If `prev_tokens` is None, this function will convert the input ids to\n+    tokens and return the tokens and the new text. Otherwise, it will return the\n+    new tokens and the new text.\n+\n+    This function will also return the new prefix offset and the new read\n+    offset to be used in the next iteration.\n+\n+    The offsets are necessary to defeat cleanup algorithms in the decode which\n+    decide to add a space or not depending on the surrounding ids.\n+\n+    Args:\n+        tokenizer: The tokenizer to use.\n+        all_input_ids: The input ids. The last id is the new token id.\n+        prev_tokens: The previous tokens. If None, this function will convert\n+            the input ids to tokens and return the tokens and the new text.\n+        prefix_offset: The prefix offset.\n+        read_offset: The read offset.\n+        skip_special_tokens: Whether to skip special tokens.\n+        spaces_between_special_tokens: Whether to add spaces between special\n+            tokens.\n+    \"\"\"\n     new_token_id = all_input_ids[-1]\n     # This is the first iteration for this sequence\n-    if prev_tokens is None:\n-        new_tokens = tokenizer.convert_ids_to_tokens(\n-            all_input_ids, skip_special_tokens=skip_special_tokens)\n-        output_tokens = new_tokens\n-        # 5 is an arbitrary value that should work for all\n-        # tokenizers (bigger = more conservative).\n-        # Subtract 1 extra to account for the generated token.\n-        prefix_offset = max(len(output_tokens) - 6, 0)\n-        # If the first new token is a special token, we can't skip 1 extra token\n-        if skip_special_tokens and new_token_id in tokenizer.all_special_ids:\n-            read_offset = max(len(output_tokens), 0)\n-        else:\n-            read_offset = max(len(output_tokens) - 1, 0)\n-    else:\n-        # Put new_token_id in a list so skip_special_tokens is respected\n-        new_tokens = tokenizer.convert_ids_to_tokens(\n-            [new_token_id], skip_special_tokens=skip_special_tokens)\n-        output_tokens = prev_tokens + new_tokens\n+    is_first_iter = prev_tokens is None\n+    if is_first_iter:\n+        (prev_tokens, prefix_offset,\n+         read_offset) = convert_prompt_ids_to_tokens(\n+             tokenizer,\n+             all_input_ids[:-1],\n+             skip_special_tokens=skip_special_tokens)\n+\n+    # Put new_token_id in a list so skip_special_tokens is respected\n+    new_tokens = tokenizer.convert_ids_to_tokens(\n+        [new_token_id], skip_special_tokens=skip_special_tokens)\n+    output_tokens = prev_tokens + new_tokens\n+\n+    # If this is the first iteration, return all tokens.\n+    if is_first_iter:\n+        new_tokens = output_tokens\n \n     # The prefix text is necessary only to defeat cleanup algorithms in\n     # the decode which decide to add a space or not depending on the",
      "change_type": "modified",
      "lines_added": 71,
      "lines_removed": 21
    }
  ],
  "affected_apis": [
    "vllm.transformers_utils.detokenizer.Detokenizer.decode_sequence_inplace",
    "vllm.transformers_utils.detokenizer.Detokenizer.decode_prompt_logprobs_inplace",
    "vllm.transformers_utils.detokenizer.Detokenizer.get_tokenizer_for_seq",
    "vllm.engine.llm_engine.LLMEngine.get_tokenizer"
  ],
  "summary": {
    "total_files": 4,
    "files_added": 1,
    "files_deleted": 0,
    "files_modified": 3
  },
  "csv_metadata": {
    "category": "model-based",
    "json_has_tests": "TRUE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "Yes (test_detokenize, test_tokenizer, test_llm_engine)",
    "is_benchmark_actually_there": "",
    "sample_clues": "detokenizer, llm_engine, llmengine"
  }
}