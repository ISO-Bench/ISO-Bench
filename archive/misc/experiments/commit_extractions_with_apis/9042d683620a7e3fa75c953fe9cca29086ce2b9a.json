{
  "commit_hash": "9042d683620a7e3fa75c953fe9cca29086ce2b9a",
  "parent_hash": "3f8d42c81fe8d3842a9e05c9f5d98290b7f79736",
  "message": "[Misc] Consolidate and optimize logic for building padded tensors (#6541)",
  "author": "Cyrus Leung <tlleungac@connect.ust.hk>",
  "date": "2024-07-20 04:17:24 +0000",
  "files_changed": [
    {
      "file_path": "tests/conftest.py",
      "old_content": "import contextlib\nimport gc\nimport os\nimport sys\nfrom collections import UserList\nfrom typing import Any, Dict, List, Optional, Tuple, TypedDict, TypeVar\n\nimport pytest\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nfrom PIL import Image\nfrom transformers import (AutoModelForCausalLM, AutoModelForVision2Seq,\n                          AutoTokenizer, BatchEncoding)\n\nfrom vllm import LLM, SamplingParams\nfrom vllm.assets.image import ImageAsset\nfrom vllm.config import TokenizerPoolConfig\nfrom vllm.distributed import (destroy_distributed_environment,\n                              destroy_model_parallel)\nfrom vllm.inputs import TextPrompt\nfrom vllm.logger import init_logger\nfrom vllm.sequence import SampleLogprobs\nfrom vllm.utils import cuda_device_count_stateless, is_cpu\n\nlogger = init_logger(__name__)\n\n_TEST_DIR = os.path.dirname(__file__)\n_TEST_PROMPTS = [os.path.join(_TEST_DIR, \"prompts\", \"example.txt\")]\n_LONG_PROMPTS = [os.path.join(_TEST_DIR, \"prompts\", \"summary.txt\")]\n\n\ndef _read_prompts(filename: str) -> List[str]:\n    with open(filename, \"r\") as f:\n        prompts = f.readlines()\n        return prompts\n\n\nclass _ImageAssetPrompts(TypedDict):\n    stop_sign: str\n    cherry_blossom: str\n\n\nif sys.version_info < (3, 9):\n    # UserList cannot be subscripted\n    class _ImageAssetsBase(UserList):\n        pass\nelse:\n\n    class _ImageAssetsBase(UserList[ImageAsset]):\n        pass\n\n\nclass _ImageAssets(_ImageAssetsBase):\n\n    def __init__(self) -> None:\n        super().__init__([\n            ImageAsset(\"stop_sign\"),\n            ImageAsset(\"cherry_blossom\"),\n        ])\n\n    def prompts(self, prompts: _ImageAssetPrompts) -> List[str]:\n        \"\"\"\n        Convenience method to define the prompt for each test image.\n\n        The order of the returned prompts matches the order of the\n        assets when iterating through this object.\n        \"\"\"\n        return [prompts[\"stop_sign\"], prompts[\"cherry_blossom\"]]\n\n\nIMAGE_ASSETS = _ImageAssets()\n\"\"\"Singleton instance of :class:`_ImageAssets`.\"\"\"\n\n\ndef cleanup():\n    destroy_model_parallel()\n    destroy_distributed_environment()\n    with contextlib.suppress(AssertionError):\n        torch.distributed.destroy_process_group()\n    gc.collect()\n    if not is_cpu():\n        torch.cuda.empty_cache()\n\n\n@pytest.fixture()\ndef should_do_global_cleanup_after_test(request) -> bool:\n    \"\"\"Allow subdirectories to skip global cleanup by overriding this fixture.\n    This can provide a ~10x speedup for non-GPU unit tests since they don't need\n    to initialize torch.\n    \"\"\"\n\n    if request.node.get_closest_marker(\"skip_global_cleanup\"):\n        return False\n\n    return True\n\n\n@pytest.fixture(autouse=True)\ndef cleanup_fixture(should_do_global_cleanup_after_test: bool):\n    yield\n    if should_do_global_cleanup_after_test:\n        cleanup()\n\n\n@pytest.fixture\ndef example_prompts() -> List[str]:\n    prompts = []\n    for filename in _TEST_PROMPTS:\n        prompts += _read_prompts(filename)\n    return prompts\n\n\n@pytest.fixture\ndef example_long_prompts() -> List[str]:\n    prompts = []\n    for filename in _LONG_PROMPTS:\n        prompts += _read_prompts(filename)\n    return prompts\n\n\n@pytest.fixture(scope=\"session\")\ndef image_assets() -> _ImageAssets:\n    return IMAGE_ASSETS\n\n\n_STR_DTYPE_TO_TORCH_DTYPE = {\n    \"half\": torch.half,\n    \"bfloat16\": torch.bfloat16,\n    \"float\": torch.float,\n}\n\n_T = TypeVar(\"_T\", nn.Module, torch.Tensor, BatchEncoding)\n\n\nclass HfRunner:\n\n    def wrap_device(self, input: _T) -> _T:\n        if not is_cpu():\n            return input.to(\"cuda\")\n        else:\n            return input.to(\"cpu\")\n\n    def __init__(\n        self,\n        model_name: str,\n        dtype: str = \"half\",\n        *,\n        model_kwargs: Optional[Dict[str, Any]] = None,\n        is_embedding_model: bool = False,\n        is_vision_model: bool = False,\n        is_sparseml_model: bool = False,\n    ) -> None:\n        assert dtype in _STR_DTYPE_TO_TORCH_DTYPE\n        torch_dtype = _STR_DTYPE_TO_TORCH_DTYPE[dtype]\n\n        self.model_name = model_name\n\n        if is_embedding_model:\n            # Lazy init required for AMD CI\n            from sentence_transformers import SentenceTransformer\n            self.model = self.wrap_device(\n                SentenceTransformer(\n                    model_name,\n                    device=\"cpu\",\n                ).to(dtype=torch_dtype))\n        else:\n            if is_vision_model:\n                auto_cls = AutoModelForVision2Seq\n            elif is_sparseml_model:\n                from sparseml.transformers import SparseAutoModelForCausalLM\n                auto_cls = SparseAutoModelForCausalLM\n            else:\n                auto_cls = AutoModelForCausalLM\n\n            model_kwargs = model_kwargs if model_kwargs is not None else {}\n            self.model = self.wrap_device(\n                auto_cls.from_pretrained(\n                    model_name,\n                    torch_dtype=torch_dtype,\n                    trust_remote_code=True,\n                    **model_kwargs,\n                ))\n\n        self.tokenizer = AutoTokenizer.from_pretrained(\n            model_name,\n            torch_dtype=torch_dtype,\n            trust_remote_code=True,\n        )\n\n        try:\n            # don't put this import at the top level\n            # it will call torch.cuda.device_count()\n            from transformers import AutoProcessor  # noqa: F401\n            self.processor = AutoProcessor.from_pretrained(\n                model_name,\n                torch_dtype=torch_dtype,\n                trust_remote_code=True,\n            )\n        except Exception:\n            logger.warning(\n                \"Unable to auto-load processor from HuggingFace for \"\n                \"model %s. Using tokenizer instead.\", model_name)\n            self.processor = self.tokenizer\n\n    def generate(\n        self,\n        prompts: List[str],\n        images: Optional[List[Image.Image]] = None,\n        **kwargs: Any,\n    ) -> List[Tuple[List[List[int]], List[str]]]:\n        if images:\n            assert len(prompts) == len(images)\n\n        outputs: List[Tuple[List[List[int]], List[str]]] = []\n        for i, prompt in enumerate(prompts):\n            processor_kwargs: Dict[str, Any] = {\n                \"text\": prompt,\n                \"return_tensors\": \"pt\",\n            }\n            if images is not None and images[i] is not None:\n                processor_kwargs[\"images\"] = images[i]\n\n            inputs = self.processor(**processor_kwargs)\n\n            output_ids = self.model.generate(\n                **self.wrap_device(inputs),\n                use_cache=True,\n                **kwargs,\n            )\n            output_str = self.processor.batch_decode(\n                output_ids,\n                skip_special_tokens=True,\n                clean_up_tokenization_spaces=False,\n            )\n            output_ids = output_ids.cpu().tolist()\n            outputs.append((output_ids, output_str))\n        return outputs\n\n    def generate_greedy(\n        self,\n        prompts: List[str],\n        max_tokens: int,\n        images: Optional[List[Image.Image]] = None,\n        **kwargs: Any,\n    ) -> List[Tuple[List[int], str]]:\n        outputs = self.generate(prompts,\n                                do_sample=False,\n                                max_new_tokens=max_tokens,\n                                images=images,\n                                **kwargs)\n\n        return [(output_ids[0], output_str[0])\n                for output_ids, output_str in outputs]\n\n    def generate_beam_search(\n        self,\n        prompts: List[str],\n        beam_width: int,\n        max_tokens: int,\n    ) -> List[Tuple[List[List[int]], List[str]]]:\n        outputs = self.generate(prompts,\n                                do_sample=False,\n                                max_new_tokens=max_tokens,\n                                num_beams=beam_width,\n                                num_return_sequences=beam_width)\n        for i in range(len(outputs)):\n            output_ids, output_str = outputs[i]\n            for j in range(len(output_ids)):\n                output_ids[j] = [\n                    x for x in output_ids[j]\n                    if x != self.tokenizer.pad_token_id\n                ]\n            outputs[i] = (output_ids, output_str)\n        return outputs\n\n    def generate_greedy_logprobs(\n        self,\n        prompts: List[str],\n        max_tokens: int,\n        images: Optional[List[Image.Image]] = None,\n        **kwargs: Any,\n    ) -> List[List[torch.Tensor]]:\n        all_logprobs: List[List[torch.Tensor]] = []\n        for i, prompt in enumerate(prompts):\n            processor_kwargs: Dict[str, Any] = {\n                \"text\": prompt,\n                \"return_tensors\": \"pt\",\n            }\n            if images is not None and images[i] is not None:\n                processor_kwargs[\"images\"] = images[i]\n\n            inputs = self.processor(**processor_kwargs)\n\n            output = self.model.generate(\n                **self.wrap_device(inputs),\n                use_cache=True,\n                do_sample=False,\n                max_new_tokens=max_tokens,\n                output_hidden_states=True,\n                return_dict_in_generate=True,\n                **kwargs,\n            )\n            seq_logprobs: List[torch.Tensor] = []\n            for hidden_states in output.hidden_states:\n                last_hidden_states = hidden_states[-1][0]\n                logits = torch.matmul(\n                    last_hidden_states,\n                    self.model.get_output_embeddings().weight.t(),\n                )\n                if self.model.get_output_embeddings().bias is not None:\n                    logits += self.model.get_output_embeddings(\n                    ).bias.unsqueeze(0)\n                logprobs = F.log_softmax(logits, dim=-1, dtype=torch.float32)\n                seq_logprobs.append(logprobs)\n            all_logprobs.append(seq_logprobs)\n        return all_logprobs\n\n    def generate_greedy_logprobs_limit(\n        self,\n        prompts: List[str],\n        max_tokens: int,\n        num_logprobs: int,\n        images: Optional[List[Image.Image]] = None,\n        **kwargs: Any,\n    ) -> List[Tuple[List[int], str, List[Dict[int, float]]]]:\n        all_logprobs: List[List[Dict[int, float]]] = []\n        all_output_ids: List[List[int]] = []\n        all_output_strs: List[str] = []\n\n        for i, prompt in enumerate(prompts):\n            processor_kwargs: Dict[str, Any] = {\n                \"text\": prompt,\n                \"return_tensors\": \"pt\",\n            }\n            if images is not None and images[i] is not None:\n                processor_kwargs[\"images\"] = images[i]\n\n            inputs = self.processor(**processor_kwargs)\n            input_ids = inputs.input_ids\n\n            output = self.model.generate(\n                **self.wrap_device(inputs),\n                use_cache=True,\n                do_sample=False,\n                max_new_tokens=max_tokens,\n                output_hidden_states=True,\n                return_dict_in_generate=True,\n                **kwargs,\n            )\n\n            seq_logprobs: List[torch.Tensor] = []\n            for _, hidden_states in enumerate(output.hidden_states):\n                last_hidden_states = hidden_states[-1][0]\n                logits = torch.matmul(\n                    last_hidden_states,\n                    self.model.get_output_embeddings().weight.t(),\n                )\n                if getattr(self.model.get_output_embeddings(), \"bias\",\n                           None) is not None:\n                    logits += self.model.get_output_embeddings(\n                    ).bias.unsqueeze(0)\n                logprobs = F.log_softmax(logits, dim=-1, dtype=torch.float32)\n                seq_logprobs.append(logprobs)\n\n            # convert to dict\n            seq_logprobs_lst: List[Dict[int, float]] = []\n            for tok_idx, tok_logprobs in enumerate(seq_logprobs):\n                # drop prompt logprobs\n                if tok_idx == 0:\n                    tok_logprobs = tok_logprobs[-1, :].reshape(1, -1)\n                topk = tok_logprobs.topk(num_logprobs)\n\n                tok_logprobs_dct = {}\n                for token_id, logprob in zip(topk.indices[0], topk.values[0]):\n                    tok_logprobs_dct[token_id.item()] = logprob.item()\n\n                seq_logprobs_lst.append(tok_logprobs_dct)\n\n            all_logprobs.append(seq_logprobs_lst)\n            seq_ids = output.sequences[0]\n            output_len = seq_ids.shape[0] - input_ids.shape[1]\n            output_ids = seq_ids[-output_len:]\n            all_output_ids.append(output_ids.tolist())\n            all_output_strs.append(self.tokenizer.decode(output_ids))\n\n        outputs = zip(all_output_ids, all_output_strs, all_logprobs)\n        return [(output_ids, output_str, output_logprobs)\n                for output_ids, output_str, output_logprobs in outputs]\n\n    def encode(self, prompts: List[str]) -> List[List[torch.Tensor]]:\n        return self.model.encode(prompts)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        del self.model\n        cleanup()\n\n\n@pytest.fixture(scope=\"session\")\ndef hf_runner():\n    return HfRunner\n\n\nclass VllmRunner:\n\n    def __init__(\n        self,\n        model_name: str,\n        tokenizer_name: Optional[str] = None,\n        # Use smaller max model length, otherwise bigger model cannot run due\n        # to kv cache size limit.\n        max_model_len: int = 1024,\n        dtype: str = \"half\",\n        disable_log_stats: bool = True,\n        tensor_parallel_size: int = 1,\n        block_size: int = 16,\n        enable_chunked_prefill: bool = False,\n        swap_space: int = 4,\n        enforce_eager: bool = False,\n        **kwargs,\n    ) -> None:\n        self.model = LLM(\n            model=model_name,\n            tokenizer=tokenizer_name,\n            trust_remote_code=True,\n            dtype=dtype,\n            swap_space=swap_space,\n            enforce_eager=enforce_eager,\n            disable_log_stats=disable_log_stats,\n            tensor_parallel_size=tensor_parallel_size,\n            max_model_len=max_model_len,\n            block_size=block_size,\n            enable_chunked_prefill=enable_chunked_prefill,\n            **kwargs,\n        )\n\n    def generate(\n        self,\n        prompts: List[str],\n        sampling_params: SamplingParams,\n        images: Optional[List[Image.Image]] = None,\n    ) -> List[Tuple[List[List[int]], List[str]]]:\n        if images is not None:\n            assert len(prompts) == len(images)\n\n        inputs = [TextPrompt(prompt=prompt) for prompt in prompts]\n        if images is not None:\n            for i, image in enumerate(images):\n                inputs[i][\"multi_modal_data\"] = {\"image\": image}\n\n        req_outputs = self.model.generate(inputs,\n                                          sampling_params=sampling_params)\n\n        outputs: List[Tuple[List[List[int]], List[str]]] = []\n        for req_output in req_outputs:\n            prompt_str = req_output.prompt\n            prompt_ids = req_output.prompt_token_ids\n            req_sample_output_ids: List[List[int]] = []\n            req_sample_output_strs: List[str] = []\n            for sample in req_output.outputs:\n                output_str = sample.text\n                output_ids = list(sample.token_ids)\n                req_sample_output_ids.append(prompt_ids + output_ids)\n                req_sample_output_strs.append(prompt_str + output_str)\n            outputs.append((req_sample_output_ids, req_sample_output_strs))\n        return outputs\n\n    def generate_w_logprobs(\n        self,\n        prompts: List[str],\n        sampling_params: SamplingParams,\n        images: Optional[List[Image.Image]] = None,\n    ) -> List[Tuple[List[int], str, Optional[SampleLogprobs]]]:\n        assert sampling_params.logprobs is not None\n\n        if images is not None:\n            assert len(prompts) == len(images)\n\n        inputs = [TextPrompt(prompt=prompt) for prompt in prompts]\n        if images is not None:\n            for i, image in enumerate(images):\n                inputs[i][\"multi_modal_data\"] = {\"image\": image}\n\n        req_outputs = self.model.generate(inputs,\n                                          sampling_params=sampling_params)\n        outputs: List[Tuple[List[int], str, Optional[SampleLogprobs]]] = []\n        for req_output in req_outputs:\n            for sample in req_output.outputs:\n                output_str = sample.text\n                output_ids = sample.token_ids\n                output_logprobs = sample.logprobs\n            outputs.append((output_ids, output_str, output_logprobs))\n        return outputs\n\n    def generate_greedy(\n        self,\n        prompts: List[str],\n        max_tokens: int,\n        images: Optional[List[Image.Image]] = None,\n    ) -> List[Tuple[List[int], str]]:\n        greedy_params = SamplingParams(temperature=0.0, max_tokens=max_tokens)\n        outputs = self.generate(prompts, greedy_params, images=images)\n        return [(output_ids[0], output_str[0])\n                for output_ids, output_str in outputs]\n\n    def generate_greedy_logprobs(\n        self,\n        prompts: List[str],\n        max_tokens: int,\n        num_logprobs: int,\n        images: Optional[List[Image.Image]] = None,\n    ) -> List[Tuple[List[int], str, Optional[SampleLogprobs]]]:\n        greedy_logprobs_params = SamplingParams(temperature=0.0,\n                                                max_tokens=max_tokens,\n                                                logprobs=num_logprobs)\n        outputs = self.generate_w_logprobs(prompts,\n                                           greedy_logprobs_params,\n                                           images=images)\n\n        return [(output_ids, output_str, output_logprobs)\n                for output_ids, output_str, output_logprobs in outputs]\n\n    def generate_beam_search(\n        self,\n        prompts: List[str],\n        beam_width: int,\n        max_tokens: int,\n    ) -> List[Tuple[List[List[int]], List[str]]]:\n        beam_search_params = SamplingParams(n=beam_width,\n                                            use_beam_search=True,\n                                            temperature=0.0,\n                                            max_tokens=max_tokens)\n        outputs = self.generate(prompts, beam_search_params)\n        return outputs\n\n    def encode(self, prompts: List[str]) -> List[List[float]]:\n        req_outputs = self.model.encode(prompts)\n        outputs = []\n        for req_output in req_outputs:\n            embedding = req_output.outputs.embedding\n            outputs.append(embedding)\n        return outputs\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        del self.model\n        cleanup()\n\n\n@pytest.fixture(scope=\"session\")\ndef vllm_runner():\n    return VllmRunner\n\n\ndef get_tokenizer_pool_config(tokenizer_group_type):\n    if tokenizer_group_type is None:\n        return None\n    if tokenizer_group_type == \"ray\":\n        return TokenizerPoolConfig(pool_size=1,\n                                   pool_type=\"ray\",\n                                   extra_config={})\n    if isinstance(tokenizer_group_type, type):\n        return TokenizerPoolConfig(pool_size=1,\n                                   pool_type=tokenizer_group_type,\n                                   extra_config={})\n    raise ValueError(f\"Unknown tokenizer_group_type: {tokenizer_group_type}\")\n\n\n@pytest.fixture()\ndef temporary_enable_log_propagate():\n    import logging\n    logger = logging.getLogger(\"vllm\")\n    logger.propagate = True\n    yield\n    logger.propagate = False\n\n\n@pytest.fixture()\ndef caplog_vllm(temporary_enable_log_propagate, caplog):\n    # To capture vllm log, we should enable propagate=True temporarily\n    # because caplog depends on logs propagated to the root logger.\n    yield caplog\n\n\n@pytest.fixture(scope=\"session\")\ndef num_gpus_available():\n    \"\"\"Get number of GPUs without initializing the CUDA context\n    in current process.\"\"\"\n\n    return cuda_device_count_stateless()\n",
      "diff": "diff --git a/tests/conftest.py b/tests/conftest.py\nindex 71c4a539c..652d62737 100644\n--- a/tests/conftest.py\n+++ b/tests/conftest.py\n@@ -21,7 +21,8 @@ from vllm.distributed import (destroy_distributed_environment,\n from vllm.inputs import TextPrompt\n from vllm.logger import init_logger\n from vllm.sequence import SampleLogprobs\n-from vllm.utils import cuda_device_count_stateless, is_cpu\n+from vllm.utils import (STR_DTYPE_TO_TORCH_DTYPE, cuda_device_count_stateless,\n+                        is_cpu)\n \n logger = init_logger(__name__)\n \n@@ -124,12 +125,6 @@ def image_assets() -> _ImageAssets:\n     return IMAGE_ASSETS\n \n \n-_STR_DTYPE_TO_TORCH_DTYPE = {\n-    \"half\": torch.half,\n-    \"bfloat16\": torch.bfloat16,\n-    \"float\": torch.float,\n-}\n-\n _T = TypeVar(\"_T\", nn.Module, torch.Tensor, BatchEncoding)\n \n \n@@ -151,8 +146,7 @@ class HfRunner:\n         is_vision_model: bool = False,\n         is_sparseml_model: bool = False,\n     ) -> None:\n-        assert dtype in _STR_DTYPE_TO_TORCH_DTYPE\n-        torch_dtype = _STR_DTYPE_TO_TORCH_DTYPE[dtype]\n+        torch_dtype = STR_DTYPE_TO_TORCH_DTYPE[dtype]\n \n         self.model_name = model_name",
      "change_type": "modified",
      "lines_added": 4,
      "lines_removed": 10
    },
    {
      "file_path": "vllm/attention/backends/flash_attn.py",
      "old_content": "\"\"\"Attention layer with FlashAttention.\"\"\"\nfrom dataclasses import dataclass\nfrom typing import TYPE_CHECKING, Any, Dict, List, Optional, Tuple, Type\n\nimport torch\nfrom vllm_flash_attn import flash_attn_varlen_func, flash_attn_with_kvcache\n\nfrom vllm import _custom_ops as ops\nfrom vllm.attention.backends.abstract import (AttentionBackend, AttentionImpl,\n                                              AttentionMetadata,\n                                              AttentionMetadataBuilder,\n                                              AttentionType)\nfrom vllm.attention.backends.utils import (PAD_SLOT_ID, compute_slot_mapping,\n                                           compute_slot_mapping_start_idx,\n                                           is_block_tables_empty)\nfrom vllm.sequence import SequenceGroupMetadata\nfrom vllm.utils import make_tensor_with_pad\n\nif TYPE_CHECKING:\n    from vllm.worker.model_runner import (GPUModelRunnerBase,\n                                          ModelInputForGPUBuilder)\n\n\nclass FlashAttentionBackend(AttentionBackend):\n\n    @staticmethod\n    def get_supported_head_sizes() -> List[int]:\n        return [32, 64, 96, 128, 160, 192, 224, 256]\n\n    @staticmethod\n    def get_name() -> str:\n        return \"flash-attn\"\n\n    @staticmethod\n    def get_impl_cls() -> Type[\"FlashAttentionImpl\"]:\n        return FlashAttentionImpl\n\n    @staticmethod\n    def get_metadata_cls() -> Type[\"AttentionMetadata\"]:\n        return FlashAttentionMetadata\n\n    @staticmethod\n    def get_builder_cls() -> Type[\"FlashAttentionMetadataBuilder\"]:\n        return FlashAttentionMetadataBuilder\n\n    @staticmethod\n    def get_kv_cache_shape(\n        num_blocks: int,\n        block_size: int,\n        num_kv_heads: int,\n        head_size: int,\n    ) -> Tuple[int, ...]:\n        if block_size % 16 != 0:\n            raise ValueError(\"Block size must be a multiple of 16.\")\n        return (2, num_blocks, block_size, num_kv_heads, head_size)\n\n    @staticmethod\n    def swap_blocks(\n        src_kv_cache: torch.Tensor,\n        dst_kv_cache: torch.Tensor,\n        src_to_dst: torch.Tensor,\n    ) -> None:\n        src_key_cache = src_kv_cache[0]\n        dst_key_cache = dst_kv_cache[0]\n        ops.swap_blocks(src_key_cache, dst_key_cache, src_to_dst)\n\n        src_value_cache = src_kv_cache[1]\n        dst_value_cache = dst_kv_cache[1]\n        ops.swap_blocks(src_value_cache, dst_value_cache, src_to_dst)\n\n    @staticmethod\n    def copy_blocks(\n        kv_caches: List[torch.Tensor],\n        src_to_dists: torch.Tensor,\n    ) -> None:\n        key_caches = [kv_cache[0] for kv_cache in kv_caches]\n        value_caches = [kv_cache[1] for kv_cache in kv_caches]\n        ops.copy_blocks(key_caches, value_caches, src_to_dists)\n\n\n@dataclass\nclass FlashAttentionMetadata(AttentionMetadata):\n    \"\"\"Metadata for FlashAttentionBackend.\n\n    NOTE: Any python object stored here is not updated when it is\n    cuda-graph replayed. If you have values that need to be changed\n    dynamically, it should be stored in tensor. The tensor has to be\n    updated from `CUDAGraphRunner.forward` API.\n    \"\"\"\n    # (batch_size,). The sequence length per sequence. Sequence length means\n    # the computed tokens + new tokens None if it is a decoding.\n    seq_lens: Optional[List[int]]\n    # seq_lens stored as a tensor.\n    seq_lens_tensor: Optional[torch.Tensor]\n\n    # NOTE(sang): Definition of context_len, query_len, and seq_len.\n    # |---------- N-1 iteration --------|\n    # |---------------- N iteration ---------------------|\n    # |- tokenA -|......................|-- newTokens ---|\n    # |---------- context_len ----------|\n    # |-------------------- seq_len ---------------------|\n    #                                   |-- query_len ---|\n\n    # Maximum query length in the batch. None for decoding.\n    max_query_len: Optional[int]\n    # Maximum sequence length among prefill batch. 0 if there are decoding\n    # requests only.\n    max_prefill_seq_len: int\n    # Maximum sequence length among decode batch. 0 if there are prefill\n    # requests only.\n    max_decode_seq_len: int\n    # (batch_size + 1,). The cumulative subquery lengths of the sequences in\n    # the batch, used to index into subquery. E.g., if the subquery length\n    # is [4, 6], it is [0, 4, 10].\n    query_start_loc: Optional[torch.Tensor]\n    # (batch_size + 1,). The cumulative sequence lengths of the sequences in\n    # the batch, used to index into sequence. E.g., if the sequence length is\n    # [4, 6], it is [0, 4, 10].\n    seq_start_loc: Optional[torch.Tensor]\n    # (batch_size,) A tensor of context lengths (tokens that are computed\n    # so far).\n    context_lens_tensor: Optional[torch.Tensor]\n\n    # (batch_size, max_blocks_per_seq).\n    # Block addresses per sequence. (Seq id -> list of physical block)\n    # E.g., [0, 1, 2] means tokens are stored in 0th, 1st, and 2nd blocks\n    # in the kv cache. Each block can contain up to block_size tokens.\n    # 2nd dimensions are padded up to max_blocks_per_seq if it is cuda-graph\n    # captured.\n    block_tables: Optional[torch.Tensor]\n\n    # Whether or not if cuda graph is enabled.\n    # Cuda-graph is currently enabled for decoding only.\n    # TODO(woosuk): Move `use_cuda_graph` out since it's unrelated to attention.\n    use_cuda_graph: bool\n\n    _cached_prefill_metadata: Optional[\"FlashAttentionMetadata\"] = None\n    _cached_decode_metadata: Optional[\"FlashAttentionMetadata\"] = None\n\n    @property\n    def prefill_metadata(self) -> Optional[\"FlashAttentionMetadata\"]:\n        if self.num_prefills == 0:\n            return None\n\n        if self._cached_prefill_metadata is not None:\n            return self._cached_prefill_metadata\n\n        assert self.seq_lens is not None\n        assert self.seq_lens_tensor is not None\n        assert self.query_start_loc is not None\n        assert self.context_lens_tensor is not None\n        assert self.block_tables is not None\n        assert self.seq_start_loc is not None\n\n        self._cached_prefill_metadata = FlashAttentionMetadata(\n            num_prefills=self.num_prefills,\n            num_prefill_tokens=self.num_prefill_tokens,\n            num_decode_tokens=0,\n            slot_mapping=self.slot_mapping[:self.num_prefill_tokens],\n            seq_lens=self.seq_lens[:self.num_prefills],\n            seq_lens_tensor=self.seq_lens_tensor[:self.num_prefills],\n            max_query_len=self.max_query_len,\n            max_prefill_seq_len=self.max_prefill_seq_len,\n            max_decode_seq_len=0,\n            query_start_loc=self.query_start_loc[:self.num_prefills + 1],\n            seq_start_loc=self.seq_start_loc[:self.num_prefills + 1],\n            context_lens_tensor=self.context_lens_tensor[:self.num_prefills],\n            block_tables=self.block_tables[:self.num_prefills],\n            use_cuda_graph=False,\n        )\n        return self._cached_prefill_metadata\n\n    @property\n    def decode_metadata(self) -> Optional[\"FlashAttentionMetadata\"]:\n        if self.num_decode_tokens == 0:\n            return None\n\n        if self._cached_decode_metadata is not None:\n            return self._cached_decode_metadata\n        assert self.block_tables is not None\n        assert self.seq_lens_tensor is not None\n\n        self._cached_decode_metadata = FlashAttentionMetadata(\n            num_prefills=0,\n            num_prefill_tokens=0,\n            num_decode_tokens=self.num_decode_tokens,\n            slot_mapping=self.slot_mapping[self.num_prefill_tokens:],\n            seq_lens=None,\n            seq_lens_tensor=self.seq_lens_tensor[self.num_prefills:],\n            max_query_len=None,\n            max_prefill_seq_len=0,\n            max_decode_seq_len=self.max_decode_seq_len,\n            query_start_loc=None,\n            seq_start_loc=None,\n            context_lens_tensor=None,\n            block_tables=self.block_tables[self.num_prefills:],\n            use_cuda_graph=self.use_cuda_graph,\n        )\n        return self._cached_decode_metadata\n\n\nclass FlashAttentionMetadataBuilder(\n        AttentionMetadataBuilder[FlashAttentionMetadata]):\n\n    def __init__(self, input_builder: \"ModelInputForGPUBuilder\"):\n        self.slot_mapping: List[int] = []\n        self.prefill_seq_lens: List[int] = []\n        self.context_lens: List[int] = []\n        self.block_tables: List[List[int]] = []\n        self.curr_seq_lens: List[int] = []\n        self.num_prefills = 0\n        self.num_prefill_tokens = 0\n        self.num_decode_tokens = 0\n\n        self.sliding_window = input_builder.sliding_window\n        self.block_size = input_builder.block_size\n        self.use_v2_block_manager = (\n            input_builder.scheduler_config.use_v2_block_manager)\n\n    def add_seq_group(self, seq_group_metadata: SequenceGroupMetadata,\n                      token_lens: List[int], seq_lens: List[int],\n                      curr_seq_lens: List[int], query_lens: List[int],\n                      context_lens: List[int],\n                      curr_sliding_window_blocks: List[int],\n                      prefix_cache_hit: bool, chunked_prefill_enabled: bool):\n        \"\"\"Add a sequence group to the metadata. Specifically update/append\n        1. context length.\n        2. block table.\n        3. slot mapping.\n        \"\"\"\n        is_prompt = seq_group_metadata.is_prompt\n        block_tables = seq_group_metadata.block_tables\n\n        for (seq_id, token_len, seq_len, curr_seq_len, query_len, context_len,\n             curr_sliding_window_block) in zip(\n                 seq_group_metadata.seq_data.keys(), token_lens, seq_lens,\n                 curr_seq_lens, query_lens, context_lens,\n                 curr_sliding_window_blocks):\n            self.context_lens.append(context_len)\n\n            if is_prompt:\n                self.num_prefills += 1\n                self.num_prefill_tokens += token_len\n                self.prefill_seq_lens.append(seq_len)\n            else:\n                assert query_len == 1, (\n                    \"seq_len: {}, context_len: {}, query_len: {}\".format(\n                        seq_len, context_len, query_len))\n                self.num_decode_tokens += query_len\n                self.curr_seq_lens.append(curr_seq_len)\n\n            # Compute block table.\n            # TODO(sang): Combine chunked prefill and prefix caching by\n            # only allowing multiple of block_size chunk size.\n            # NOTE: This only works for oooooooxxx style attention.\n            block_table = []\n            if prefix_cache_hit:\n                # NOTE(woosuk): For flash-attn, the block table should\n                # include the entries for the incoming prefill tokens.\n                block_table = block_tables[seq_id]\n            elif ((chunked_prefill_enabled or not is_prompt)\n                  and block_tables is not None):\n                block_table = block_tables[seq_id][-curr_sliding_window_block:]\n            self.block_tables.append(block_table)\n\n            # Compute slot mapping.\n            is_profile_run = is_block_tables_empty(block_tables)\n            start_idx = compute_slot_mapping_start_idx(\n                is_prompt, query_len, context_len, self.sliding_window,\n                self.use_v2_block_manager)\n            compute_slot_mapping(is_profile_run, self.slot_mapping, seq_id,\n                                 seq_len, context_len, start_idx,\n                                 self.block_size,\n                                 seq_group_metadata.block_tables)\n\n    def build(self, runner: \"GPUModelRunnerBase\", seq_lens, query_lens,\n              cuda_graph_pad_size: int, batch_size: int):\n        \"\"\"Build attention metadata with on-device tensors.\"\"\"\n        device = runner.device\n        use_captured_graph = cuda_graph_pad_size != -1\n\n        logits_soft_cap = getattr(runner.model_config.hf_config,\n                                  \"attn_logit_softcapping\", None)\n        if logits_soft_cap is not None:\n            raise ValueError(\n                \"Please use Flashinfer backend for models with logits_soft_cap\"\n                \" (i.e., Gemma-2). Otherwise, the output might be wrong.\"\n                \" Set Flashinfer backend by \"\n                \"export VLLM_ATTENTION_BACKEND=FLASHINFER.\")\n\n        max_query_len = max(query_lens)\n        max_prefill_seq_len = max(self.prefill_seq_lens, default=0)\n        max_decode_seq_len = max(self.curr_seq_lens, default=0)\n        num_decode_tokens = self.num_decode_tokens\n\n        if use_captured_graph:\n            self.slot_mapping.extend([PAD_SLOT_ID] * cuda_graph_pad_size)\n            self.block_tables.extend([] * cuda_graph_pad_size)\n            num_decode_tokens = batch_size + cuda_graph_pad_size\n\n            # The shape of graph_block_tables is\n            # [max batch size, max context len // block size].\n            input_block_tables = runner.graph_block_tables[:batch_size]\n            for i, block_table in enumerate(self.block_tables):\n                if block_table:\n                    input_block_tables[i, :len(block_table)] = block_table\n            block_tables = torch.tensor(input_block_tables, device=device)\n        else:\n            max_block_table_len = max(\n                len(block_table) for block_table in self.block_tables)\n            block_tables = make_tensor_with_pad(\n                self.block_tables,\n                max_len=max_block_table_len,\n                pad=0,\n                dtype=torch.int,\n                device=device,\n            )\n        assert max_query_len > 0, (\"query_lens: {}\".format(query_lens))\n\n        context_lens_tensor = torch.tensor(self.context_lens,\n                                           dtype=torch.int,\n                                           device=device)\n        seq_lens_tensor = torch.tensor(seq_lens,\n                                       dtype=torch.int,\n                                       device=device)\n        query_lens_tensor = torch.tensor(query_lens,\n                                         dtype=torch.long,\n                                         device=device)\n        query_start_loc = torch.zeros(query_lens_tensor.shape[0] + 1,\n                                      dtype=torch.int32,\n                                      device=device)\n        seq_start_loc = torch.zeros(seq_lens_tensor.shape[0] + 1,\n                                    dtype=torch.int32,\n                                    device=device)\n        torch.cumsum(seq_lens_tensor,\n                     dim=0,\n                     dtype=seq_start_loc.dtype,\n                     out=seq_start_loc[1:])\n        torch.cumsum(query_lens_tensor,\n                     dim=0,\n                     dtype=query_start_loc.dtype,\n                     out=query_start_loc[1:])\n\n        slot_mapping_tensor = torch.tensor(self.slot_mapping,\n                                           dtype=torch.long,\n                                           device=device)\n\n        return FlashAttentionMetadata(\n            num_prefills=self.num_prefills,\n            slot_mapping=slot_mapping_tensor,\n            num_prefill_tokens=self.num_prefill_tokens,\n            num_decode_tokens=num_decode_tokens,\n            seq_lens=seq_lens,\n            seq_lens_tensor=seq_lens_tensor,\n            max_query_len=max_query_len,\n            max_prefill_seq_len=max_prefill_seq_len,\n            max_decode_seq_len=max_decode_seq_len,\n            query_start_loc=query_start_loc,\n            seq_start_loc=seq_start_loc,\n            context_lens_tensor=context_lens_tensor,\n            block_tables=block_tables,\n            use_cuda_graph=use_captured_graph,\n        )\n\n\nclass FlashAttentionImpl(AttentionImpl):\n    \"\"\"\n    If the input tensors contain prompt tokens, the layout is as follows:\n    |<--------------- num_prefill_tokens ----------------->|\t\n    |<--prefill_0-->|<--prefill_1-->|...|<--prefill_N-1--->|\n\n    Otherwise, the layout is as follows:\t\n    |<----------------- num_decode_tokens ------------------>|\t\n    |<--decode_0-->|..........|<--decode_M-1-->|<--padding-->|\n\n    Generation tokens can contain padding when cuda-graph is used.\n    Currently, prompt tokens don't contain any padding.\n\n    The prompts might have different lengths, while the generation tokens\n    always have length 1.\n\n    If chunked prefill is enabled, prefill tokens and decode tokens can be\n    batched together in a flattened 1D query.\n\n    |<----- num_prefill_tokens ---->|<------- num_decode_tokens --------->|\n    |<-prefill_0->|...|<-prefill_N-1->|<--decode_0-->|...|<--decode_M-1-->|\n\n    Currently, cuda graph is disabled for chunked prefill, meaning there's no\n    padding between prefill and decode tokens.\n    \"\"\"\n\n    def __init__(\n        self,\n        num_heads: int,\n        head_size: int,\n        scale: float,\n        num_kv_heads: int,\n        alibi_slopes: Optional[List[float]],\n        sliding_window: Optional[int],\n        kv_cache_dtype: str,\n        blocksparse_params: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        assert blocksparse_params is None, ValueError(\n            \"FlashAttention does not support block-sparse attention.\")\n        self.num_heads = num_heads\n        self.head_size = head_size\n        self.scale = float(scale)\n        self.num_kv_heads = num_kv_heads\n        if alibi_slopes is not None:\n            alibi_slopes = torch.tensor(alibi_slopes, dtype=torch.float32)\n        self.alibi_slopes = alibi_slopes\n        self.sliding_window = ((sliding_window, sliding_window)\n                               if sliding_window is not None else (-1, -1))\n        self.kv_cache_dtype = kv_cache_dtype\n\n        assert self.num_heads % self.num_kv_heads == 0\n        self.num_queries_per_kv = self.num_heads // self.num_kv_heads\n\n        if sliding_window is not None:\n            # NOTE(woosuk): flash-attn's sliding window does not work with\n            # paged KV cache.\n            raise ValueError(\n                \"Sliding window is not supported in FlashAttention.\")\n\n        support_head_sizes = FlashAttentionBackend.get_supported_head_sizes()\n        if head_size not in support_head_sizes:\n            raise ValueError(\n                f\"Head size {head_size} is not supported by FlashAttention. \"\n                f\"Supported head sizes are: {support_head_sizes}.\")\n\n    def forward(\n        self,\n        query: torch.Tensor,\n        key: torch.Tensor,\n        value: torch.Tensor,\n        kv_cache: torch.Tensor,\n        attn_metadata: FlashAttentionMetadata,\n        k_scale: float = 1.0,\n        v_scale: float = 1.0,\n        attn_type: AttentionType = AttentionType.DECODER,\n    ) -> torch.Tensor:\n        \"\"\"Forward pass with FlashAttention.\n\n        Args:\n            query: shape = [num_tokens, num_heads * head_size]\n            key: shape = [num_tokens, num_kv_heads * head_size]\n            value: shape = [num_tokens, num_kv_heads * head_size]\n            kv_cache = [2, num_blocks, block_size, num_kv_heads, head_size]\n            attn_metadata: Metadata for attention.\n        Returns:\n            shape = [num_tokens, num_heads * head_size]\n        \"\"\"\n        if attn_type != AttentionType.DECODER:\n            raise NotImplementedError(\"Encoder self-attention and \"\n                                      \"encoder/decoder cross-attention \"\n                                      \"are not implemented for \"\n                                      \"FlashAttentionImpl\")\n\n        # NOTE(woosuk): FlashAttention does not support FP8 KV cache.\n        assert k_scale == 1.0 and v_scale == 1.0, (\n            \"key/v_scale is not supported in FlashAttention.\")\n\n        num_tokens, hidden_size = query.shape\n        # Reshape the query, key, and value tensors.\n        query = query.view(-1, self.num_heads, self.head_size)\n        key = key.view(-1, self.num_kv_heads, self.head_size)\n        value = value.view(-1, self.num_kv_heads, self.head_size)\n\n        if kv_cache is not None:\n            key_cache = kv_cache[0]\n            value_cache = kv_cache[1]\n\n            # Reshape the input keys and values and store them in the cache.\n            # If kv_cache is not provided, the new key and value tensors are\n            # not cached. This happens during the initial memory profiling run.\n            ops.reshape_and_cache_flash(\n                key,\n                value,\n                key_cache,\n                value_cache,\n                attn_metadata.slot_mapping.flatten(),\n                self.kv_cache_dtype,\n            )\n\n        num_prefill_tokens = attn_metadata.num_prefill_tokens\n        num_decode_tokens = attn_metadata.num_decode_tokens\n        assert key.shape[0] == num_prefill_tokens + num_decode_tokens\n        assert value.shape[0] == num_prefill_tokens + num_decode_tokens\n\n        output = torch.empty_like(query)\n        # Query for decode. KV is not needed because it is already cached.\n        decode_query = query[num_prefill_tokens:]\n        # QKV for prefill.\n        query = query[:num_prefill_tokens]\n        key = key[:num_prefill_tokens]\n        value = value[:num_prefill_tokens]\n\n        assert query.shape[0] == num_prefill_tokens\n        assert decode_query.shape[0] == num_decode_tokens\n\n        if prefill_meta := attn_metadata.prefill_metadata:\n            # Prompt run.\n            if (kv_cache is None or prefill_meta.block_tables is None\n                    or prefill_meta.block_tables.numel() == 0):\n                # normal attention\n                # When block_tables are not filled, it means q and k are the\n                # prompt, and they have the same length.\n                out = flash_attn_varlen_func(\n                    q=query,\n                    k=key,\n                    v=value,\n                    cu_seqlens_q=prefill_meta.seq_start_loc,\n                    cu_seqlens_k=prefill_meta.seq_start_loc,\n                    max_seqlen_q=prefill_meta.max_prefill_seq_len,\n                    max_seqlen_k=prefill_meta.max_prefill_seq_len,\n                    softmax_scale=self.scale,\n                    causal=True,\n                    window_size=self.sliding_window,\n                    alibi_slopes=self.alibi_slopes,\n                )\n                assert output[:num_prefill_tokens].shape == out.shape\n                output[:num_prefill_tokens] = out\n            else:\n                # prefix-enabled attention\n                assert prefill_meta.seq_lens is not None\n                max_seq_len = max(prefill_meta.seq_lens)\n                output[:num_prefill_tokens] = flash_attn_varlen_func(\n                    q=query,\n                    k=key_cache,\n                    v=value_cache,\n                    cu_seqlens_q=prefill_meta.query_start_loc,\n                    max_seqlen_q=prefill_meta.max_query_len,\n                    cu_seqlens_k=prefill_meta.seq_start_loc,\n                    max_seqlen_k=max_seq_len,\n                    softmax_scale=self.scale,\n                    causal=True,\n                    alibi_slopes=self.alibi_slopes,\n                    block_table=prefill_meta.block_tables,\n                )\n\n        if decode_meta := attn_metadata.decode_metadata:\n            # Decoding run.\n            output[num_prefill_tokens:] = flash_attn_with_kvcache(\n                decode_query.unsqueeze(1),\n                key_cache,\n                value_cache,\n                block_table=decode_meta.block_tables,\n                cache_seqlens=decode_meta.seq_lens_tensor,\n                softmax_scale=self.scale,\n                causal=True,\n                alibi_slopes=self.alibi_slopes,\n            ).squeeze(1)\n\n        # Reshape the output tensor.\n        return output.view(num_tokens, hidden_size)\n",
      "diff": "diff --git a/vllm/attention/backends/flash_attn.py b/vllm/attention/backends/flash_attn.py\nindex b8a64205b..cad3181d3 100644\n--- a/vllm/attention/backends/flash_attn.py\n+++ b/vllm/attention/backends/flash_attn.py\n@@ -306,11 +306,8 @@ class FlashAttentionMetadataBuilder(\n                     input_block_tables[i, :len(block_table)] = block_table\n             block_tables = torch.tensor(input_block_tables, device=device)\n         else:\n-            max_block_table_len = max(\n-                len(block_table) for block_table in self.block_tables)\n             block_tables = make_tensor_with_pad(\n                 self.block_tables,\n-                max_len=max_block_table_len,\n                 pad=0,\n                 dtype=torch.int,\n                 device=device,",
      "change_type": "modified",
      "lines_added": 1,
      "lines_removed": 4
    },
    {
      "file_path": "vllm/attention/backends/flashinfer.py",
      "old_content": "from dataclasses import dataclass\nfrom typing import TYPE_CHECKING, Any, Dict, List, Optional, Set, Tuple, Type\n\ntry:\n    from flashinfer import BatchDecodeWithPagedKVCacheWrapper\n    from flashinfer.prefill import BatchPrefillWithPagedKVCacheWrapper\n    from vllm_flash_attn import flash_attn_varlen_func\nexcept ImportError:\n    flash_attn_varlen_func = None\n    BatchDecodeWithPagedKVCacheWrapper = None\n    BatchPrefillWithPagedKVCacheWrapper = None\n\nimport torch\n\nfrom vllm import _custom_ops as ops\nfrom vllm.attention.backends.abstract import (AttentionBackend, AttentionImpl,\n                                              AttentionMetadata,\n                                              AttentionMetadataBuilder,\n                                              AttentionType)\nfrom vllm.attention.backends.utils import (PAD_SLOT_ID, compute_slot_mapping,\n                                           compute_slot_mapping_start_idx,\n                                           is_block_tables_empty)\nfrom vllm.attention.ops.paged_attn import PagedAttention\nfrom vllm.sequence import SequenceGroupMetadata\nfrom vllm.utils import get_kv_cache_torch_dtype, make_tensor_with_pad\n\nif TYPE_CHECKING:\n    from vllm.worker.model_runner import (GPUModelRunnerBase,\n                                          ModelInputForGPUBuilder)\n\n\nclass FlashInferBackend(AttentionBackend):\n\n    @staticmethod\n    def get_name() -> str:\n        return \"flashinfer\"\n\n    @staticmethod\n    def get_impl_cls() -> Type[\"FlashInferImpl\"]:\n        return FlashInferImpl\n\n    @staticmethod\n    def get_metadata_cls() -> Type[\"AttentionMetadata\"]:\n        return FlashInferMetadata\n\n    @staticmethod\n    def get_builder_cls() -> Type[\"FlashInferMetadataBuilder\"]:\n        return FlashInferMetadataBuilder\n\n    @staticmethod\n    def get_kv_cache_shape(\n        num_blocks: int,\n        block_size: int,\n        num_kv_heads: int,\n        head_size: int,\n    ) -> Tuple[int, ...]:\n        return (num_blocks, 2, block_size, num_kv_heads, head_size)\n\n    @staticmethod\n    def swap_blocks(\n        src_kv_cache: torch.Tensor,\n        dst_kv_cache: torch.Tensor,\n        src_to_dst: torch.Tensor,\n    ) -> None:\n        PagedAttention.swap_blocks(src_kv_cache, dst_kv_cache, src_to_dst)\n\n    @staticmethod\n    def copy_blocks(\n        kv_caches: List[torch.Tensor],\n        src_to_dists: torch.Tensor,\n    ) -> None:\n        PagedAttention.copy_blocks(kv_caches, src_to_dists)\n\n    @staticmethod\n    def get_supported_head_sizes() -> List[int]:\n        return [64, 128, 256]\n\n\n@dataclass\nclass FlashInferMetadata(AttentionMetadata):\n    # Maximum sequence length among prefill batch. 0 if there are decoding\n    # requests only.\n    max_prefill_seq_len: int\n\n    use_cuda_graph: bool = True\n\n    prefill_wrapper: Optional[BatchPrefillWithPagedKVCacheWrapper] = None\n    decode_wrapper: Optional[BatchDecodeWithPagedKVCacheWrapper] = None\n\n    # Metadata for the prefill stage\n    seq_start_loc: Optional[torch.Tensor] = None\n    query_start_loc: Optional[torch.Tensor] = None\n    block_tables: Optional[torch.Tensor] = None\n\n    # An example for paged_kv_indices, paged_kv_indptr:\n    # request 1, page indices [0, 5, 8]\n    # request 2, page indices [1, 6, 7]\n    # request 3, page indices [3, 4]\n    # paged_kv_indices is a concatenation of page indices of all requests:\n    # [0, 5, 8, 1, 6, 7, 3, 4]\n    # paged_kv_indptr is used to index into paged_kv_indices:\n    # [0, 3, 6, 8]\n    # The indptr of the paged kv cache, shape: [batch_size + 1]\n    paged_kv_indptr: Optional[torch.Tensor] = None\n    # The page indices of the paged kv cache\n    paged_kv_indices: Optional[torch.Tensor] = None\n    # The number of entries in the last page of each request in\n    # the paged kv cache, shape: [batch_size]\n    paged_kv_last_page_len: Optional[torch.Tensor] = None\n    # The number of query/output heads\n    num_qo_heads: Optional[int] = None\n    # The number of key/value heads\n    num_kv_heads: Optional[int] = None\n    # The dimension of the attention heads\n    head_dim: Optional[int] = None\n    # Block size of vllm\n    page_size: Optional[int] = None\n    # The data type of the paged kv cache\n    data_type: torch.dtype = None\n    device: torch.device = torch.device(\"cuda\")\n    # Only used by gemma2 model\n    logits_soft_cap: Optional[float] = None\n\n    def __post_init__(self):\n        # Refer to\n        # https://github.com/flashinfer-ai/flashinfer/blob/3d55c71a62052c590c130897d3a3db49b14fcc34/include/flashinfer/utils.cuh#L157\n        supported_head_sizes = FlashInferBackend.get_supported_head_sizes()\n        if self.head_dim is not None and self.head_dim \\\n                not in supported_head_sizes:\n            raise ValueError(\n                f\"Only {supported_head_sizes} are supported for head_dim,\",\n                f\"received {self.head_dim}.\")\n\n    def begin_forward(self):\n        if self.num_prefill_tokens > 0:\n            if self.paged_kv_indices is None:\n                return\n\n            assert self.prefill_wrapper is not None\n            assert self.paged_kv_indices is not None\n            assert self.paged_kv_indptr is not None\n            assert self.paged_kv_last_page_len is not None\n            self.paged_kv_indices = self.paged_kv_indices.to(self.device)\n            self.paged_kv_indptr = self.paged_kv_indptr.to(self.device)\n            self.paged_kv_last_page_len = self.paged_kv_last_page_len.to(\n                self.device)\n            self.prefill_wrapper.end_forward()\n            self.prefill_wrapper.begin_forward(\n                self.query_start_loc, self.paged_kv_indptr,\n                self.paged_kv_indices, self.paged_kv_last_page_len,\n                self.num_qo_heads, self.num_kv_heads, self.head_dim,\n                self.page_size)\n        else:\n            if not self.use_cuda_graph:\n                assert self.paged_kv_indices is not None\n                assert self.paged_kv_indptr is not None\n                assert self.paged_kv_last_page_len is not None\n                self.paged_kv_indices = self.paged_kv_indices.to(self.device)\n                self.paged_kv_indptr = self.paged_kv_indptr.to(self.device)\n                self.paged_kv_last_page_len = self.paged_kv_last_page_len.to(\n                    self.device)\n\n            assert self.decode_wrapper is not None\n            self.decode_wrapper.end_forward()\n            self.decode_wrapper.begin_forward(\n                self.paged_kv_indptr,\n                self.paged_kv_indices,\n                self.paged_kv_last_page_len,\n                self.num_qo_heads,\n                self.num_kv_heads,\n                self.head_dim,\n                self.page_size,\n                # Disable flashinfer's pos encoding and use vllm's rope.\n                pos_encoding_mode=\"NONE\",\n                data_type=self.data_type)\n\n    def asdict_zerocopy(self,\n                        skip_fields: Optional[Set[str]] = None\n                        ) -> Dict[str, Any]:\n        if skip_fields is None:\n            skip_fields = set()\n        # We need to skip the prefill/decode_wrapper field since it cannot be\n        # broadcasted with nccl when TP is enabled.\n        skip_fields.add('prefill_wrapper')\n        skip_fields.add('decode_wrapper')\n        return super().asdict_zerocopy(skip_fields)\n\n    @property\n    def prefill_metadata(self) -> Optional[\"FlashInferMetadata\"]:\n        # Currently chunked prefill is not supported\n        if self.num_decode_tokens == 0:\n            assert self.num_prefills > 0\n            return self\n\n        return None\n\n    @property\n    def decode_metadata(self) -> Optional[\"FlashInferMetadata\"]:\n        # Currently chunked prefill is not supported\n        if self.num_prefills > 0:\n            assert self.num_decode_tokens == 0\n            return None\n\n        return self\n\n\nclass FlashInferMetadataBuilder(AttentionMetadataBuilder[FlashInferMetadata]):\n\n    def __init__(self, input_builder: \"ModelInputForGPUBuilder\"):\n        self.slot_mapping: List[int] = []\n        self.prefill_seq_lens: List[int] = []\n        self.context_lens: List[int] = []\n        self.block_tables: List[List[int]] = []\n        self.curr_seq_lens: List[int] = []\n        self.num_prefills = 0\n        self.num_prefill_tokens = 0\n        self.num_decode_tokens = 0\n\n        self.sliding_window = input_builder.sliding_window\n        self.block_size = input_builder.block_size\n        self.use_v2_block_manager = (\n            input_builder.scheduler_config.use_v2_block_manager)\n\n        # Please follow https://docs.flashinfer.ai/tutorials/kv_layout.html#page-layout\n        # for the precise definition of the following fields.\n        # An example:\n        # request 1, page indices [0, 5, 8]\n        # request 2, page indices [1, 6, 7]\n        # request 3, page indices [3, 4]\n        # paged_kv_indices is a concatenation of page indices of all requests:\n        # [0, 5, 8, 1, 6, 7, 3, 4]\n        # paged_kv_indptr is used to index into paged_kv_indices:\n        # [0, 3, 6, 8]\n        self.paged_kv_indices: List[int] = []\n        # 0 at the beginning of paged_kv_indptr indicates the start of the\n        # first requests page indices in the paged_kv_indices list.\n        self.paged_kv_indptr: List[int] = [0]\n        # paged_kv_last_page_len is the length of the last page of each request\n        self.paged_kv_last_page_len: List[int] = []\n\n    def add_seq_group(self, seq_group_metadata: SequenceGroupMetadata,\n                      token_lens: List[int], seq_lens: List[int],\n                      curr_seq_lens: List[int], query_lens: List[int],\n                      context_lens: List[int],\n                      curr_sliding_window_blocks: List[int],\n                      prefix_cache_hit: bool, chunked_prefill_enabled: bool):\n        \"\"\"Add a sequence group to the metadata. Specifically update/append\n        1. context length.\n        2. block table.\n        3. slot mapping.\n        \"\"\"\n        is_prompt = seq_group_metadata.is_prompt\n        block_tables = seq_group_metadata.block_tables\n        computed_block_nums = seq_group_metadata.computed_block_nums\n\n        for (seq_id, token_len, seq_len, curr_seq_len, query_len, context_len,\n             curr_sliding_window_block) in zip(\n                 seq_group_metadata.seq_data.keys(), token_lens, seq_lens,\n                 curr_seq_lens, query_lens, context_lens,\n                 curr_sliding_window_blocks):\n            self.context_lens.append(context_len)\n            if is_prompt:\n                self.num_prefills += 1\n                self.num_prefill_tokens += token_len\n                self.prefill_seq_lens.append(seq_len)\n            else:\n                assert query_len == 1, (\n                    \"seq_len: {}, context_len: {}, query_len: {}\".format(\n                        seq_len, context_len, query_len))\n                self.num_decode_tokens += query_len\n                self.curr_seq_lens.append(curr_seq_len)\n\n            # Compute block table.\n            # TODO(sang): Combine chunked prefill and prefix caching by\n            # only allowing multiple of block_size chunk size.\n            # NOTE: This only works for oooooooxxx style attention.\n            block_table = []\n            if prefix_cache_hit:\n                block_table = computed_block_nums\n            elif ((chunked_prefill_enabled or not is_prompt)\n                  and block_tables is not None):\n                block_table = block_tables[seq_id][-curr_sliding_window_block:]\n            self.block_tables.append(block_table)\n\n            is_profile_run = is_block_tables_empty(block_tables)\n\n            # Compute slot mapping.\n            start_idx = compute_slot_mapping_start_idx(\n                is_prompt, query_len, context_len, self.sliding_window,\n                self.use_v2_block_manager)\n            compute_slot_mapping(is_profile_run, self.slot_mapping, seq_id,\n                                 seq_len, context_len, start_idx,\n                                 self.block_size,\n                                 seq_group_metadata.block_tables)\n\n            # It is not necessary to add paged_kv_indices, paged_kv_indptr,\n            # and paged_kv_last_page_len for profile run because we will\n            # create dummy inputs.\n            if is_profile_run:\n                return\n\n            # Get the number of valid blocks based on sequence length.\n            # If seq_len = 16, block_size = 16,\n            # block_table_bound is 1 with 1 valid block.\n            # If seq_len = 15, block_size = 16,\n            # block_table_bound is 0 + 1 with 1 valid block.\n            block_table_bound = seq_len // self.block_size + 1 \\\n                                if seq_len % self.block_size != 0 \\\n                                else seq_len // self.block_size\n            block_table = block_tables[seq_id]\n            self.paged_kv_indices.extend(block_table[:block_table_bound])\n            self.paged_kv_indptr.append(self.paged_kv_indptr[-1] +\n                                        block_table_bound)\n\n            last_page_len = seq_len % self.block_size\n            if last_page_len == 0:\n                last_page_len = self.block_size\n            self.paged_kv_last_page_len.append(last_page_len)\n\n    def build(self, runner: \"GPUModelRunnerBase\", seq_lens, query_lens,\n              cuda_graph_pad_size: int, batch_size: int):\n        device = runner.device\n        use_captured_graph = cuda_graph_pad_size != -1\n\n        max_query_len = max(query_lens)\n        max_prefill_seq_len = max(self.prefill_seq_lens, default=0)\n        num_decode_tokens = self.num_decode_tokens\n\n        if use_captured_graph:\n            self.slot_mapping.extend([PAD_SLOT_ID] * cuda_graph_pad_size)\n            self.block_tables.extend([] * cuda_graph_pad_size)\n            num_decode_tokens = batch_size + cuda_graph_pad_size\n\n            # The shape of graph_block_tables is\n            # [max batch size, max context len // block size].\n            input_block_tables = runner.graph_block_tables[:batch_size]\n            for i, block_table in enumerate(self.block_tables):\n                if block_table:\n                    input_block_tables[i, :len(block_table)] = block_table\n            block_tables = torch.tensor(input_block_tables, device=device)\n\n            last_paged_kv_indptr = self.paged_kv_indptr[-1]\n            self.paged_kv_indptr.extend([last_paged_kv_indptr] *\n                                        cuda_graph_pad_size)\n            self.paged_kv_last_page_len.extend([0] * cuda_graph_pad_size)\n        else:\n            max_block_table_len = max(\n                len(block_table) for block_table in self.block_tables)\n            block_tables = make_tensor_with_pad(\n                self.block_tables,\n                max_len=max_block_table_len,\n                pad=0,\n                dtype=torch.int,\n                device=device,\n            )\n        assert max_query_len > 0, (\"query_lens: {}\".format(query_lens))\n\n        seq_lens_tensor = torch.tensor(seq_lens,\n                                       dtype=torch.int,\n                                       device=device)\n        query_lens_tensor = torch.tensor(query_lens,\n                                         dtype=torch.long,\n                                         device=device)\n        query_start_loc = torch.zeros(query_lens_tensor.shape[0] + 1,\n                                      dtype=torch.int32,\n                                      device=device)\n        seq_start_loc = torch.zeros(seq_lens_tensor.shape[0] + 1,\n                                    dtype=torch.int32,\n                                    device=device)\n        torch.cumsum(seq_lens_tensor,\n                     dim=0,\n                     dtype=seq_start_loc.dtype,\n                     out=seq_start_loc[1:])\n        torch.cumsum(query_lens_tensor,\n                     dim=0,\n                     dtype=query_start_loc.dtype,\n                     out=query_start_loc[1:])\n\n        slot_mapping_tensor = torch.tensor(self.slot_mapping,\n                                           dtype=torch.long,\n                                           device=device)\n\n        logits_soft_cap = getattr(runner.model_config.hf_config,\n                                  \"attn_logit_softcapping\", None)\n\n        if len(self.paged_kv_indptr) > 0:\n            paged_kv_indices_tensor = torch.tensor(self.paged_kv_indices,\n                                                   device=\"cpu\",\n                                                   dtype=torch.int)\n            paged_kv_indptr_tensor = torch.tensor(self.paged_kv_indptr,\n                                                  device=\"cpu\",\n                                                  dtype=torch.int)\n            paged_kv_last_page_len_tensor = torch.tensor(\n                self.paged_kv_last_page_len, device=\"cpu\", dtype=torch.int)\n        else:\n            paged_kv_indices_tensor = None\n            paged_kv_indptr_tensor = None\n            paged_kv_last_page_len_tensor = None\n\n        kv_cache_dtype = get_kv_cache_torch_dtype(runner.kv_cache_dtype,\n                                                  runner.model_config.dtype)\n        return FlashInferMetadata(\n            num_prefills=self.num_prefills,\n            slot_mapping=slot_mapping_tensor,\n            num_prefill_tokens=self.num_prefill_tokens,\n            num_decode_tokens=num_decode_tokens,\n            max_prefill_seq_len=max_prefill_seq_len,\n            block_tables=block_tables,\n            paged_kv_indptr=paged_kv_indptr_tensor,\n            paged_kv_indices=paged_kv_indices_tensor,\n            paged_kv_last_page_len=paged_kv_last_page_len_tensor,\n            num_qo_heads=runner.model_config.get_num_attention_heads(\n                runner.parallel_config),\n            num_kv_heads=runner.model_config.get_num_kv_heads(\n                runner.parallel_config),\n            head_dim=runner.model_config.get_head_size(),\n            page_size=self.block_size,\n            seq_start_loc=seq_start_loc,\n            query_start_loc=query_start_loc,\n            device=device,\n            data_type=kv_cache_dtype,\n            use_cuda_graph=use_captured_graph,\n            logits_soft_cap=logits_soft_cap)\n\n\nclass FlashInferImpl(AttentionImpl):\n\n    def __init__(\n        self,\n        num_heads: int,\n        head_size: int,\n        scale: float,\n        num_kv_heads: int,\n        alibi_slopes: Optional[List[float]],\n        sliding_window: Optional[int],\n        kv_cache_dtype: str,\n        blocksparse_params: Optional[Dict[str, Any]] = None,\n    ) -> None:\n        self.num_heads = num_heads\n        self.head_size = head_size\n        self.scale = float(scale)\n        self.num_kv_heads = num_kv_heads\n        if alibi_slopes is not None:\n            alibi_slopes = torch.tensor(alibi_slopes, dtype=torch.float32)\n        self.alibi_slopes = alibi_slopes\n        if sliding_window is not None:\n            raise ValueError(\"Sliding window is not supported in FlashInfer.\")\n        self.sliding_window = (-1, -1)\n        self.kv_cache_dtype = kv_cache_dtype\n\n        assert self.num_heads % self.num_kv_heads == 0\n        self.num_queries_per_kv = self.num_heads // self.num_kv_heads\n\n    def forward(\n        self,\n        query: torch.Tensor,\n        key: torch.Tensor,\n        value: torch.Tensor,\n        kv_cache: Optional[torch.Tensor],\n        attn_metadata: FlashInferMetadata,\n        k_scale: float = 1.0,\n        v_scale: float = 1.0,\n        attn_type: AttentionType = AttentionType.DECODER,\n    ) -> torch.Tensor:\n        assert k_scale == 1.0 and v_scale == 1.0, (\n            \"key/v_scale is not supported in FlashInfer.\")\n        if attn_type != AttentionType.DECODER:\n            raise NotImplementedError(\"Encoder self-attention and \"\n                                      \"encoder/decoder cross-attention \"\n                                      \"are not implemented for \"\n                                      \"FlashInferImpl\")\n        num_tokens, hidden_size = query.shape\n        query = query.view(-1, self.num_heads, self.head_size)\n        key = key.view(-1, self.num_kv_heads, self.head_size)\n        value = value.view(-1, self.num_kv_heads, self.head_size)\n\n        if attn_metadata.num_prefill_tokens > 0:\n            assert attn_metadata.num_decode_tokens == 0, (\n                \"Chunked prefill is not supported with flashinfer yet.\")\n        if attn_metadata.num_decode_tokens > 0:\n            assert attn_metadata.num_prefill_tokens == 0, (\n                \"Chunked prefill is not supported with flashinfer yet.\")\n\n        if kv_cache is not None:\n            # Use the same reshape and cache kernel as flash attention.\n            ops.reshape_and_cache_flash(\n                key,\n                value,\n                kv_cache[:, 0],\n                kv_cache[:, 1],\n                attn_metadata.slot_mapping.flatten(),\n                self.kv_cache_dtype,\n            )\n\n        query = query.contiguous(\n        )  # Flashinfer requires query to be contiguous\n        if prefill_meta := attn_metadata.prefill_metadata:\n            # We will use flash attention for prefill\n            # when kv_cache is not provided.\n            # This happens when vllm runs the profiling to\n            # determine the number of blocks.\n            if kv_cache is None:\n                output = flash_attn_varlen_func(\n                    q=query,\n                    k=key,\n                    v=value,\n                    cu_seqlens_q=prefill_meta.seq_start_loc,\n                    cu_seqlens_k=prefill_meta.seq_start_loc,\n                    max_seqlen_q=prefill_meta.max_prefill_seq_len,\n                    max_seqlen_k=prefill_meta.max_prefill_seq_len,\n                    softmax_scale=self.scale,\n                    causal=True,\n                    window_size=self.sliding_window,\n                    alibi_slopes=self.alibi_slopes,\n                )\n            else:\n                assert prefill_meta is not None\n                assert prefill_meta.prefill_wrapper is not None\n                output = prefill_meta.prefill_wrapper.forward(\n                    query,\n                    kv_cache,\n                    logits_soft_cap=attn_metadata.logits_soft_cap,\n                    causal=True)\n        else:\n            assert attn_metadata.decode_metadata is not None\n            assert attn_metadata.decode_metadata.decode_wrapper is not None\n            output = attn_metadata.decode_metadata.decode_wrapper.forward(\n                query,\n                kv_cache,\n                sm_scale=self.scale,\n                logits_soft_cap=attn_metadata.logits_soft_cap)\n        return output.view(num_tokens, hidden_size)\n",
      "diff": "diff --git a/vllm/attention/backends/flashinfer.py b/vllm/attention/backends/flashinfer.py\nindex 9c25b2cc2..eb8b1f0fc 100644\n--- a/vllm/attention/backends/flashinfer.py\n+++ b/vllm/attention/backends/flashinfer.py\n@@ -344,11 +344,8 @@ class FlashInferMetadataBuilder(AttentionMetadataBuilder[FlashInferMetadata]):\n                                         cuda_graph_pad_size)\n             self.paged_kv_last_page_len.extend([0] * cuda_graph_pad_size)\n         else:\n-            max_block_table_len = max(\n-                len(block_table) for block_table in self.block_tables)\n             block_tables = make_tensor_with_pad(\n                 self.block_tables,\n-                max_len=max_block_table_len,\n                 pad=0,\n                 dtype=torch.int,\n                 device=device,",
      "change_type": "modified",
      "lines_added": 1,
      "lines_removed": 4
    },
    {
      "file_path": "vllm/attention/backends/utils.py",
      "old_content": "\"\"\"Attention backend utils\"\"\"\nfrom typing import TYPE_CHECKING, Dict, List, Type, TypeVar, Union\n\nimport torch\n\nfrom vllm.attention import AttentionMetadata, AttentionMetadataBuilder\nfrom vllm.sequence import SequenceGroupMetadata\nfrom vllm.utils import make_tensor_with_pad\n\n# Error string(s) for encoder/decoder\n# unsupported attention scenarios\nSTR_NOT_IMPL_ENC_DEC_ROCM_HIP = (\"ROCm/HIP is not currently supported \"\n                                 \"with encoder/decoder models.\")\n\nPAD_SLOT_ID = -1\n\nif TYPE_CHECKING:\n    from vllm.worker.model_runner import (GPUModelRunnerBase,\n                                          ModelInputForGPUBuilder)\n\n\ndef is_block_tables_empty(block_tables: Union[None, Dict]):\n    \"\"\"\n    Check if block_tables is None or a dictionary with all None values.\n    \"\"\"\n    if block_tables is None:\n        return True\n    if isinstance(block_tables, dict) and all(\n            value is None for value in block_tables.values()):\n        return True\n    return False\n\n\ndef compute_slot_mapping_start_idx(is_prompt: bool, query_len: int,\n                                   context_len: int, sliding_window: int,\n                                   use_v2_block_manager: bool):\n    \"\"\"\n    Compute the start index of slot mapping.\n    \"\"\"\n    start_idx = 0\n    if is_prompt and sliding_window is not None:\n        assert use_v2_block_manager or context_len == 0, (\n            \"Prefix caching is currently not supported with \"\n            \"sliding window attention in V1 block manager\")\n        # When prefill, we use it to not write slots to kv cache\n        # to save memory.\n        start_idx = max(0, query_len - sliding_window)\n    return start_idx\n\n\ndef compute_slot_mapping(is_profile_run: bool, slot_mapping: List[int],\n                         seq_id: int, seq_len: int, context_len: int,\n                         start_idx: int, block_size: int,\n                         block_tables: Dict[int, List[int]]):\n    \"\"\"\n    Compute slot mapping.\n    \"\"\"\n    if is_profile_run:\n        # During memory profiling, the block tables are not\n        # initialized yet. In this case, we just use a dummy\n        # slot mapping.\n        # In embeddings, the block tables are {seq_id: None}.\n        slot_mapping.extend([PAD_SLOT_ID] * seq_len)\n        return\n\n    # Mask the [0, start_idx) tokens of the prompt with\n    # PAD_SLOT_ID, where start_idx is max(0, seq_len -\n    # sliding_window). For example, if the prompt len is 10,\n    # sliding window is 8, and block size is 4, the first two\n    # tokens are masked and the slot mapping will be\n    # [-1, -1, 2, 3, 4, 5, 6, 7, 0, 1].\n    block_table = block_tables[seq_id]\n    slot_mapping.extend([PAD_SLOT_ID] * max(0, start_idx - context_len))\n    for i in range(max(start_idx, context_len), seq_len):\n        block_number = block_table[i // block_size]\n        block_offset = i % block_size\n        slot = block_number * block_size + block_offset\n        slot_mapping.append(slot)\n\n\nTAttentionMetadata = TypeVar(\"TAttentionMetadata\", bound='AttentionMetadata')\n\n\nclass CommonMetadataBuilder(AttentionMetadataBuilder[TAttentionMetadata]):\n\n    _metadata_cls: Type[TAttentionMetadata]\n\n    def __init__(self, input_builder: \"ModelInputForGPUBuilder\"):\n        self.slot_mapping: List[int] = []\n        self.prefill_seq_lens: List[int] = []\n        self.context_lens: List[int] = []\n        self.block_tables: List[List[int]] = []\n        self.curr_seq_lens: List[int] = []\n        self.num_prefills = 0\n        self.num_prefill_tokens = 0\n        self.num_decode_tokens = 0\n\n        self.sliding_window = input_builder.sliding_window\n        self.block_size = input_builder.block_size\n        self.use_v2_block_manager = (\n            input_builder.scheduler_config.use_v2_block_manager)\n\n    def add_seq_group(self, seq_group_metadata: SequenceGroupMetadata,\n                      token_lens: List[int], seq_lens: List[int],\n                      curr_seq_lens: List[int], query_lens: List[int],\n                      context_lens: List[int],\n                      curr_sliding_window_blocks: List[int], prefix_cache_hit,\n                      chunked_prefill_enabled):\n        is_prompt = seq_group_metadata.is_prompt\n        block_tables = seq_group_metadata.block_tables\n        computed_block_nums = seq_group_metadata.computed_block_nums\n\n        for (seq_id, token_len, seq_len, curr_seq_len, query_len, context_len,\n             curr_sliding_window_block) in zip(\n                 seq_group_metadata.seq_data.keys(), token_lens, seq_lens,\n                 curr_seq_lens, query_lens, context_lens,\n                 curr_sliding_window_blocks):\n            self.context_lens.append(context_len)\n            if is_prompt:\n                self.num_prefills += 1\n                self.num_prefill_tokens += token_len\n                self.prefill_seq_lens.append(seq_len)\n            else:\n                assert query_len == 1, (\n                    \"seq_len: {}, context_len: {}, query_len: {}\".format(\n                        seq_len, context_len, query_len))\n                self.num_decode_tokens += query_len\n                self.curr_seq_lens.append(curr_seq_len)\n\n            # Compute block table.\n            # TODO(sang): Combine chunked prefill and prefix caching by\n            # only allowing multiple of block_size chunk size.\n            # NOTE: This only works for oooooooxxx style attention.\n            block_table = []\n            if prefix_cache_hit:\n                block_table = computed_block_nums\n            elif ((chunked_prefill_enabled or not is_prompt)\n                  and block_tables is not None):\n                block_table = block_tables[seq_id][-curr_sliding_window_block:]\n            self.block_tables.append(block_table)\n\n            # Compute slot mapping.\n            is_profile_run = is_block_tables_empty(block_tables)\n            start_idx = compute_slot_mapping_start_idx(\n                is_prompt, query_len, context_len, self.sliding_window,\n                self.use_v2_block_manager)\n            compute_slot_mapping(is_profile_run, self.slot_mapping, seq_id,\n                                 seq_len, context_len, start_idx,\n                                 self.block_size,\n                                 seq_group_metadata.block_tables)\n\n    def build(self, runner: \"GPUModelRunnerBase\", seq_lens: List[int],\n              query_lens: List[int], cuda_graph_pad_size: int,\n              batch_size: int):\n        device = runner.device\n        use_captured_graph = cuda_graph_pad_size != -1\n\n        logits_soft_cap = getattr(runner.model_config.hf_config,\n                                  \"attn_logit_softcapping\", None)\n        if logits_soft_cap is not None:\n            raise ValueError(\n                \"Please use Flashinfer backend for models with logits_soft_cap \"\n                \"(i.e., Gemma-2). Otherwise, the output might be wrong. \"\n                \"Set Flashinfer backend by \"\n                \"export VLLM_ATTENTION_BACKEND=FLASHINFER.\")\n\n        max_query_len = max(query_lens)\n        max_prefill_seq_len = max(self.prefill_seq_lens, default=0)\n        max_decode_seq_len = max(self.curr_seq_lens, default=0)\n        num_decode_tokens = self.num_decode_tokens\n\n        if use_captured_graph:\n            self.slot_mapping.extend([PAD_SLOT_ID] * cuda_graph_pad_size)\n            self.block_tables.extend([] * cuda_graph_pad_size)\n            num_decode_tokens = batch_size + cuda_graph_pad_size\n\n            # The shape of graph_block_tables is\n            # [max batch size, max context len // block size].\n            input_block_tables = runner.graph_block_tables[:batch_size]\n            for i, block_table in enumerate(self.block_tables):\n                if block_table:\n                    input_block_tables[i, :len(block_table)] = block_table\n            block_tables = torch.tensor(input_block_tables, device=device)\n        else:\n            max_block_table_len = max(\n                len(block_table) for block_table in self.block_tables)\n            block_tables = make_tensor_with_pad(\n                self.block_tables,\n                max_len=max_block_table_len,\n                pad=0,\n                dtype=torch.int,\n                device=device,\n            )\n        assert max_query_len > 0, \"query_lens: {}\".format(query_lens)\n\n        context_lens_tensor = torch.tensor(self.context_lens,\n                                           dtype=torch.int,\n                                           device=device)\n        seq_lens_tensor = torch.tensor(seq_lens,\n                                       dtype=torch.int,\n                                       device=device)\n        query_lens_tensor = torch.tensor(query_lens,\n                                         dtype=torch.long,\n                                         device=device)\n        query_start_loc = torch.zeros(query_lens_tensor.shape[0] + 1,\n                                      dtype=torch.int32,\n                                      device=device)\n        seq_start_loc = torch.zeros(seq_lens_tensor.shape[0] + 1,\n                                    dtype=torch.int32,\n                                    device=device)\n        torch.cumsum(seq_lens_tensor,\n                     dim=0,\n                     dtype=seq_start_loc.dtype,\n                     out=seq_start_loc[1:])\n        torch.cumsum(query_lens_tensor,\n                     dim=0,\n                     dtype=query_start_loc.dtype,\n                     out=query_start_loc[1:])\n\n        slot_mapping_tensor = torch.tensor(self.slot_mapping,\n                                           dtype=torch.long,\n                                           device=device)\n\n        return self._metadata_cls(  # type: ignore\n            num_prefills=self.num_prefills,\n            slot_mapping=slot_mapping_tensor,\n            num_prefill_tokens=self.num_prefill_tokens,\n            num_decode_tokens=num_decode_tokens,\n            seq_lens=seq_lens,\n            seq_lens_tensor=seq_lens_tensor,\n            max_query_len=max_query_len,\n            max_prefill_seq_len=max_prefill_seq_len,\n            max_decode_seq_len=max_decode_seq_len,\n            query_start_loc=query_start_loc,\n            seq_start_loc=seq_start_loc,\n            context_lens_tensor=context_lens_tensor,\n            block_tables=block_tables,\n            use_cuda_graph=use_captured_graph,\n        )\n",
      "diff": "diff --git a/vllm/attention/backends/utils.py b/vllm/attention/backends/utils.py\nindex 62d0eeb24..0706e2d3a 100644\n--- a/vllm/attention/backends/utils.py\n+++ b/vllm/attention/backends/utils.py\n@@ -182,11 +182,8 @@ class CommonMetadataBuilder(AttentionMetadataBuilder[TAttentionMetadata]):\n                     input_block_tables[i, :len(block_table)] = block_table\n             block_tables = torch.tensor(input_block_tables, device=device)\n         else:\n-            max_block_table_len = max(\n-                len(block_table) for block_table in self.block_tables)\n             block_tables = make_tensor_with_pad(\n                 self.block_tables,\n-                max_len=max_block_table_len,\n                 pad=0,\n                 dtype=torch.int,\n                 device=device,",
      "change_type": "modified",
      "lines_added": 1,
      "lines_removed": 4
    },
    {
      "file_path": "vllm/model_executor/sampling_metadata.py",
      "old_content": "import random\nfrom dataclasses import dataclass\nfrom typing import Dict, List, Optional, Tuple\n\nimport numpy as np\nimport torch\n\nfrom vllm.model_executor.layers.ops.sample import get_num_triton_sampler_splits\nfrom vllm.sampling_params import SamplingParams, SamplingType\nfrom vllm.sequence import SequenceData, SequenceGroupMetadata\nfrom vllm.utils import (async_tensor_h2d, is_pin_memory_available,\n                        maybe_expand_dim)\n\n_SAMPLING_EPS = 1e-5\n_SEED_0_REPLACEMENT = 3403598558\n\n\n@dataclass\nclass SequenceGroupToSample:\n    # |---------- N-1 iteration --------|\n    # |---------------- N iteration ---------------------|\n    # |- tokenA -|......................|-- newTokens ---|\n    # |---------- context_len ----------|\n    # |-------------------- seq_len ----------------------|\n    #                                   |-- query_len ---|\n\n    # Sequence ids for the sequence group in a previous step.\n    seq_ids: List[int]\n    sampling_params: SamplingParams\n    # seq_id -> sequence data.\n    seq_data: Dict[int, SequenceData]\n    # The length of the sequence (all tokens seen in the past + new token to\n    # compute attention) of the sequence group. None if it is in a decode\n    # stage.\n    seq_len: Optional[int]\n    # The length of new query tokens to compute in the current step. None if it\n    # is in a decode stage. The length of query_len <= seq_len if chunked\n    # prefill is enabled.\n    query_len: Optional[int]\n    # A random number generator for sampling.\n    generator: Optional[torch.Generator]\n    # True if the sequence group is in prefill stage. False if it is in a\n    # decode stage.\n    is_prompt: bool\n    # Query token indices from logits. to compute prompt logprob. Empty if\n    # prompt logprob is not required.\n    prompt_logprob_indices: List[int]\n    # Sample token indices from logits. Empty if sampling is not required.\n    sample_indices: List[int]\n\n    @property\n    def do_sample(self):\n        return len(self.sample_indices) > 0\n\n    def __post_init__(self):\n        if len(self.prompt_logprob_indices) > 0:\n            assert self.sampling_params.prompt_logprobs is not None\n        if self.is_prompt:\n            assert self.seq_len is not None\n            assert self.query_len is not None\n\n\nclass SamplingMetadata:\n    \"\"\"Metadata for input sequences. Used in sampler.\n\n    The usage is as follow;\n    ```\n    hidden_states = execute_model(...)\n    logits = hidden_states[sampling_metadata.selected_token_indices]\n    sample(logits)\n\n    def sample(logits):\n        # Use categorized_sample_indices for sampling....\n    ```\n\n    Args:\n        seq_groups: List of batched sequence groups.\n        selected_token_indices: (num_query_tokens_to_logprob). Indices to find\n            logits from the initial model output hidden states.\n        categorized_sample_indices: SamplingType -> token indices to sample.\n            Each token indices is 2D tensor of (num_indices, num_indices) where\n            the first item means the sample index within the returned logit\n            (before pruning padding), and the second item means the sample\n            index after pruning using selected_token_indices.\n            For example, if the returned logit is [1, 2, 3], and we select\n            [1, 2] for sampling, the pruned logit will be [2, 3]. In this case,\n            The first tuple is [1, 2] (sampled index within original logit),\n            and the second tuple is [0, 1] (sampled index within pruned logit).\n        num_prompts: Number of prompt sequence groups in seq_groups.\n        skip_sampler_cpu_output: Indicates if we want to skip the GPU=>CPU \n            serialization of token outputs.\n        reuse_sampling_tensors: Indicates if we want to reuse sampling \n            tensors that are part of the sampler forward pass. Currently,\n            it is mainly used for multi-step decode.\n            \n    \"\"\"\n\n    def __init__(\n        self,\n        seq_groups: List[SequenceGroupToSample],\n        selected_token_indices: torch.Tensor,\n        categorized_sample_indices: Dict[SamplingType, torch.Tensor],\n        num_prompts: int,\n        skip_sampler_cpu_output: bool = False,\n        reuse_sampling_tensors: bool = False,\n    ) -> None:\n        self.seq_groups = seq_groups\n        self.selected_token_indices = selected_token_indices\n        self.categorized_sample_indices = categorized_sample_indices\n        self.num_prompts = num_prompts\n        self.skip_sampler_cpu_output = skip_sampler_cpu_output\n        self.reuse_sampling_tensors = reuse_sampling_tensors\n\n    @staticmethod\n    def prepare(\n        seq_group_metadata_list: List[SequenceGroupMetadata],\n        seq_lens: List[int],\n        query_lens: Optional[List[int]],\n        device: str,\n        pin_memory: bool,\n    ) -> \"SamplingMetadata\":\n        (\n            seq_groups,\n            selected_token_indices,\n            categorized_sample_indices,\n            num_prompts,\n        ) = _prepare_seq_groups(seq_group_metadata_list, seq_lens, query_lens,\n                                device)\n        selected_token_indices = async_tensor_h2d(selected_token_indices,\n                                                  dtype=torch.long,\n                                                  target_device=device,\n                                                  pin_memory=pin_memory)\n        categorized_sample_indices = {\n            t: maybe_expand_dim(\n                async_tensor_h2d(seq_ids,\n                                 dtype=torch.int,\n                                 target_device=device,\n                                 pin_memory=pin_memory), 2, 2)\n            for t, seq_ids in categorized_sample_indices.items()\n        }\n\n        sampling_metadata = SamplingMetadata(\n            seq_groups=seq_groups,\n            selected_token_indices=selected_token_indices,\n            categorized_sample_indices=categorized_sample_indices,\n            num_prompts=num_prompts,\n        )\n        return sampling_metadata\n\n    def __repr__(self) -> str:\n        return (\n            \"SamplingMetadata(\"\n            f\"seq_groups={self.seq_groups}, \"\n            f\"selected_token_indices={self.selected_token_indices}, \"\n            f\"categorized_sample_indices={self.categorized_sample_indices}), \")\n\n\ndef _prepare_seq_groups(\n    seq_group_metadata_list: List[SequenceGroupMetadata],\n    seq_lens: List[int],\n    query_lens: Optional[List[int]],\n    device: str,\n) -> Tuple[List[SequenceGroupToSample], List[int], Dict[\n        SamplingType, List[Tuple[int, int]]], int]:\n    \"\"\"Prepare sequence groups and indices for sampling.\n\n    Args:\n        seq_group_metadata_list: A list of sequence group to batch.\n        seq_lens: A list of sequence lens per sequence group.\n            Index of prompt len should match with seq_group_metadata_list.\n        query_lens: A list of query lengths. Prompt lens include the length\n            of entire prompt tokens, and it could be shorter.\n        device: A device to use for random number generator,\n            `SequenceGroupToSample.generator`.\n\n    Returns:\n        seq_groups: A list of sequence group to sample.\n        selected_token_indices: See the definition from `SamplingMetadata`.\n        categorized_sample_indices: See the definition from `SamplingMetadata`.\n        num_prompts: Total number of prompts from `seq_group_metadata_list`.\n    \"\"\"\n    # Batched sequence groups for the current model forward stsep.\n    seq_groups: List[SequenceGroupToSample] = []\n    # A list of token indices to sample/compute logprob. It is used to\n    # prune the outcome logits from the model for the performance.\n    selected_token_indices: List[int] = []\n    # Used for selected_token_indices.\n    model_output_idx = 0\n\n    # Sampling type -> (\n    # indices to sample/prompt logprob within pruned output logits,\n    # indices to sample within pruned logits)\n    categorized_sample_indices: Dict[SamplingType, List[Tuple[int, int]]] = {\n        t: []\n        for t in SamplingType\n    }\n    # Index of logits to compute logprob. Logits include both prompt logprob\n    # and sample logprob indices.\n    logit_idx = 0\n    # Index to sample from a sample tensor. It is used by triton sample kernel.\n    # See `_sample_with_triton_kernel` for more details.\n    sample_idx = 0\n    # Total number of prompts from given sequence groups.\n    num_prompts = 0\n\n    for i, seq_group_metadata in enumerate(seq_group_metadata_list):\n        seq_ids = list(seq_group_metadata.seq_data.keys())\n        sampling_params = seq_group_metadata.sampling_params\n        is_prompt = seq_group_metadata.is_prompt\n        generator: Optional[torch.Generator] = None\n        # If the current seq group is in decode stage, it is None.\n        seq_len: Optional[int] = None\n        query_len: Optional[int] = None\n        prompt_logprob_indices: List[int] = []\n        sample_indices: List[int] = []\n        do_sample = seq_group_metadata.do_sample\n\n        if seq_group_metadata.is_prompt:\n            if sampling_params.seed is not None:\n                seq_group_metadata.state.generator = torch.Generator(\n                    device=device).manual_seed(sampling_params.seed)\n\n            num_prompts += 1\n            num_prefill_sample = len(seq_ids)\n            assert num_prefill_sample == 1\n            assert query_lens is not None and seq_lens is not None\n            query_len, seq_len = query_lens[i], seq_lens[i]\n            # If we need sampling, exclude num_prefill_sample tokens from\n            # prompt logprob.\n            prompt_logprob_len = (query_len - num_prefill_sample\n                                  if do_sample else query_len)\n            sample_len = num_prefill_sample if do_sample else 0\n        else:\n            # Decode\n            prompt_logprob_len = 0\n            sample_len = len(seq_ids) if do_sample else 0\n\n        # Update indices to select from the model output.\n        \"\"\"\n        This blocks computes selected_token_indices which is used in the\n        following way.\n\n        hidden_states = model(...)\n        logits = hidden_states[selected_token_indices]\n        \"\"\"\n\n        if sampling_params.prompt_logprobs is not None:\n            selected_token_indices.extend(\n                range(model_output_idx, model_output_idx + prompt_logprob_len))\n        model_output_idx += prompt_logprob_len\n        if do_sample:\n            selected_token_indices.extend(\n                range(model_output_idx, model_output_idx + sample_len))\n        model_output_idx += sample_len\n\n        # We now find indices for logprob computation and sampling.\n        \"\"\"\n        This block computes categorized_sample_indices which is used in the\n        following way.\n\n        hidden_states = model(...)\n        logits = hidden_states[selected_token_indices]\n        def sample(logits):\n           # Use categorized_sample_indices for sampling.\n           # prompt_logprob_indices to find prompt logprob indices.\n           # sample_indices to find sample indices.\n        \"\"\"\n\n        if sampling_params.prompt_logprobs is not None:\n            prompt_logprob_indices.extend(\n                range(logit_idx, logit_idx + prompt_logprob_len))\n            logit_idx += prompt_logprob_len\n        if do_sample:\n            sample_indices.extend(range(logit_idx, logit_idx + sample_len))\n            categorized_sample_indices[sampling_params.sampling_type].extend(\n                list(\n                    zip(range(logit_idx, logit_idx + sample_len),\n                        range(sample_idx, sample_idx + sample_len))))\n            logit_idx += sample_len\n            sample_idx += sample_len\n\n        if sampling_params.seed is not None:\n            generator = seq_group_metadata.state.generator\n\n        seq_groups.append(\n            SequenceGroupToSample(\n                seq_ids=seq_ids,\n                sampling_params=sampling_params,\n                seq_data=seq_group_metadata.seq_data,\n                seq_len=seq_len,\n                query_len=query_len,\n                generator=generator,\n                is_prompt=is_prompt,\n                prompt_logprob_indices=list(prompt_logprob_indices),\n                sample_indices=list(sample_indices)))\n    return (seq_groups, selected_token_indices, categorized_sample_indices,\n            num_prompts)\n\n\n@dataclass\nclass SamplingTensors:\n    \"\"\"Tensors for sampling.\"\"\"\n\n    temperatures: torch.Tensor\n    top_ps: torch.Tensor\n    top_ks: torch.Tensor\n    min_ps: torch.Tensor\n    presence_penalties: torch.Tensor\n    frequency_penalties: torch.Tensor\n    repetition_penalties: torch.Tensor\n    sampling_seeds: torch.Tensor\n    sample_indices: torch.Tensor\n    extra_seeds: Optional[torch.Tensor]\n    prompt_tokens: torch.Tensor\n    output_tokens: torch.Tensor\n\n    @classmethod\n    def from_sampling_metadata(\n        cls,\n        sampling_metadata: \"SamplingMetadata\",\n        vocab_size: int,\n        device: torch.device,\n        dtype: torch.dtype,\n        *,\n        extra_seeds_to_generate: int = 0,\n        extra_entropy: Optional[Tuple[int, ...]] = None\n    ) -> Tuple[\"SamplingTensors\", bool, bool, bool]:\n        \"\"\"\n        extra_seeds_to_generate: extra seeds to generate using the\n            user-defined seed for each sequence.\n        extra_entropy: extra entropy to use when generating seeds.\n        \"\"\"\n        prompt_tokens: List[List[int]] = []\n        output_tokens: List[List[int]] = []\n        top_ks: List[int] = []\n        temperatures: List[float] = []\n        top_ps: List[float] = []\n        min_ps: List[float] = []\n        presence_penalties: List[float] = []\n        frequency_penalties: List[float] = []\n        repetition_penalties: List[float] = []\n        sampling_seeds: List[int] = []\n        sample_indices: List[int] = []\n        prompt_best_of: List[int] = []\n        do_penalties = False\n        do_top_p_top_k = False\n        do_min_p = False\n\n        # We need one base seed per Triton slice.\n        seeds_to_generate = (extra_seeds_to_generate +\n                             get_num_triton_sampler_splits(vocab_size))\n\n        assert sampling_metadata.seq_groups is not None\n        for seq_group in sampling_metadata.seq_groups:\n            seq_ids = seq_group.seq_ids\n            sampling_params = seq_group.sampling_params\n            temperature = sampling_params.temperature\n            p = sampling_params.presence_penalty\n            f = sampling_params.frequency_penalty\n            r = sampling_params.repetition_penalty\n            top_p = sampling_params.top_p\n            min_p = sampling_params.min_p\n            seed = sampling_params.seed\n\n            is_greedy = sampling_params.sampling_type == SamplingType.GREEDY\n\n            # k should not be greater than the vocab size.\n            top_k = min(sampling_params.top_k, vocab_size)\n            top_k = vocab_size if top_k == -1 else top_k\n            if temperature < _SAMPLING_EPS:\n                # NOTE: Zero temperature means deterministic sampling\n                # (i.e., greedy sampling or beam search).\n                # Set the temperature to 1 to avoid division by zero.\n                temperature = 1.0\n            if not do_top_p_top_k and (top_p < 1.0 - _SAMPLING_EPS\n                                       or top_k != vocab_size):\n                do_top_p_top_k = True\n            if not do_min_p and min_p > _SAMPLING_EPS:\n                do_min_p = True\n            if not do_penalties and (abs(p) >= _SAMPLING_EPS\n                                     or abs(f) >= _SAMPLING_EPS\n                                     or abs(r - 1.0) >= _SAMPLING_EPS):\n                do_penalties = True\n\n            is_prompt = seq_group.is_prompt\n            if (seq_group.is_prompt\n                    and sampling_params.prompt_logprobs is not None):\n                # For tokens in the prompt that we only need to get\n                # their logprobs\n                query_len = seq_group.query_len\n                assert query_len is not None\n                prefill_len = len(seq_group.prompt_logprob_indices)\n                temperatures += [temperature] * prefill_len\n                top_ps += [top_p] * prefill_len\n                top_ks += [top_k] * prefill_len\n                min_ps += [min_p] * prefill_len\n                presence_penalties += [0] * prefill_len\n                frequency_penalties += [0] * prefill_len\n                repetition_penalties += [1] * prefill_len\n\n            if seq_group.do_sample:\n                sample_lens = len(seq_group.sample_indices)\n                assert sample_lens == len(seq_ids)\n                temperatures += [temperature] * len(seq_ids)\n                top_ps += [top_p] * len(seq_ids)\n                top_ks += [top_k] * len(seq_ids)\n                min_ps += [min_p] * len(seq_ids)\n                presence_penalties += [p] * len(seq_ids)\n                frequency_penalties += [f] * len(seq_ids)\n                repetition_penalties += [r] * len(seq_ids)\n\n            if is_prompt:\n                prompt_best_of.append(sampling_params.best_of)\n                query_len = seq_group.query_len\n                assert query_len is not None\n\n            for seq_id in seq_ids:\n                seq_data = seq_group.seq_data[seq_id]\n                extra_entropy = extra_entropy or ()\n                seq_seeds = cls._get_sequence_seeds(\n                    seed,\n                    seq_data.get_len(),\n                    *extra_entropy,\n                    seq_id,\n                    seeds_to_generate=seeds_to_generate,\n                    is_greedy=is_greedy)\n                sampling_seeds.append(seq_seeds)\n            sample_indices.extend(seq_group.sample_indices)\n\n        if do_penalties:\n            for seq_group in sampling_metadata.seq_groups:\n                seq_ids = seq_group.seq_ids\n                if (seq_group.is_prompt\n                        and sampling_params.prompt_logprobs is not None):\n                    prefill_len = len(seq_group.prompt_logprob_indices)\n                    prompt_tokens.extend([] for _ in range(prefill_len))\n                    output_tokens.extend([] for _ in range(prefill_len))\n                if seq_group.do_sample:\n                    for seq_id in seq_ids:\n                        seq_data = seq_group.seq_data[seq_id]\n                        prompt_tokens.append(list(seq_data.prompt_token_ids))\n                        output_tokens.append(list(seq_data.output_token_ids))\n\n        sampling_tensors = SamplingTensors.from_lists(\n            temperatures, top_ps, top_ks, min_ps, presence_penalties,\n            frequency_penalties, repetition_penalties, sampling_seeds,\n            sample_indices, prompt_tokens, output_tokens, vocab_size,\n            extra_seeds_to_generate, device, dtype)\n        return (sampling_tensors, do_penalties, do_top_p_top_k, do_min_p)\n\n    @classmethod\n    def from_lists(cls, temperatures: List[float], top_ps: List[float],\n                   top_ks: List[int], min_ps: List[float],\n                   presence_penalties: List[float],\n                   frequency_penalties: List[float],\n                   repetition_penalties: List[float],\n                   sampling_seeds: List[int], sample_indices: List[int],\n                   prompt_tokens: List[List[int]],\n                   output_tokens: List[List[int]], vocab_size: int,\n                   extra_seeds_to_generate: int, device: torch.device,\n                   dtype: torch.dtype) -> \"SamplingTensors\":\n        # Note that the performance will be very bad without\n        # pinned memory.\n        pin_memory = is_pin_memory_available()\n\n        do_penalties = prompt_tokens or output_tokens\n\n        if do_penalties:\n            prompt_max_len = max([len(tokens) for tokens in prompt_tokens],\n                                 default=0)\n            prompt_padded_tokens = np.full(\n                (len(prompt_tokens), prompt_max_len),\n                vocab_size,\n                dtype=np.int64)\n            for i, tokens in enumerate(prompt_tokens):\n                prompt_padded_tokens[i, :len(tokens)] = tokens\n            output_max_len = max([len(tokens) for tokens in output_tokens],\n                                 default=0)\n            output_padded_tokens = np.full(\n                (len(output_tokens), output_max_len),\n                vocab_size,\n                dtype=np.int64)\n            for i, tokens in enumerate(output_tokens):\n                output_padded_tokens[i, :len(tokens)] = tokens\n\n        temperatures_t = torch.tensor(\n            temperatures,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        top_ps_t = torch.tensor(\n            top_ps,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        min_ps_t = torch.tensor(\n            min_ps,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        presence_penalties_t = torch.tensor(\n            presence_penalties,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        frequency_penalties_t = torch.tensor(\n            frequency_penalties,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        repetition_penalties_t = torch.tensor(\n            repetition_penalties,\n            device=\"cpu\",\n            dtype=dtype,\n            pin_memory=pin_memory,\n        )\n        top_ks_t = torch.tensor(\n            top_ks,\n            device=\"cpu\",\n            dtype=torch.int,\n            pin_memory=pin_memory,\n        )\n        sample_indices_t = torch.tensor(\n            sample_indices,\n            device=\"cpu\",\n            dtype=torch.long,\n            pin_memory=pin_memory,\n        )\n        if do_penalties:\n            prompt_tensor = torch.from_numpy(prompt_padded_tokens)\n            output_tensor = torch.from_numpy(output_padded_tokens)\n            if pin_memory:\n                prompt_tensor = prompt_tensor.pin_memory()\n                output_tensor = output_tensor.pin_memory()\n        else:\n            prompt_tensor = None\n            output_tensor = None\n        # need to transpose and make contiguous to\n        # copy the tensor correctly.\n        # [batch_size, n_seeds] -> [n_seeds, batch_size]\n        sampling_seeds_t = torch.tensor(\n            sampling_seeds,\n            device=\"cpu\",\n            dtype=torch.long,\n            pin_memory=pin_memory,\n        ).T.contiguous()\n\n        # Because the memory is pinned, we can do non-blocking\n        # transfer to device.\n\n        # How many seeds the sample operation itself will need.\n        num_base_seeds = sampling_seeds_t.shape[0] - extra_seeds_to_generate\n        sampling_seeds_gpu = sampling_seeds_t.to(device=device,\n                                                 non_blocking=True)\n        extra_seeds_gpu = sampling_seeds_gpu[num_base_seeds:]\n        if not extra_seeds_gpu.numel():\n            extra_seeds_gpu = None\n        sampling_seeds_gpu = sampling_seeds_gpu[:num_base_seeds]\n\n        if do_penalties:\n            prompt_tokens_gpu = prompt_tensor.to(device=device,\n                                                 non_blocking=True)\n            output_tokens_gpu = output_tensor.to(device=device,\n                                                 non_blocking=True)\n        else:\n            empty_tensor = torch.empty(0, device=device, dtype=torch.long)\n            prompt_tokens_gpu = empty_tensor\n            output_tokens_gpu = empty_tensor\n\n        return cls(\n            temperatures=temperatures_t.to(device=device, non_blocking=True),\n            top_ps=top_ps_t.to(device=device, non_blocking=True),\n            top_ks=top_ks_t.to(device=device, non_blocking=True),\n            min_ps=min_ps_t.to(device=device, non_blocking=True),\n            presence_penalties=presence_penalties_t.to(device=device,\n                                                       non_blocking=True),\n            frequency_penalties=frequency_penalties_t.to(device=device,\n                                                         non_blocking=True),\n            repetition_penalties=repetition_penalties_t.to(device=device,\n                                                           non_blocking=True),\n            prompt_tokens=prompt_tokens_gpu,\n            output_tokens=output_tokens_gpu,\n            sampling_seeds=sampling_seeds_gpu,\n            sample_indices=sample_indices_t.to(device=device,\n                                               non_blocking=True),\n            extra_seeds=extra_seeds_gpu,\n        )\n\n    @staticmethod\n    def _get_sequence_seeds(\n        seed: int,\n        *extra_entropy: int,\n        seeds_to_generate: int,\n        is_greedy: bool,\n    ):\n        \"\"\"Get `seeds_to_generate` child seeds from `seed` and extra entropy.\"\"\"\n        if not is_greedy:\n            if seed is None:\n                randint_fn = random.randint\n            else:\n                generator = random.Random(str((seed, ) + extra_entropy))\n                randint_fn = generator.randint\n            lo, hi = torch.iinfo(torch.long).min, torch.iinfo(torch.long).max\n            # If the user/random sets seed = 0 but request should\n            # have sampling, we need to change it to something\n            # else. We use a constant in that case.\n            # This way we don't need to create and load a bool\n            # matrix in the sampling kernel, which reduces CPU\n            # overhead and latency.\n            seq_seeds = [\n                randint_fn(lo, hi) or _SEED_0_REPLACEMENT\n                for _ in range(seeds_to_generate)\n            ]\n        else:\n            # For the kernel, seed == 0 means greedy decoding.\n            seq_seeds = [0] * seeds_to_generate\n        return seq_seeds\n",
      "diff": "diff --git a/vllm/model_executor/sampling_metadata.py b/vllm/model_executor/sampling_metadata.py\nindex 29b077cf6..390b5d173 100644\n--- a/vllm/model_executor/sampling_metadata.py\n+++ b/vllm/model_executor/sampling_metadata.py\n@@ -2,14 +2,13 @@ import random\n from dataclasses import dataclass\n from typing import Dict, List, Optional, Tuple\n \n-import numpy as np\n import torch\n \n from vllm.model_executor.layers.ops.sample import get_num_triton_sampler_splits\n from vllm.sampling_params import SamplingParams, SamplingType\n from vllm.sequence import SequenceData, SequenceGroupMetadata\n from vllm.utils import (async_tensor_h2d, is_pin_memory_available,\n-                        maybe_expand_dim)\n+                        make_tensor_with_pad, maybe_expand_dim)\n \n _SAMPLING_EPS = 1e-5\n _SEED_0_REPLACEMENT = 3403598558\n@@ -466,22 +465,24 @@ class SamplingTensors:\n         do_penalties = prompt_tokens or output_tokens\n \n         if do_penalties:\n-            prompt_max_len = max([len(tokens) for tokens in prompt_tokens],\n-                                 default=0)\n-            prompt_padded_tokens = np.full(\n-                (len(prompt_tokens), prompt_max_len),\n+            prompt_t = make_tensor_with_pad(\n+                prompt_tokens,\n                 vocab_size,\n-                dtype=np.int64)\n-            for i, tokens in enumerate(prompt_tokens):\n-                prompt_padded_tokens[i, :len(tokens)] = tokens\n-            output_max_len = max([len(tokens) for tokens in output_tokens],\n-                                 default=0)\n-            output_padded_tokens = np.full(\n-                (len(output_tokens), output_max_len),\n+                device=\"cpu\",\n+                dtype=torch.int64,\n+                pin_memory=pin_memory,\n+            )\n+            output_t = make_tensor_with_pad(\n+                output_tokens,\n                 vocab_size,\n-                dtype=np.int64)\n-            for i, tokens in enumerate(output_tokens):\n-                output_padded_tokens[i, :len(tokens)] = tokens\n+                device=\"cpu\",\n+                dtype=torch.int64,\n+                pin_memory=pin_memory,\n+            )\n+        else:\n+            empty_tensor = torch.empty(0, device=device, dtype=torch.long)\n+            prompt_t = empty_tensor\n+            output_t = empty_tensor\n \n         temperatures_t = torch.tensor(\n             temperatures,\n@@ -531,15 +532,6 @@ class SamplingTensors:\n             dtype=torch.long,\n             pin_memory=pin_memory,\n         )\n-        if do_penalties:\n-            prompt_tensor = torch.from_numpy(prompt_padded_tokens)\n-            output_tensor = torch.from_numpy(output_padded_tokens)\n-            if pin_memory:\n-                prompt_tensor = prompt_tensor.pin_memory()\n-                output_tensor = output_tensor.pin_memory()\n-        else:\n-            prompt_tensor = None\n-            output_tensor = None\n         # need to transpose and make contiguous to\n         # copy the tensor correctly.\n         # [batch_size, n_seeds] -> [n_seeds, batch_size]\n@@ -562,16 +554,6 @@ class SamplingTensors:\n             extra_seeds_gpu = None\n         sampling_seeds_gpu = sampling_seeds_gpu[:num_base_seeds]\n \n-        if do_penalties:\n-            prompt_tokens_gpu = prompt_tensor.to(device=device,\n-                                                 non_blocking=True)\n-            output_tokens_gpu = output_tensor.to(device=device,\n-                                                 non_blocking=True)\n-        else:\n-            empty_tensor = torch.empty(0, device=device, dtype=torch.long)\n-            prompt_tokens_gpu = empty_tensor\n-            output_tokens_gpu = empty_tensor\n-\n         return cls(\n             temperatures=temperatures_t.to(device=device, non_blocking=True),\n             top_ps=top_ps_t.to(device=device, non_blocking=True),\n@@ -583,8 +565,8 @@ class SamplingTensors:\n                                                          non_blocking=True),\n             repetition_penalties=repetition_penalties_t.to(device=device,\n                                                            non_blocking=True),\n-            prompt_tokens=prompt_tokens_gpu,\n-            output_tokens=output_tokens_gpu,\n+            prompt_tokens=prompt_t.to(device=device, non_blocking=True),\n+            output_tokens=output_t.to(device=device, non_blocking=True),\n             sampling_seeds=sampling_seeds_gpu,\n             sample_indices=sample_indices_t.to(device=device,\n                                                non_blocking=True),",
      "change_type": "modified",
      "lines_added": 20,
      "lines_removed": 38
    },
    {
      "file_path": "vllm/utils.py",
      "old_content": "import argparse\nimport asyncio\nimport contextlib\nimport datetime\nimport enum\nimport gc\nimport os\nimport socket\nimport subprocess\nimport sys\nimport tempfile\nimport threading\nimport uuid\nimport warnings\nfrom collections import defaultdict\nfrom functools import lru_cache, partial, wraps\nfrom platform import uname\nfrom typing import (Any, AsyncIterator, Awaitable, Callable, Dict, Generic,\n                    Hashable, List, Optional, OrderedDict, Set, Tuple, TypeVar,\n                    Union)\n\nimport numpy as np\nimport psutil\nimport torch\nimport torch.types\nfrom typing_extensions import ParamSpec\n\nimport vllm.envs as envs\nfrom vllm import _custom_ops as ops\nfrom vllm.logger import enable_trace_function_call, init_logger\n\nlogger = init_logger(__name__)\n\nSTR_DTYPE_TO_TORCH_DTYPE = {\n    \"half\": torch.half,\n    \"bfloat16\": torch.bfloat16,\n    \"float\": torch.float,\n    \"fp8\": torch.uint8,\n    \"fp8_e4m3\": torch.uint8,\n    \"fp8_e5m2\": torch.uint8,\n}\n\nP = ParamSpec('P')\nK = TypeVar(\"K\")\nT = TypeVar(\"T\")\n\n\nclass _Sentinel:\n    ...\n\n\nALL_PINNED_SENTINEL = _Sentinel()\n\n\nclass Device(enum.Enum):\n    GPU = enum.auto()\n    CPU = enum.auto()\n\n\nclass Counter:\n\n    def __init__(self, start: int = 0) -> None:\n        self.counter = start\n\n    def __next__(self) -> int:\n        i = self.counter\n        self.counter += 1\n        return i\n\n    def reset(self) -> None:\n        self.counter = 0\n\n\nclass LRUCache(Generic[T]):\n\n    def __init__(self, capacity: int):\n        self.cache: OrderedDict[Hashable, T] = OrderedDict()\n        self.pinned_items: Set[Hashable] = set()\n        self.capacity = capacity\n\n    def __contains__(self, key: Hashable) -> bool:\n        return key in self.cache\n\n    def __len__(self) -> int:\n        return len(self.cache)\n\n    def __getitem__(self, key: Hashable) -> Optional[T]:\n        return self.get(key)\n\n    def __setitem__(self, key: Hashable, value: T) -> None:\n        self.put(key, value)\n\n    def __delitem__(self, key: Hashable) -> None:\n        self.pop(key)\n\n    def touch(self, key: Hashable) -> None:\n        self.cache.move_to_end(key)\n\n    def get(self,\n            key: Hashable,\n            default_value: Optional[T] = None) -> Optional[T]:\n        if key in self.cache:\n            value: Optional[T] = self.cache[key]\n            self.cache.move_to_end(key)\n        else:\n            value = default_value\n        return value\n\n    def put(self, key: Hashable, value: T) -> None:\n        self.cache[key] = value\n        self.cache.move_to_end(key)\n        self._remove_old_if_needed()\n\n    def pin(self, key: Hashable) -> None:\n        \"\"\"\n        Pins a key in the cache preventing it from being\n        evicted in the LRU order.\n        \"\"\"\n        if key not in self.cache:\n            raise ValueError(f\"Cannot pin key: {key} not in cache.\")\n        self.pinned_items.add(key)\n\n    def _unpin(self, key: Hashable) -> None:\n        self.pinned_items.remove(key)\n\n    def _on_remove(self, key: Hashable, value: Optional[T]):\n        pass\n\n    def remove_oldest(self, remove_pinned=False):\n        if not self.cache:\n            return\n\n        if not remove_pinned:\n            # pop the oldest item in the cache that is not pinned\n            lru_key = next(\n                (key for key in self.cache if key not in self.pinned_items),\n                ALL_PINNED_SENTINEL)\n            if lru_key is ALL_PINNED_SENTINEL:\n                raise RuntimeError(\"All items are pinned, \"\n                                   \"cannot remove oldest from the cache.\")\n        else:\n            lru_key = next(iter(self.cache))\n        self.pop(lru_key)\n\n    def _remove_old_if_needed(self) -> None:\n        while len(self.cache) > self.capacity:\n            self.remove_oldest()\n\n    def pop(self,\n            key: Hashable,\n            default_value: Optional[T] = None) -> Optional[T]:\n        run_on_remove = key in self.cache\n        value: Optional[T] = self.cache.pop(key, default_value)\n        # remove from pinned items\n        if key in self.pinned_items:\n            self._unpin(key)\n        if run_on_remove:\n            self._on_remove(key, value)\n        return value\n\n    def clear(self):\n        while len(self.cache) > 0:\n            self.remove_oldest(remove_pinned=True)\n        self.cache.clear()\n\n\ndef is_hip() -> bool:\n    return torch.version.hip is not None\n\n\n@lru_cache(maxsize=None)\ndef is_cpu() -> bool:\n    from importlib.metadata import PackageNotFoundError, version\n    try:\n        return \"cpu\" in version(\"vllm\")\n    except PackageNotFoundError:\n        return False\n\n\n@lru_cache(maxsize=None)\ndef is_openvino() -> bool:\n    from importlib.metadata import PackageNotFoundError, version\n    try:\n        return \"openvino\" in version(\"vllm\")\n    except PackageNotFoundError:\n        return False\n\n\n@lru_cache(maxsize=None)\ndef is_neuron() -> bool:\n    try:\n        import transformers_neuronx\n    except ImportError:\n        transformers_neuronx = None\n    return transformers_neuronx is not None\n\n\n@lru_cache(maxsize=None)\ndef is_tpu() -> bool:\n    try:\n        import libtpu\n    except ImportError:\n        libtpu = None\n    return libtpu is not None\n\n\n@lru_cache(maxsize=None)\ndef is_xpu() -> bool:\n    from importlib.metadata import version\n    is_xpu_flag = \"xpu\" in version(\"vllm\")\n    # vllm is not build with xpu\n    if not is_xpu_flag:\n        return False\n    try:\n        import intel_extension_for_pytorch as ipex  # noqa: F401\n        _import_ipex = True\n    except ImportError as e:\n        logger.warning(\"Import Error for IPEX: %s\", e.msg)\n        _import_ipex = False\n    # ipex dependency is not ready\n    if not _import_ipex:\n        logger.warning(\"not found ipex lib\")\n        return False\n    return hasattr(torch, \"xpu\") and torch.xpu.is_available()\n\n\n@lru_cache(maxsize=None)\ndef get_max_shared_memory_bytes(gpu: int = 0) -> int:\n    \"\"\"Returns the maximum shared memory per thread block in bytes.\"\"\"\n    max_shared_mem = (\n        ops.get_max_shared_memory_per_block_device_attribute(gpu))\n    # value 0 will cause MAX_SEQ_LEN become negative and test_attention.py\n    # will fail\n    assert max_shared_mem > 0, \"max_shared_mem can not be zero\"\n    return int(max_shared_mem)\n\n\ndef get_cpu_memory() -> int:\n    \"\"\"Returns the total CPU memory of the node in bytes.\"\"\"\n    return psutil.virtual_memory().total\n\n\ndef random_uuid() -> str:\n    return str(uuid.uuid4().hex)\n\n\n@lru_cache(maxsize=None)\ndef get_vllm_instance_id() -> str:\n    \"\"\"\n    If the environment variable VLLM_INSTANCE_ID is set, return it.\n    Otherwise, return a random UUID.\n    Instance id represents an instance of the VLLM. All processes in the same\n    instance should have the same instance id.\n    \"\"\"\n    return envs.VLLM_INSTANCE_ID or f\"vllm-instance-{random_uuid()}\"\n\n\n@lru_cache(maxsize=None)\ndef in_wsl() -> bool:\n    # Reference: https://github.com/microsoft/WSL/issues/4071\n    return \"microsoft\" in \" \".join(uname()).lower()\n\n\ndef make_async(func: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Take a blocking function, and run it on in an executor thread.\n\n    This function prevents the blocking function from blocking the\n    asyncio event loop.\n    The code in this function needs to be thread safe.\n    \"\"\"\n\n    def _async_wrapper(*args: P.args, **kwargs: P.kwargs) -> asyncio.Future:\n        loop = asyncio.get_event_loop()\n        p_func = partial(func, *args, **kwargs)\n        return loop.run_in_executor(executor=None, func=p_func)\n\n    return _async_wrapper\n\n\ndef merge_async_iterators(\n        *iterators: AsyncIterator[T]) -> AsyncIterator[Tuple[int, T]]:\n    \"\"\"Merge multiple asynchronous iterators into a single iterator.\n\n    This method handle the case where some iterators finish before others.\n    When it yields, it yields a tuple (i, item) where i is the index of the\n    iterator that yields the item.\n    \"\"\"\n    queue: asyncio.Queue[Union[Tuple[int, T], Exception]] = asyncio.Queue()\n\n    finished = [False] * len(iterators)\n\n    async def producer(i: int, iterator: AsyncIterator[T]):\n        try:\n            async for item in iterator:\n                await queue.put((i, item))\n        except Exception as e:\n            await queue.put(e)\n        finished[i] = True\n\n    _tasks = [\n        asyncio.create_task(producer(i, iterator))\n        for i, iterator in enumerate(iterators)\n    ]\n\n    async def consumer():\n        try:\n            while not all(finished) or not queue.empty():\n                item = await queue.get()\n                if isinstance(item, Exception):\n                    raise item\n                yield item\n        except (Exception, asyncio.CancelledError) as e:\n            for task in _tasks:\n                if sys.version_info >= (3, 9):\n                    # msg parameter only supported in Python 3.9+\n                    task.cancel(e)\n                else:\n                    task.cancel()\n            raise e\n        await asyncio.gather(*_tasks)\n\n    return consumer()\n\n\ndef get_ip() -> str:\n    host_ip = envs.VLLM_HOST_IP\n    if host_ip:\n        return host_ip\n\n    # IP is not set, try to get it from the network interface\n\n    # try ipv4\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    try:\n        s.connect((\"8.8.8.8\", 80))  # Doesn't need to be reachable\n        return s.getsockname()[0]\n    except Exception:\n        pass\n\n    # try ipv6\n    try:\n        s = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)\n        # Google's public DNS server, see\n        # https://developers.google.com/speed/public-dns/docs/using#addresses\n        s.connect((\"2001:4860:4860::8888\", 80))  # Doesn't need to be reachable\n        return s.getsockname()[0]\n    except Exception:\n        pass\n\n    warnings.warn(\n        \"Failed to get the IP address, using 0.0.0.0 by default.\"\n        \"The value can be set by the environment variable\"\n        \" VLLM_HOST_IP or HOST_IP.\",\n        stacklevel=2)\n    return \"0.0.0.0\"\n\n\ndef get_distributed_init_method(ip: str, port: int) -> str:\n    # Brackets are not permitted in ipv4 addresses,\n    # see https://github.com/python/cpython/issues/103848\n    return f\"tcp://[{ip}]:{port}\" if \":\" in ip else f\"tcp://{ip}:{port}\"\n\n\ndef get_open_port() -> int:\n    port = envs.VLLM_PORT\n    if port is not None:\n        while True:\n            try:\n                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n                    s.bind((\"\", port))\n                    return port\n            except OSError:\n                port += 1  # Increment port number if already in use\n                logger.info(\"Port %d is already in use, trying port %d\",\n                            port - 1, port)\n    # try ipv4\n    try:\n        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n            s.bind((\"\", 0))\n            return s.getsockname()[1]\n    except OSError:\n        # try ipv6\n        with socket.socket(socket.AF_INET6, socket.SOCK_STREAM) as s:\n            s.bind((\"\", 0))\n            return s.getsockname()[1]\n\n\ndef update_environment_variables(envs: Dict[str, str]):\n    for k, v in envs.items():\n        if k in os.environ and os.environ[k] != v:\n            logger.warning(\n                \"Overwriting environment variable %s \"\n                \"from '%s' to '%s'\", k, os.environ[k], v)\n        os.environ[k] = v\n\n\ndef init_kmp_env():\n    if not is_cpu():\n        return\n\n    ld_prealod_str = os.getenv(\"LD_PRELOAD\", \"\")\n    if \"libiomp5.so\" not in ld_prealod_str:\n        return\n\n    # The time(milliseconds) that a thread should wait after completing the\n    # execution of a parallel region, before sleeping.\n    os.environ['KMP_BLOCKTIME'] = \"1\"\n    # dump settings on start up\n    os.environ['KMP_SETTINGS'] = \"1\"\n    # Prevents the CPU to run into low performance state\n    os.environ['KMP_TPAUSE'] = \"0\"\n    # Provides fine granularity parallelism\n    os.environ['KMP_FORKJOIN_BARRIER_PATTERN'] = \"dist,dist\"\n    os.environ['KMP_PLAIN_BARRIER_PATTERN'] = \"dist,dist\"\n    os.environ['KMP_REDUCTION_BARRIER_PATTERN'] = \"dist,dist\"\n\n\ndef chunk_list(lst: List[T], chunk_size: int):\n    \"\"\"Yield successive chunk_size chunks from lst.\"\"\"\n    for i in range(0, len(lst), chunk_size):\n        yield lst[i:i + chunk_size]\n\n\ndef cdiv(a: int, b: int) -> int:\n    \"\"\"Ceiling division.\"\"\"\n    return -(a // -b)\n\n\ndef _generate_random_fp8(\n    tensor: torch.Tensor,\n    low: float,\n    high: float,\n) -> None:\n    # NOTE(zhaoyang): Due to NaN and Inf representation for fp8 data type,\n    # it may occur Inf or NaN if we directly use torch.randint\n    # to generate random data for fp8 data.\n    # For example, s.11111.00 in fp8e5m2 format represents Inf.\n    #     | E4M3        | E5M2\n    #-----|-------------|-------------------\n    # Inf | N/A         | s.11111.00\n    # NaN | s.1111.111  | s.11111.{01,10,11}\n    from vllm import _custom_ops as ops\n    tensor_tmp = torch.empty_like(tensor, dtype=torch.float16)\n    tensor_tmp.uniform_(low, high)\n    ops.convert_fp8(tensor, tensor_tmp)\n    del tensor_tmp\n\n\ndef get_kv_cache_torch_dtype(\n        cache_dtype: Optional[Union[str, torch.dtype]],\n        model_dtype: Optional[Union[str, torch.dtype]] = None) -> torch.dtype:\n    if isinstance(cache_dtype, str):\n        if cache_dtype == \"auto\":\n            if isinstance(model_dtype, str):\n                torch_dtype = STR_DTYPE_TO_TORCH_DTYPE[model_dtype]\n            elif isinstance(model_dtype, torch.dtype):\n                torch_dtype = model_dtype\n            else:\n                raise ValueError(f\"Invalid model dtype: {model_dtype}\")\n        elif cache_dtype in [\"half\", \"bfloat16\", \"float\"]:\n            torch_dtype = STR_DTYPE_TO_TORCH_DTYPE[cache_dtype]\n        elif cache_dtype == \"fp8\":\n            torch_dtype = torch.uint8\n        else:\n            raise ValueError(f\"Invalid kv cache dtype: {cache_dtype}\")\n    elif isinstance(cache_dtype, torch.dtype):\n        torch_dtype = cache_dtype\n    else:\n        raise ValueError(f\"Invalid kv cache dtype: {cache_dtype}\")\n    return torch_dtype\n\n\ndef create_kv_caches_with_random_flash(\n    num_blocks: int,\n    block_size: int,\n    num_layers: int,\n    num_heads: int,\n    head_size: int,\n    cache_dtype: Optional[Union[str, torch.dtype]],\n    model_dtype: Optional[Union[str, torch.dtype]] = None,\n    seed: int = 0,\n    device: Optional[str] = \"cuda\",\n) -> Tuple[List[torch.Tensor], List[torch.Tensor]]:\n    assert cache_dtype != \"fp8\"\n    torch.random.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed(seed)\n\n    torch_dtype = get_kv_cache_torch_dtype(cache_dtype, model_dtype)\n    key_value_cache_shape = (num_blocks, 2, block_size, num_heads, head_size)\n    scale = head_size**-0.5\n\n    key_caches: List[torch.Tensor] = []\n    value_caches: List[torch.Tensor] = []\n\n    for _ in range(num_layers):\n        key_value_cache = torch.empty(size=key_value_cache_shape,\n                                      dtype=torch_dtype,\n                                      device=device)\n        key_value_cache.uniform_(-scale, scale)\n        key_caches.append(key_value_cache[:, 0])\n        value_caches.append(key_value_cache[:, 1])\n    return key_caches, value_caches\n\n\ndef create_kv_caches_with_random(\n    num_blocks: int,\n    block_size: int,\n    num_layers: int,\n    num_heads: int,\n    head_size: int,\n    cache_dtype: Optional[Union[str, torch.dtype]],\n    model_dtype: Optional[Union[str, torch.dtype]] = None,\n    seed: int = 0,\n    device: Optional[str] = \"cuda\",\n) -> Tuple[List[torch.Tensor], List[torch.Tensor]]:\n    torch.random.manual_seed(seed)\n    if torch.cuda.is_available():\n        torch.cuda.manual_seed(seed)\n\n    torch_dtype = get_kv_cache_torch_dtype(cache_dtype, model_dtype)\n\n    scale = head_size**-0.5\n    x = 16 // torch.tensor([], dtype=torch_dtype).element_size()\n    key_cache_shape = (num_blocks, num_heads, head_size // x, block_size, x)\n    key_caches: List[torch.Tensor] = []\n    for _ in range(num_layers):\n        key_cache = torch.empty(size=key_cache_shape,\n                                dtype=torch_dtype,\n                                device=device)\n        if cache_dtype in [\"auto\", \"half\", \"bfloat16\", \"float\"]:\n            key_cache.uniform_(-scale, scale)\n        elif cache_dtype == 'fp8':\n            _generate_random_fp8(key_cache, -scale, scale)\n        else:\n            raise ValueError(\n                f\"Does not support key cache of type {cache_dtype}\")\n        key_caches.append(key_cache)\n\n    value_cache_shape = (num_blocks, num_heads, head_size, block_size)\n    value_caches: List[torch.Tensor] = []\n    for _ in range(num_layers):\n        value_cache = torch.empty(size=value_cache_shape,\n                                  dtype=torch_dtype,\n                                  device=device)\n        if cache_dtype in [\"auto\", \"half\", \"bfloat16\", \"float\"]:\n            value_cache.uniform_(-scale, scale)\n        elif cache_dtype == 'fp8':\n            _generate_random_fp8(value_cache, -scale, scale)\n        else:\n            raise ValueError(\n                f\"Does not support value cache of type {cache_dtype}\")\n        value_caches.append(value_cache)\n    return key_caches, value_caches\n\n\n@lru_cache\ndef print_warning_once(msg: str) -> None:\n    logger.warning(msg)\n\n\n@lru_cache(maxsize=None)\ndef is_pin_memory_available() -> bool:\n\n    if in_wsl():\n        # Pinning memory in WSL is not supported.\n        # https://docs.nvidia.com/cuda/wsl-user-guide/index.html#known-limitations-for-linux-cuda-applications\n        print_warning_once(\"Using 'pin_memory=False' as WSL is detected. \"\n                           \"This may slow down the performance.\")\n        return False\n    elif is_xpu():\n        print_warning_once(\"Pin memory is not supported on XPU.\")\n        return False\n    elif is_neuron():\n        print_warning_once(\"Pin memory is not supported on Neuron.\")\n        return False\n    elif is_cpu() or is_openvino():\n        return False\n    return True\n\n\nclass CudaMemoryProfiler:\n\n    def __init__(self, device: Optional[torch.types.Device] = None):\n        self.device = device\n\n    def current_memory_usage(self) -> float:\n        # Return the memory usage in bytes.\n        if torch.cuda.is_available():\n            torch.cuda.reset_peak_memory_stats(self.device)\n            mem = torch.cuda.max_memory_allocated(self.device)\n        elif is_xpu():\n            torch.xpu.reset_peak_memory_stats(self.device)\n            mem = torch.xpu.max_memory_allocated(self.device)\n        return mem\n\n    def __enter__(self):\n        self.initial_memory = self.current_memory_usage()\n        # This allows us to call methods of the context manager if needed\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        self.final_memory = self.current_memory_usage()\n        self.consumed_memory = self.final_memory - self.initial_memory\n\n        # Force garbage collection\n        gc.collect()\n\n\ndef str_to_int_tuple(s: str) -> Tuple[int, ...]:\n    \"\"\"Convert a string to a tuple of integers.\"\"\"\n    try:\n        return tuple(map(int, s.split(\",\")))\n    except ValueError as e:\n        raise ValueError(\n            \"String must be a series of integers separated by commas \"\n            f\"(e.g., 1, 2, 3). Given input: {s}\") from e\n\n\ndef make_tensor_with_pad(\n    x: List[List[int]],\n    max_len: int,\n    pad: int,\n    dtype: torch.dtype,\n    device: Optional[Union[str, torch.device]],\n) -> torch.Tensor:\n    \"\"\"Make a padded tensor of a 2D inputs.\n\n    The padding is applied to the end of each inner list until it reaches\n    `max_len`.\n    \"\"\"\n    padded_x = np.zeros([len(x), max_len], dtype=np.int32) + pad\n    for ind, blocktb in enumerate(x):\n        assert len(blocktb) <= max_len\n        padded_x[ind, :len(blocktb)] = blocktb\n    return torch.tensor(padded_x, dtype=dtype, device=device)\n\n\ndef async_tensor_h2d(\n    data: list,\n    dtype: torch.dtype,\n    target_device: Union[str, torch.device],\n    pin_memory: bool,\n) -> torch.Tensor:\n    \"\"\"Asynchronously create a tensor and copy it from host to device.\"\"\"\n    t = torch.tensor(data, dtype=dtype, pin_memory=pin_memory, device=\"cpu\")\n    return t.to(device=target_device, non_blocking=True)\n\n\ndef maybe_expand_dim(tensor: torch.Tensor,\n                     target_dims: int,\n                     size: int = 1) -> torch.Tensor:\n    \"\"\"Expand the tensor to the target_dims.\"\"\"\n    if tensor.ndim < target_dims:\n        tensor = tensor.view(-1, *([size] * (target_dims - tensor.ndim)))\n    return tensor\n\n\ndef get_dtype_size(dtype: torch.dtype) -> int:\n    \"\"\"Get the size of the data type in bytes.\"\"\"\n    return torch.tensor([], dtype=dtype).element_size()\n\n\ndef merge_dicts(dict1: Dict[K, List[T]],\n                dict2: Dict[K, List[T]]) -> Dict[K, List[T]]:\n    \"\"\"Merge 2 dicts that have key -> List of items.\n\n    When a key conflicts, the values in dict1 is prioritized.\n    \"\"\"\n    merged_dict: Dict[K, List[T]] = defaultdict(list)\n\n    for key, value in dict1.items():\n        merged_dict[key].extend(value)\n\n    for key, value in dict2.items():\n        merged_dict[key].extend(value)\n\n    return dict(merged_dict)\n\n\ndef init_cached_hf_modules() -> None:\n    \"\"\"\n    Lazy initialization of the Hugging Face modules.\n    \"\"\"\n    from transformers.dynamic_module_utils import init_hf_modules\n    init_hf_modules()\n\n\n@lru_cache(maxsize=None)\ndef find_library(lib_name: str) -> str:\n    \"\"\"\n    Find the library file in the system.\n    `lib_name` is full filename, with both prefix and suffix.\n    This function resolves `lib_name` to the full path of the library.\n    \"\"\"\n    # Adapted from https://github.com/openai/triton/blob/main/third_party/nvidia/backend/driver.py#L19 # noqa\n    # According to https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard\n    # `/sbin/ldconfig` should exist in all Linux systems.\n    # `/sbin/ldconfig` searches the library in the system\n    libs = subprocess.check_output([\"/sbin/ldconfig\", \"-p\"]).decode()\n    # each line looks like the following:\n    # libcuda.so.1 (libc6,x86-64) => /lib/x86_64-linux-gnu/libcuda.so.1\n    locs = [line.split()[-1] for line in libs.splitlines() if lib_name in line]\n    # `LD_LIBRARY_PATH` searches the library in the user-defined paths\n    env_ld_library_path = envs.LD_LIBRARY_PATH\n    if not locs and env_ld_library_path:\n        locs = [\n            os.path.join(dir, lib_name)\n            for dir in env_ld_library_path.split(\":\")\n            if os.path.exists(os.path.join(dir, lib_name))\n        ]\n    if not locs:\n        raise ValueError(f\"Cannot find {lib_name} in the system.\")\n    return locs[0]\n\n\ndef find_nccl_library() -> str:\n    \"\"\"\n    We either use the library file specified by the `VLLM_NCCL_SO_PATH`\n    environment variable, or we find the library file brought by PyTorch.\n    After importing `torch`, `libnccl.so.2` or `librccl.so.1` can be\n    found by `ctypes` automatically.\n    \"\"\"\n    so_file = envs.VLLM_NCCL_SO_PATH\n\n    # manually load the nccl library\n    if so_file:\n        logger.info(\n            \"Found nccl from environment variable VLLM_NCCL_SO_PATH=%s\",\n            so_file)\n    else:\n        if torch.version.cuda is not None:\n            so_file = \"libnccl.so.2\"\n        elif torch.version.hip is not None:\n            so_file = \"librccl.so.1\"\n        else:\n            raise ValueError(\"NCCL only supports CUDA and ROCm backends.\")\n        logger.info(\"Found nccl from library %s\", so_file)\n    return so_file\n\n\ndef enable_trace_function_call_for_thread() -> None:\n    \"\"\"Set up function tracing for the current thread,\n    if enabled via the VLLM_TRACE_FUNCTION environment variable\n    \"\"\"\n\n    if envs.VLLM_TRACE_FUNCTION:\n        tmp_dir = tempfile.gettempdir()\n        filename = (f\"VLLM_TRACE_FUNCTION_for_process_{os.getpid()}\"\n                    f\"_thread_{threading.get_ident()}_\"\n                    f\"at_{datetime.datetime.now()}.log\").replace(\" \", \"_\")\n        log_path = os.path.join(tmp_dir, \"vllm\", get_vllm_instance_id(),\n                                filename)\n        os.makedirs(os.path.dirname(log_path), exist_ok=True)\n        enable_trace_function_call(log_path)\n\n\ndef identity(value: T) -> T:\n    return value\n\n\nF = TypeVar('F', bound=Callable[..., Any])\n\n\ndef deprecate_kwargs(\n        *kws: str,\n        is_deprecated: Union[bool, Callable[[], bool]] = True,\n        additional_message: Optional[str] = None) -> Callable[[F], F]:\n    deprecated_kws = set(kws)\n\n    if not callable(is_deprecated):\n        is_deprecated = partial(identity, is_deprecated)\n\n    def wrapper(fn: F) -> F:\n\n        @wraps(fn)\n        def inner(*args, **kwargs):\n            if is_deprecated():\n                deprecated_kwargs = kwargs.keys() & deprecated_kws\n                if deprecated_kwargs:\n                    msg = (\n                        f\"The keyword arguments {deprecated_kwargs} are \"\n                        \"deprecated and will be removed in a future update.\")\n                    if additional_message is not None:\n                        msg += f\" {additional_message}\"\n\n                    warnings.warn(\n                        DeprecationWarning(msg),\n                        stacklevel=3,  # The inner function takes up one level\n                    )\n\n            return fn(*args, **kwargs)\n\n        return inner  # type: ignore\n\n    return wrapper\n\n\n@lru_cache(maxsize=8)\ndef _cuda_device_count_stateless(\n        cuda_visible_devices: Optional[str] = None) -> int:\n    # Note: cuda_visible_devices is not used, but we keep it as an argument for\n    # LRU Cache purposes.\n\n    # Code below is based on\n    # https://github.com/pytorch/pytorch/blob/\n    # c1cd946818442aca8c7f812b16d187ce1586c3bc/\n    # torch/cuda/__init__.py#L831C1-L831C17\n    import torch.cuda\n    import torch.version\n\n    if not torch.cuda._is_compiled():\n        return 0\n    if is_hip():\n        # ROCm uses amdsmi instead of nvml for stateless device count\n        # This requires a sufficiently modern version of Torch 2.4.0\n        raw_count = torch.cuda._device_count_amdsmi() if (hasattr(\n            torch.cuda, \"_device_count_amdsmi\")) else -1\n    else:\n        raw_count = torch.cuda._device_count_nvml()\n    r = torch._C._cuda_getDeviceCount() if raw_count < 0 else raw_count\n    return r\n\n\ndef cuda_device_count_stateless() -> int:\n    \"\"\"Get number of CUDA devices, caching based on the value of\n    CUDA_VISIBLE_DEVICES at the time of call.\n    \n    This should be used instead of torch.cuda.device_count()\n    unless CUDA_VISIBLE_DEVICES has already been set to the desired\n    value.\"\"\"\n\n    # This can be removed and simply replaced with torch.cuda.get_device_count\n    # after https://github.com/pytorch/pytorch/pull/122815 is released.\n    return _cuda_device_count_stateless(envs.CUDA_VISIBLE_DEVICES)\n\n\ndef error_on_invalid_device_count_status():\n    cache_entries = 0\n    with contextlib.suppress(Exception):\n        # future pytorch will fix the issue, device_count will not be cached\n        # at that time, `.cache_info().currsize` will error out\n        cache_entries = torch.cuda.device_count.cache_info().currsize\n    if cache_entries != 0:\n        # the function is already called, and the result is cached\n        remembered = torch.cuda.device_count()\n        current = cuda_device_count_stateless()\n        if remembered > current:\n            raise RuntimeError(\n                \"The number of CUDA devices has changed since the first \"\n                \"call to torch.cuda.device_count(). This is not allowed \"\n                \"and may result in undefined behavior. Please check out \"\n                \"https://github.com/vllm-project/vllm/issues/6056 to \"\n                \"find the first call to torch.cuda.device_count() \"\n                \"and defer it until the engine is up. Or you can set \"\n                \"CUDA_VISIBLE_DEVICES to the GPUs you want to use.\")\n\n\n# NVML utils\n# Note that NVML is not affected by `CUDA_VISIBLE_DEVICES`,\n# all the related functions work on real physical device ids.\n# the major benefit of using NVML is that it will not initialize CUDA\n\ntry:\n    import pynvml\nexcept ImportError:\n    # For non-NV devices\n    pynvml = None\n\n\ndef with_nvml_context(fn):\n\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        if pynvml is not None:\n            pynvml.nvmlInit()\n        try:\n            return fn(*args, **kwargs)\n        finally:\n            if pynvml is not None:\n                pynvml.nvmlShutdown()\n\n    return wrapper\n\n\n@with_nvml_context\ndef is_full_nvlink(device_ids: List[int]) -> bool:\n    \"\"\"\n    query if the set of gpus are fully connected by nvlink (1 hop)\n    \"\"\"\n    handles = [pynvml.nvmlDeviceGetHandleByIndex(i) for i in device_ids]\n    for i, handle in enumerate(handles):\n        for j, peer_handle in enumerate(handles):\n            if i < j:\n                try:\n                    p2p_status = pynvml.nvmlDeviceGetP2PStatus(\n                        handle, peer_handle, pynvml.NVML_P2P_CAPS_INDEX_NVLINK)\n                    if p2p_status != pynvml.NVML_P2P_STATUS_OK:\n                        return False\n                except pynvml.NVMLError as error:\n                    logger.error(\n                        \"NVLink detection failed. This is normal if your\"\n                        \" machine has no NVLink equipped.\",\n                        exc_info=error)\n                    return False\n    return True\n\n\n#From: https://stackoverflow.com/a/4104188/2749989\ndef run_once(f):\n\n    def wrapper(*args, **kwargs) -> Any:\n        if not wrapper.has_run:  # type: ignore[attr-defined]\n            wrapper.has_run = True  # type: ignore[attr-defined]\n            return f(*args, **kwargs)\n\n    wrapper.has_run = False  # type: ignore[attr-defined]\n    return wrapper\n\n\nclass FlexibleArgumentParser(argparse.ArgumentParser):\n    \"\"\"ArgumentParser that allows both underscore and dash in names.\"\"\"\n\n    def parse_args(self, args=None, namespace=None):\n        if args is None:\n            args = sys.argv[1:]\n\n        # Convert underscores to dashes and vice versa in argument names\n        processed_args = []\n        for arg in args:\n            if arg.startswith('--'):\n                if '=' in arg:\n                    key, value = arg.split('=', 1)\n                    key = '--' + key[len('--'):].replace('_', '-')\n                    processed_args.append(f'{key}={value}')\n                else:\n                    processed_args.append('--' +\n                                          arg[len('--'):].replace('_', '-'))\n            else:\n                processed_args.append(arg)\n\n        return super().parse_args(processed_args, namespace)\n\n\nasync def _run_task_with_lock(task: Callable, lock: asyncio.Lock, *args,\n                              **kwargs):\n    \"\"\"Utility function to run async task in a lock\"\"\"\n    async with lock:\n        return await task(*args, **kwargs)\n",
      "diff": "diff --git a/vllm/utils.py b/vllm/utils.py\nindex f906d8258..9e222772e 100644\n--- a/vllm/utils.py\n+++ b/vllm/utils.py\n@@ -20,6 +20,7 @@ from typing import (Any, AsyncIterator, Awaitable, Callable, Dict, Generic,\n                     Union)\n \n import numpy as np\n+import numpy.typing as npt\n import psutil\n import torch\n import torch.types\n@@ -40,6 +41,15 @@ STR_DTYPE_TO_TORCH_DTYPE = {\n     \"fp8_e5m2\": torch.uint8,\n }\n \n+TORCH_DTYPE_TO_NUMPY_DTYPE = {\n+    torch.float16: np.float16,\n+    torch.float32: np.float32,\n+    torch.float64: np.float64,\n+    torch.uint8: np.uint8,\n+    torch.int32: np.int32,\n+    torch.int64: np.int64,\n+}\n+\n P = ParamSpec('P')\n K = TypeVar(\"K\")\n T = TypeVar(\"T\")\n@@ -617,23 +627,54 @@ def str_to_int_tuple(s: str) -> Tuple[int, ...]:\n             f\"(e.g., 1, 2, 3). Given input: {s}\") from e\n \n \n-def make_tensor_with_pad(\n-    x: List[List[int]],\n-    max_len: int,\n-    pad: int,\n-    dtype: torch.dtype,\n-    device: Optional[Union[str, torch.device]],\n-) -> torch.Tensor:\n-    \"\"\"Make a padded tensor of a 2D inputs.\n+def make_ndarray_with_pad(\n+    x: List[List[T]],\n+    pad: T,\n+    dtype: npt.DTypeLike,\n+    *,\n+    max_len: Optional[int] = None,\n+) -> npt.NDArray:\n+    \"\"\"\n+    Make a padded array from 2D inputs.\n \n     The padding is applied to the end of each inner list until it reaches\n     `max_len`.\n     \"\"\"\n-    padded_x = np.zeros([len(x), max_len], dtype=np.int32) + pad\n+    if max_len is None:\n+        # Unlike for most functions, map is faster than a genexpr over `len`\n+        max_len = max(map(len, x), default=0)\n+\n+    padded_x = np.full((len(x), max_len), pad, dtype=dtype)\n     for ind, blocktb in enumerate(x):\n         assert len(blocktb) <= max_len\n         padded_x[ind, :len(blocktb)] = blocktb\n-    return torch.tensor(padded_x, dtype=dtype, device=device)\n+\n+    return padded_x\n+\n+\n+def make_tensor_with_pad(\n+    x: List[List[T]],\n+    pad: T,\n+    dtype: torch.dtype,\n+    *,\n+    max_len: Optional[int] = None,\n+    device: Optional[Union[str, torch.device]] = None,\n+    pin_memory: bool = False,\n+) -> torch.Tensor:\n+    \"\"\"\n+    Make a padded tensor from 2D inputs.\n+\n+    The padding is applied to the end of each inner list until it reaches\n+    `max_len`.\n+    \"\"\"\n+    np_dtype = TORCH_DTYPE_TO_NUMPY_DTYPE[dtype]\n+    padded_x = make_ndarray_with_pad(x, pad, np_dtype, max_len=max_len)\n+\n+    tensor = torch.from_numpy(padded_x).to(device)\n+    if pin_memory:\n+        tensor = tensor.pin_memory()\n+\n+    return tensor\n \n \n def async_tensor_h2d(",
      "change_type": "modified",
      "lines_added": 52,
      "lines_removed": 11
    },
    {
      "file_path": "vllm/worker/cpu_model_runner.py",
      "old_content": "from dataclasses import dataclass\nfrom typing import (TYPE_CHECKING, Any, Dict, List, Mapping, Optional, Tuple,\n                    Type, Union)\n\nimport torch\nfrom torch import nn\n\nfrom vllm.attention import AttentionMetadata, get_attn_backend\nfrom vllm.config import (CacheConfig, DeviceConfig, LoadConfig, LoRAConfig,\n                         ModelConfig, MultiModalConfig, ParallelConfig,\n                         PromptAdapterConfig, SchedulerConfig)\nfrom vllm.logger import init_logger\nfrom vllm.model_executor import SamplingMetadata\nfrom vllm.model_executor.model_loader import get_model\nfrom vllm.multimodal import (MULTIMODAL_REGISTRY, BatchedTensors,\n                             MultiModalInputs)\nfrom vllm.sequence import (IntermediateTensors, SamplerOutput,\n                           SequenceGroupMetadata)\nfrom vllm.utils import make_tensor_with_pad\nfrom vllm.worker.model_runner_base import (\n    ModelRunnerBase, ModelRunnerInputBase,\n    _add_attn_metadata_broadcastable_dict,\n    _add_sampling_metadata_broadcastable_dict,\n    _init_attn_metadata_from_tensor_dict,\n    _init_sampling_metadata_from_tensor_dict)\n\nif TYPE_CHECKING:\n    from vllm.attention.backends.abstract import AttentionBackend\n\nlogger = init_logger(__name__)\n\n_PAD_SLOT_ID = -1\n\n\n@dataclass(frozen=True)\nclass CPUModelInput(ModelRunnerInputBase):\n    \"\"\"\n    Used by the CPUModelRunner.\n    \"\"\"\n    input_tokens: Optional[torch.Tensor] = None\n    input_positions: Optional[torch.Tensor] = None\n    attn_metadata: Optional[\"AttentionMetadata\"] = None\n    sampling_metadata: Optional[\"SamplingMetadata\"] = None\n    multi_modal_kwargs: Optional[Mapping[str, BatchedTensors]] = None\n\n    def as_broadcastable_tensor_dict(\n            self) -> Dict[str, Union[int, torch.Tensor]]:\n        tensor_dict = {\n            \"input_tokens\": self.input_tokens,\n            \"input_positions\": self.input_positions,\n            \"multi_modal_kwargs\": self.multi_modal_kwargs,\n        }\n        _add_attn_metadata_broadcastable_dict(tensor_dict, self.attn_metadata)\n        _add_sampling_metadata_broadcastable_dict(tensor_dict,\n                                                  self.sampling_metadata)\n        return tensor_dict\n\n    @classmethod\n    def from_broadcasted_tensor_dict(\n            cls: Type[\"CPUModelInput\"],\n            tensor_dict: Dict[str, Any],\n            attn_backend: Optional[\"AttentionBackend\"] = None\n    ) -> \"CPUModelInput\":\n        tensor_dict = _init_sampling_metadata_from_tensor_dict(tensor_dict)\n        if attn_backend is not None:\n            tensor_dict = _init_attn_metadata_from_tensor_dict(\n                attn_backend, tensor_dict)\n        return cls(**tensor_dict)\n\n\nclass CPUModelRunner(ModelRunnerBase[CPUModelInput]):\n\n    def __init__(\n        self,\n        model_config: ModelConfig,\n        parallel_config: ParallelConfig,\n        scheduler_config: SchedulerConfig,\n        device_config: DeviceConfig,\n        cache_config: CacheConfig,\n        load_config: LoadConfig,\n        lora_config: Optional[LoRAConfig],\n        multimodal_config: Optional[MultiModalConfig],\n        kv_cache_dtype: Optional[str] = \"auto\",\n        prompt_adapter_config: Optional[PromptAdapterConfig] = None,\n        is_driver_worker: bool = False,\n        *args,\n        **kwargs,\n    ):\n        self.model_config = model_config\n        self.parallel_config = parallel_config\n        self.scheduler_config = scheduler_config\n        # Currently, CPU worker doesn't support chunked prefill.\n        assert self.scheduler_config.chunked_prefill_enabled is False\n        self.device_config = device_config\n        self.cache_config = cache_config\n        self.lora_config = lora_config\n        self.multimodal_config = multimodal_config\n        self.prompt_adapter_config = prompt_adapter_config\n        self.load_config = load_config\n        self.is_driver_worker = is_driver_worker\n\n        self.device = self.device_config.device\n\n        self.kv_cache_dtype = kv_cache_dtype\n        self.sliding_window = model_config.get_sliding_window()\n        self.block_size = cache_config.block_size\n        self.attn_backend = get_attn_backend(\n            self.model_config.get_num_attention_heads(self.parallel_config),\n            self.model_config.get_head_size(),\n            self.model_config.get_num_kv_heads(self.parallel_config),\n            self.model_config.get_sliding_window(),\n            self.model_config.dtype,\n            self.kv_cache_dtype,\n            self.block_size,\n        )\n\n        # Multi-modal data support\n        self.multi_modal_input_mapper = MULTIMODAL_REGISTRY \\\n            .create_input_mapper(self.model_config)\n\n        # Lazy initialization.\n        self.model: nn.Module  # Set after init_Model\n\n    def load_model(self) -> None:\n        self.model = get_model(model_config=self.model_config,\n                               load_config=self.load_config,\n                               device_config=self.device_config,\n                               multimodal_config=self.multimodal_config,\n                               lora_config=self.lora_config,\n                               parallel_config=self.parallel_config,\n                               scheduler_config=self.scheduler_config,\n                               cache_config=self.cache_config)\n\n    def _prepare_prompt(\n        self,\n        seq_group_metadata_list: List[SequenceGroupMetadata],\n    ) -> Tuple[torch.Tensor, torch.Tensor, AttentionMetadata, List[int],\n               Mapping[str, BatchedTensors]]:\n        assert len(seq_group_metadata_list) > 0\n        input_tokens: List[int] = []\n        input_positions: List[int] = []\n        slot_mapping: List[int] = []\n        seq_lens: List[int] = []\n        multi_modal_inputs_list: List[MultiModalInputs] = []\n\n        for seq_group_metadata in seq_group_metadata_list:\n            assert seq_group_metadata.is_prompt\n            seq_ids = list(seq_group_metadata.seq_data.keys())\n            assert len(seq_ids) == 1\n            seq_id = seq_ids[0]\n\n            seq_data = seq_group_metadata.seq_data[seq_id]\n            prompt_tokens = seq_data.get_token_ids()\n            computed_len = seq_data.get_num_computed_tokens()\n            seq_len = len(prompt_tokens)\n\n            seq_lens.append(seq_len)  # Prompt token num\n            input_tokens.extend(prompt_tokens)  # Token ids\n\n            # Token position ids\n            # NOTE(woosuk): Here we assume that the first token in the prompt\n            # is always the first token in the sequence.\n            input_positions.extend(list(range(computed_len, seq_len)))\n\n            mm_data = seq_group_metadata.multi_modal_data\n            if mm_data:\n                mm_kwargs = self.multi_modal_input_mapper(mm_data)\n                multi_modal_inputs_list.append(mm_kwargs)\n\n            # Compute the slot mapping.\n            block_table = seq_group_metadata.block_tables[seq_id]\n            # Mask the [0, start_idx) tokens of the prompt with _PAD_SLOT_ID,\n            # where start_idx is max(0, seq_len - sliding_window).\n            # For example, if the prompt len is 10, sliding window is 8, and\n            # block size is 4, the first two tokens are masked and the slot\n            # mapping will be [-1, -1, 2, 3, 4, 5, 6, 7, 0, 1].\n            start_idx = 0\n            if self.sliding_window is not None:\n                start_idx = max(0, seq_len - self.sliding_window)\n\n            for i in range(computed_len, seq_len):\n                if i < start_idx:\n                    slot_mapping.append(_PAD_SLOT_ID)\n                    continue\n\n                block_number = block_table[i //\n                                           self.block_size]  # type: ignore\n                block_offset = i % self.block_size  # type: ignore\n                slot = block_number * self.block_size + block_offset\n                slot_mapping.append(slot)\n\n        num_prompt_tokens = len(input_tokens)\n\n        input_tokens = torch.tensor(input_tokens,\n                                    dtype=torch.long,\n                                    device=self.device)  # type: ignore\n        input_positions = torch.tensor(input_positions,\n                                       dtype=torch.long,\n                                       device=self.device)  # type: ignore\n        slot_mapping = torch.tensor(slot_mapping,\n                                    dtype=torch.long,\n                                    device=self.device)  # type: ignore\n\n        attn_metadata = self.attn_backend.make_metadata(\n            is_prompt=True,\n            seq_lens=seq_lens,\n            seq_lens_tensor=None,\n            max_decode_seq_len=None,\n            num_prefills=len(seq_lens),\n            num_prefill_tokens=num_prompt_tokens,\n            num_decode_tokens=0,\n            block_tables=torch.tensor([]),\n            slot_mapping=slot_mapping,\n        )\n\n        multi_modal_kwargs = MultiModalInputs.batch(multi_modal_inputs_list,\n                                                    device=self.device)\n\n        return (input_tokens, input_positions, attn_metadata, seq_lens,\n                multi_modal_kwargs)\n\n    def _prepare_decode(\n        self,\n        seq_group_metadata_list: List[SequenceGroupMetadata],\n    ) -> Tuple[torch.Tensor, torch.Tensor, AttentionMetadata]:\n        assert len(seq_group_metadata_list) > 0\n        input_tokens: List[int] = []\n        input_positions: List[int] = []\n        slot_mapping: List[int] = []\n        seq_lens: List[int] = []\n        block_tables: List[List[int]] = []\n\n        for seq_group_metadata in seq_group_metadata_list:\n            assert not seq_group_metadata.is_prompt\n            assert seq_group_metadata.token_chunk_size == 1\n\n            seq_ids = list(seq_group_metadata.seq_data.keys())\n\n            for seq_id in seq_ids:\n                seq_data = seq_group_metadata.seq_data[seq_id]\n                generation_token = seq_data.get_last_token_id()\n                input_tokens.append(generation_token)\n\n                seq_len = seq_data.get_len()\n                position = seq_len - 1\n                input_positions.append(position)\n\n                seq_len = seq_len if self.sliding_window is None else min(\n                    seq_len, self.sliding_window)\n                seq_lens.append(seq_len)\n\n                block_table = seq_group_metadata.block_tables[seq_id]\n                block_number = block_table[position // self.block_size]\n                block_offset = position % self.block_size\n                slot = block_number * self.block_size + block_offset\n                slot_mapping.append(slot)\n\n                if self.sliding_window is not None:\n                    sliding_window_blocks = (self.sliding_window //\n                                             self.block_size)\n                    block_table = block_table[-sliding_window_blocks:]\n                block_tables.append(block_table)\n\n        max_decode_seq_len = max(seq_lens)\n\n        input_tokens = torch.tensor(input_tokens,\n                                    dtype=torch.long,\n                                    device=self.device)\n        input_positions = torch.tensor(input_positions,\n                                       dtype=torch.long,\n                                       device=self.device)\n        slot_mapping = torch.tensor(slot_mapping,\n                                    dtype=torch.long,\n                                    device=self.device)\n        seq_lens_tensor = torch.tensor(seq_lens,\n                                       dtype=torch.int,\n                                       device=self.device)\n\n        max_block_table_len = max(\n            len(block_table) for block_table in block_tables)\n        block_tables = make_tensor_with_pad(\n            block_tables,\n            max_len=max_block_table_len,\n            pad=0,\n            dtype=torch.int,\n            device=self.device,\n        )\n\n        attn_metadata = self.attn_backend.make_metadata(\n            is_prompt=False,\n            slot_mapping=slot_mapping,\n            seq_lens=seq_lens,\n            seq_lens_tensor=seq_lens_tensor,\n            max_decode_seq_len=max_decode_seq_len,\n            num_prefill_tokens=0,\n            num_decode_tokens=len(input_tokens),\n            num_prefills=0,\n            block_tables=block_tables,\n        )\n        return (\n            input_tokens,\n            input_positions,\n            attn_metadata,\n        )\n\n    def make_model_input_from_broadcasted_tensor_dict(\n        self,\n        tensor_dict: Dict[str, Any],\n    ) -> CPUModelInput:\n        return CPUModelInput.from_broadcasted_tensor_dict(\n            tensor_dict,\n            attn_backend=self.attn_backend,\n        )\n\n    def prepare_model_input(\n            self,\n            seq_group_metadata_list: List[SequenceGroupMetadata],\n            virtual_engine: int = 0,\n            finished_requests_ids: Optional[List[str]] = None\n    ) -> CPUModelInput:\n        multi_modal_kwargs = None\n        # NOTE: We assume that all sequences in the group are all prompts or\n        # all decodes.\n        is_prompt = seq_group_metadata_list[0].is_prompt\n        # Prepare input tensors.\n        if is_prompt:\n            (input_tokens, input_positions, attn_metadata, seq_lens,\n             multi_modal_kwargs\n             ) = self._prepare_prompt(seq_group_metadata_list)\n        else:\n            (input_tokens, input_positions,\n             attn_metadata) = self._prepare_decode(seq_group_metadata_list)\n            seq_lens = []\n        sampling_metadata = SamplingMetadata.prepare(\n            seq_group_metadata_list,\n            seq_lens,\n            # query_lens is not needed if chunked prefill is not\n            # supported. Since CPU worker doesn't support chunked prefill\n            # just use seq_lens instead.\n            seq_lens,\n            self.device,\n            pin_memory=False)\n        return CPUModelInput(\n            input_tokens=input_tokens,\n            input_positions=input_positions,\n            attn_metadata=attn_metadata,\n            sampling_metadata=sampling_metadata,\n            multi_modal_kwargs=multi_modal_kwargs,\n        )\n\n    @torch.inference_mode()\n    def execute_model(\n        self,\n        model_input: CPUModelInput,\n        kv_caches: List[torch.Tensor],\n        intermediate_tensors: Optional[IntermediateTensors] = None,\n        num_steps: int = 1,\n    ) -> Optional[List[SamplerOutput]]:\n        if num_steps > 1:\n            raise ValueError(\n                \"CPU worker does not support multi-step execution.\")\n\n        model_executable = self.model\n        execute_model_kwargs = {\n            \"input_ids\": model_input.input_tokens,\n            \"positions\": model_input.input_positions,\n            \"kv_caches\": kv_caches,\n            \"attn_metadata\": model_input.attn_metadata,\n            **(model_input.multi_modal_kwargs or {}),\n        }\n\n        hidden_states = model_executable(**execute_model_kwargs)\n\n        # Compute the logits.\n        logits = self.model.compute_logits(hidden_states,\n                                           model_input.sampling_metadata)\n\n        # Only perform sampling in the driver worker.\n        if not self.is_driver_worker:\n            return []\n\n        # Sample the next token.\n        output = self.model.sample(\n            logits=logits,\n            sampling_metadata=model_input.sampling_metadata,\n        )\n        return [output]\n",
      "diff": "diff --git a/vllm/worker/cpu_model_runner.py b/vllm/worker/cpu_model_runner.py\nindex db0e178e4..83f4ba69f 100644\n--- a/vllm/worker/cpu_model_runner.py\n+++ b/vllm/worker/cpu_model_runner.py\n@@ -276,11 +276,8 @@ class CPUModelRunner(ModelRunnerBase[CPUModelInput]):\n                                        dtype=torch.int,\n                                        device=self.device)\n \n-        max_block_table_len = max(\n-            len(block_table) for block_table in block_tables)\n         block_tables = make_tensor_with_pad(\n             block_tables,\n-            max_len=max_block_table_len,\n             pad=0,\n             dtype=torch.int,\n             device=self.device,",
      "change_type": "modified",
      "lines_added": 1,
      "lines_removed": 4
    },
    {
      "file_path": "vllm/worker/neuron_model_runner.py",
      "old_content": "from dataclasses import dataclass\nfrom typing import (TYPE_CHECKING, Any, Dict, List, Mapping, Optional, Tuple,\n                    Union)\n\nimport torch\nfrom torch import nn\n\nfrom vllm.config import (DeviceConfig, ModelConfig, ParallelConfig,\n                         SchedulerConfig)\nfrom vllm.logger import init_logger\nfrom vllm.model_executor import SamplingMetadata\nfrom vllm.model_executor.model_loader.neuron import get_neuron_model\nfrom vllm.multimodal import (MULTIMODAL_REGISTRY, BatchedTensors,\n                             MultiModalInputs)\nfrom vllm.sequence import (IntermediateTensors, SamplerOutput,\n                           SequenceGroupMetadata)\nfrom vllm.utils import is_pin_memory_available, make_tensor_with_pad\nfrom vllm.worker.model_runner_base import ModelRunnerBase, ModelRunnerInputBase\n\nif TYPE_CHECKING:\n    from vllm.attention.backends.abstract import AttentionBackend\n\nlogger = init_logger(__name__)\n\n\n@dataclass(frozen=True)\nclass ModelInputForNeuron(ModelRunnerInputBase):\n    \"\"\"\n    Used by the NeuronModelRunner.\n    \"\"\"\n    input_tokens: Optional[torch.Tensor] = None\n    input_positions: Optional[torch.Tensor] = None\n    input_block_ids: Optional[torch.Tensor] = None\n    sampling_metadata: Optional[\"SamplingMetadata\"] = None\n    multi_modal_kwargs: Optional[Mapping[str, BatchedTensors]] = None\n\n    def as_broadcastable_tensor_dict(\n            self) -> Dict[str, Union[int, torch.Tensor]]:\n        raise NotImplementedError(\"ModelInputForNeuron cannot be broadcast.\")\n\n    @classmethod\n    def from_broadcasted_tensor_dict(\n        cls,\n        tensor_dict: Dict[str, Any],\n        attn_backend: Optional[\"AttentionBackend\"] = None,\n    ) -> \"ModelInputForNeuron\":\n        assert attn_backend is None\n        return cls.from_broadcasted_tensor_dict(tensor_dict)\n\n\nclass NeuronModelRunner(ModelRunnerBase[ModelInputForNeuron]):\n\n    def __init__(\n        self,\n        model_config: ModelConfig,\n        parallel_config: ParallelConfig,\n        scheduler_config: SchedulerConfig,\n        device_config: DeviceConfig,\n    ):\n        self.model_config = model_config\n        self.parallel_config = parallel_config\n        self.scheduler_config = scheduler_config\n\n        if model_config is not None and model_config.get_sliding_window():\n            logger.warning(\"Sliding window is not supported on Neuron. \"\n                           \"The model will run without sliding window.\")\n        self.device_config = (device_config\n                              if device_config is not None else DeviceConfig())\n        self.device = self.device_config.device\n        self.pin_memory = is_pin_memory_available()\n\n        # Multi-modal data support\n        self.multi_modal_input_mapper = MULTIMODAL_REGISTRY \\\n            .create_input_mapper(self.model_config)\n\n        # Lazy initialization.\n        self.model: nn.Module  # initialize after load_model.\n\n    def load_model(self) -> None:\n        self.model = get_neuron_model(self.model_config,\n                                      parallel_config=self.parallel_config,\n                                      scheduler_config=self.scheduler_config)\n\n    def _prepare_prompt(\n        self,\n        seq_group_metadata_list: List[SequenceGroupMetadata],\n    ) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor, List[int], Mapping[\n            str, BatchedTensors]]:\n        assert len(seq_group_metadata_list) > 0\n        input_tokens: List[List[int]] = []\n        input_positions: List[List[int]] = []\n        input_block_ids: List[int] = []\n\n        seq_lens: List[int] = []\n        multi_modal_inputs_list: List[MultiModalInputs] = []\n        for seq_group_metadata in seq_group_metadata_list:\n            assert seq_group_metadata.is_prompt\n            seq_ids = list(seq_group_metadata.seq_data.keys())\n            assert len(seq_ids) == 1\n            seq_id = seq_ids[0]\n\n            seq_data = seq_group_metadata.seq_data[seq_id]\n            prompt_tokens = seq_data.get_token_ids()\n            seq_len = len(prompt_tokens)\n            seq_lens.append(seq_len)\n\n            input_tokens.append(prompt_tokens)\n            input_positions.append(list(range(seq_len)))\n\n            assert seq_group_metadata.block_tables is not None\n            block_table = seq_group_metadata.block_tables[seq_id]\n            assert len(block_table) == 1\n            input_block_ids.append(block_table[0])\n\n            mm_data = seq_group_metadata.multi_modal_data\n            if mm_data:\n                # Process multi-modal data\n                mm_kwargs = self.multi_modal_input_mapper(mm_data)\n                multi_modal_inputs_list.append(mm_kwargs)\n\n        max_seq_len = max(seq_lens)\n        assert max_seq_len > 0\n        input_tokens = make_tensor_with_pad(input_tokens,\n                                            max_seq_len,\n                                            pad=0,\n                                            dtype=torch.long,\n                                            device=self.device)\n        input_positions = make_tensor_with_pad(input_positions,\n                                               max_seq_len,\n                                               pad=0,\n                                               dtype=torch.long,\n                                               device=self.device)\n        input_block_ids = torch.tensor(input_block_ids,\n                                       dtype=torch.long,\n                                       device=self.device)\n\n        multi_modal_kwargs = MultiModalInputs.batch(multi_modal_inputs_list,\n                                                    device=self.device)\n\n        return (input_tokens, input_positions, input_block_ids, seq_lens,\n                multi_modal_kwargs)\n\n    def _prepare_decode(\n        self,\n        seq_group_metadata_list: List[SequenceGroupMetadata],\n    ) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n        assert len(seq_group_metadata_list) > 0\n        input_tokens: List[List[int]] = []\n        input_positions: List[List[int]] = []\n        input_block_ids: List[int] = []\n        context_lens: List[int] = []\n\n        for seq_group_metadata in seq_group_metadata_list:\n            assert not seq_group_metadata.is_prompt\n\n            seq_ids = list(seq_group_metadata.seq_data.keys())\n\n            for seq_id in seq_ids:\n                seq_data = seq_group_metadata.seq_data[seq_id]\n                generation_token = seq_data.get_last_token_id()\n                input_tokens.append([generation_token])\n\n                seq_len = seq_data.get_len()\n                position = seq_len - 1\n                input_positions.append([position])\n                context_lens.append(seq_len)\n\n                assert seq_group_metadata.block_tables is not None\n                block_table = seq_group_metadata.block_tables[seq_id]\n                assert len(block_table) == 1\n                input_block_ids.append(block_table[0])\n\n        input_tokens = make_tensor_with_pad(input_tokens,\n                                            max_len=1,\n                                            pad=0,\n                                            dtype=torch.long,\n                                            device=self.device)\n        input_positions = make_tensor_with_pad(input_positions,\n                                               max_len=1,\n                                               pad=0,\n                                               dtype=torch.long,\n                                               device=self.device)\n        context_lens = torch.tensor(context_lens,\n                                    dtype=torch.int,\n                                    device=self.device)\n        input_block_ids = torch.tensor(input_block_ids,\n                                       dtype=torch.long,\n                                       device=self.device)\n\n        return input_tokens, input_positions, input_block_ids\n\n    def make_model_input_from_broadcasted_tensor_dict(\n            self, tensor_dict: Dict[str, Any]) -> ModelInputForNeuron:\n        return ModelInputForNeuron.from_broadcasted_tensor_dict(tensor_dict)\n\n    def prepare_model_input(\n        self,\n        seq_group_metadata_list: List[SequenceGroupMetadata],\n        virtual_engine: int = 0,\n        finished_requests_ids: Optional[List[str]] = None\n    ) -> ModelInputForNeuron:\n        # NOTE: We assume that all sequences in the group are all prompts or\n        # all decodes.\n        is_prompt = seq_group_metadata_list[0].is_prompt\n        # Prepare input tensors.\n        if is_prompt:\n            (input_tokens, input_positions, input_block_ids, seq_lens,\n             multi_modal_kwargs\n             ) = self._prepare_prompt(seq_group_metadata_list)\n        else:\n            (input_tokens, input_positions,\n             input_block_ids) = self._prepare_decode(seq_group_metadata_list)\n            seq_lens = []\n        sampling_metadata = SamplingMetadata.prepare(\n            seq_group_metadata_list,\n            seq_lens,\n            # query_lens is not needed if chunked prefill is not\n            # supported. Since neuron worker doesn't support chunked prefill\n            # just use seq_lens instead.\n            seq_lens,\n            self.device,\n            self.pin_memory)\n\n        return ModelInputForNeuron(input_tokens=input_tokens,\n                                   input_positions=input_positions,\n                                   input_block_ids=input_block_ids,\n                                   sampling_metadata=sampling_metadata,\n                                   multi_modal_kwargs=multi_modal_kwargs)\n\n    @torch.inference_mode()\n    def execute_model(\n        self,\n        model_input: ModelInputForNeuron,\n        kv_caches: Optional[List[torch.Tensor]] = None,\n        intermediate_tensors: Optional[IntermediateTensors] = None,\n        num_steps: int = 1,\n    ) -> Optional[List[SamplerOutput]]:\n        if num_steps > 1:\n            raise ValueError(\n                \"NeuronModelRunner does not support multi-step execution.\")\n\n        hidden_states = self.model(\n            input_ids=model_input.input_tokens,\n            positions=model_input.input_positions,\n            input_block_ids=model_input.input_block_ids,\n            **(model_input.multi_modal_kwargs or {}),\n        )\n\n        # Compute the logits.\n        logits = self.model.compute_logits(hidden_states,\n                                           model_input.sampling_metadata)\n\n        # Sample the next token.\n        output = self.model.sample(\n            logits=logits,\n            sampling_metadata=model_input.sampling_metadata,\n        )\n        return [output]\n\n    @property\n    def vocab_size(self) -> int:\n        return self.model_config.get_vocab_size()\n",
      "diff": "diff --git a/vllm/worker/neuron_model_runner.py b/vllm/worker/neuron_model_runner.py\nindex 423f44085..651319ab1 100644\n--- a/vllm/worker/neuron_model_runner.py\n+++ b/vllm/worker/neuron_model_runner.py\n@@ -121,13 +121,13 @@ class NeuronModelRunner(ModelRunnerBase[ModelInputForNeuron]):\n         max_seq_len = max(seq_lens)\n         assert max_seq_len > 0\n         input_tokens = make_tensor_with_pad(input_tokens,\n-                                            max_seq_len,\n                                             pad=0,\n+                                            max_len=max_seq_len,\n                                             dtype=torch.long,\n                                             device=self.device)\n         input_positions = make_tensor_with_pad(input_positions,\n-                                               max_seq_len,\n                                                pad=0,\n+                                               max_len=max_seq_len,\n                                                dtype=torch.long,\n                                                device=self.device)\n         input_block_ids = torch.tensor(input_block_ids,\n@@ -171,13 +171,13 @@ class NeuronModelRunner(ModelRunnerBase[ModelInputForNeuron]):\n                 input_block_ids.append(block_table[0])\n \n         input_tokens = make_tensor_with_pad(input_tokens,\n-                                            max_len=1,\n                                             pad=0,\n+                                            max_len=1,\n                                             dtype=torch.long,\n                                             device=self.device)\n         input_positions = make_tensor_with_pad(input_positions,\n-                                               max_len=1,\n                                                pad=0,\n+                                               max_len=1,\n                                                dtype=torch.long,\n                                                device=self.device)\n         context_lens = torch.tensor(context_lens,",
      "change_type": "modified",
      "lines_added": 5,
      "lines_removed": 5
    },
    {
      "file_path": "vllm/worker/xpu_model_runner.py",
      "old_content": "from dataclasses import dataclass\nfrom typing import (TYPE_CHECKING, Any, Dict, List, Mapping, Optional, Tuple,\n                    Type, Union)\n\nimport torch\nimport torch.nn as nn\n\nfrom vllm.attention import get_attn_backend\nfrom vllm.config import (CacheConfig, DeviceConfig, LoadConfig, LoRAConfig,\n                         ModelConfig, MultiModalConfig, ParallelConfig,\n                         PromptAdapterConfig, SchedulerConfig)\nfrom vllm.distributed import broadcast_tensor_dict\nfrom vllm.inputs import INPUT_REGISTRY\nfrom vllm.logger import init_logger\nfrom vllm.model_executor.model_loader import get_model\nfrom vllm.model_executor.models.interfaces import supports_vision\nfrom vllm.multimodal import (MULTIMODAL_REGISTRY, BatchedTensors,\n                             MultiModalInputs)\nfrom vllm.sampling_params import SamplingParams\nfrom vllm.sequence import (IntermediateTensors, SamplerOutput,\n                           SequenceGroupMetadata)\nfrom vllm.utils import CudaMemoryProfiler, make_tensor_with_pad\nfrom vllm.worker.model_runner import AttentionMetadata, SamplingMetadata\nfrom vllm.worker.model_runner_base import (\n    ModelRunnerBase, ModelRunnerInputBase,\n    _add_attn_metadata_broadcastable_dict,\n    _add_sampling_metadata_broadcastable_dict,\n    _init_attn_metadata_from_tensor_dict,\n    _init_sampling_metadata_from_tensor_dict)\n\nif TYPE_CHECKING:\n    from vllm.attention.backends.abstract import AttentionBackend\n\nlogger = init_logger(__name__)\n\n_PAD_SLOT_ID = -1\n_BATCH_SIZE_ALIGNMENT = 8\n_BATCH_SIZES_TO_CAPTURE = [1, 2, 4] + [\n    _BATCH_SIZE_ALIGNMENT * i for i in range(1, 33)\n]\n\n\n@dataclass(frozen=True)\nclass ModelInputForXPU(ModelRunnerInputBase):\n    \"\"\"\n    Used by the NeuronModelRunner.\n    \"\"\"\n    input_tokens: Optional[torch.Tensor] = None\n    input_positions: Optional[torch.Tensor] = None\n    attn_metadata: Optional[\"AttentionMetadata\"] = None\n    sampling_metadata: Optional[\"SamplingMetadata\"] = None\n    multi_modal_kwargs: Optional[Mapping[str, BatchedTensors]] = None\n\n    def as_broadcastable_tensor_dict(\n            self) -> Dict[str, Union[int, torch.Tensor]]:\n        tensor_dict = {\n            \"input_tokens\": self.input_tokens,\n            \"input_positions\": self.input_positions,\n        }\n        _add_attn_metadata_broadcastable_dict(tensor_dict, self.attn_metadata)\n        _add_sampling_metadata_broadcastable_dict(tensor_dict,\n                                                  self.sampling_metadata)\n        return tensor_dict\n\n    @classmethod\n    def from_broadcasted_tensor_dict(\n        cls: Type[\"ModelInputForXPU\"],\n        tensor_dict: Dict[str, Any],\n        attn_backend: Optional[\"AttentionBackend\"] = None,\n    ) -> \"ModelInputForXPU\":\n        tensor_dict = _init_sampling_metadata_from_tensor_dict(tensor_dict)\n        if attn_backend is not None:\n            tensor_dict = _init_attn_metadata_from_tensor_dict(\n                attn_backend, tensor_dict)\n        return cls(**tensor_dict)\n\n\nclass XPUModelRunner(ModelRunnerBase[ModelInputForXPU]):\n\n    def __init__(\n        self,\n        model_config: ModelConfig,\n        parallel_config: ParallelConfig,\n        scheduler_config: SchedulerConfig,\n        device_config: DeviceConfig,\n        cache_config: CacheConfig,\n        load_config: LoadConfig,\n        lora_config: Optional[LoRAConfig],\n        multimodal_config: Optional[MultiModalConfig],\n        kv_cache_dtype: Optional[str] = \"auto\",\n        prompt_adapter_config: Optional[PromptAdapterConfig] = None,\n        is_driver_worker: bool = False,\n        *args,\n        **kwargs,\n    ):\n        self.model_config = model_config\n        self.parallel_config = parallel_config\n        self.scheduler_config = scheduler_config\n        self.lora_config = lora_config\n        self.load_config = load_config\n        self.cache_config = cache_config\n        self.prompt_adapter_config = prompt_adapter_config\n        self.multimodal_config = multimodal_config\n        self.is_driver_worker = is_driver_worker\n\n        self.sliding_window = model_config.get_sliding_window()\n        self.device_config = device_config\n        self.device = self.device_config.device\n\n        self.kv_cache_dtype = kv_cache_dtype\n        self.block_size = cache_config.block_size\n\n        self.attn_backend = get_attn_backend(\n            self.model_config.get_num_attention_heads(self.parallel_config),\n            self.model_config.get_head_size(),\n            self.model_config.get_num_kv_heads(self.parallel_config),\n            self.model_config.get_sliding_window(),\n            self.model_config.dtype,\n            self.kv_cache_dtype,\n            self.block_size,\n        )\n\n        # Multi-modal data support\n        self.multi_modal_input_mapper = MULTIMODAL_REGISTRY \\\n            .create_input_mapper(self.model_config)\n\n        # Lazy initialization.\n        self.model: nn.Module  # Set after init_Model\n\n    def load_model(self) -> None:\n        with CudaMemoryProfiler() as m:\n            self.model = get_model(\n                model_config=self.model_config,\n                device_config=self.device_config,\n                load_config=self.load_config,\n                lora_config=self.lora_config,\n                multimodal_config=self.multimodal_config,\n                parallel_config=self.parallel_config,\n                scheduler_config=self.scheduler_config,\n                cache_config=self.cache_config,\n            )\n\n        self.model_memory_usage = m.consumed_memory\n        logger.info(\"Loading model weights took %.4f GB\",\n                    self.model_memory_usage / float(2**30))\n\n    @property\n    def vocab_size(self) -> int:\n        return self.model_config.get_vocab_size()\n\n    @torch.inference_mode()\n    def profile_run(self) -> None:\n        # Enable top-k sampling to reflect the accurate memory usage.\n        sampling_params = SamplingParams(top_p=0.99, top_k=self.vocab_size - 1)\n        max_num_batched_tokens = self.scheduler_config.max_num_batched_tokens\n        max_num_seqs = self.scheduler_config.max_num_seqs\n\n        # Profile memory usage with max_num_sequences sequences and the total\n        # number of tokens equal to max_num_batched_tokens.\n        seqs: List[SequenceGroupMetadata] = []\n        # Additional GPU memory may be needed for vision encoding, which needs\n        # to be accounted for when calculating the GPU blocks for\n        # vLLM blocker manager.\n        # To exercise the worst scenario for GPU memory consumption,\n        # the number of seqs (batch_size) is chosen to maximize the number\n        # of images processed.\n        model_config = self.model_config\n\n        if supports_vision(self.model):\n            max_mm_tokens = MULTIMODAL_REGISTRY \\\n                .get_max_multimodal_tokens(model_config)\n            max_num_seqs_orig = max_num_seqs\n            max_num_seqs = min(max_num_seqs,\n                               max_num_batched_tokens // max_mm_tokens)\n            if max_num_seqs < 1:\n                expr = (f\"min({max_num_seqs_orig}, \"\n                        f\"{max_num_batched_tokens} // {max_mm_tokens})\")\n                logger.warning(\n                    \"Computed max_num_seqs (%s) to be less than 1. \"\n                    \"Setting it to the minimum value of 1.\", expr)\n                max_num_seqs = 1\n\n        for group_id in range(max_num_seqs):\n            seq_len = (max_num_batched_tokens // max_num_seqs +\n                       (group_id < max_num_batched_tokens % max_num_seqs))\n\n            seq_data, dummy_multi_modal_data = INPUT_REGISTRY \\\n                .dummy_data_for_profiling(model_config, seq_len)\n\n            # Having more tokens is over-conservative but otherwise fine\n            assert len(seq_data.prompt_token_ids) >= seq_len, (\n                f\"Expected at least {seq_len} dummy tokens for profiling, \"\n                f\"but got: {len(seq_data.prompt_token_ids)}\")\n\n            seq = SequenceGroupMetadata(\n                request_id=str(group_id),\n                is_prompt=True,\n                seq_data={group_id: seq_data},\n                sampling_params=sampling_params,\n                block_tables=None,\n                lora_request=None,\n                multi_modal_data=dummy_multi_modal_data,\n            )\n            seqs.append(seq)\n\n        # Run the model with the dummy inputs.\n        num_layers = self.model_config.get_num_layers(self.parallel_config)\n        kv_caches = [None] * num_layers\n        model_input = self.prepare_model_input(seqs)\n        self.execute_model(model_input, kv_caches)\n        torch.xpu.synchronize()\n        return\n\n    def make_model_input_from_broadcasted_tensor_dict(\n            self, tensor_dict: Dict[str, Any]) -> ModelInputForXPU:\n        return (ModelInputForXPU.from_broadcasted_tensor_dict(\n            tensor_dict,\n            attn_backend=self.attn_backend,\n        ))\n\n    def prepare_model_input(\n            self,\n            seq_group_metadata_list: List[SequenceGroupMetadata],\n            virtual_engine: int = 0,\n            finished_requests_ids: Optional[List[str]] = None\n    ) -> ModelInputForXPU:\n        multi_modal_kwargs = None\n        if self.is_driver_worker:\n            # NOTE: We assume that all sequences in the group are all prompts or\n            # all decodes.\n            is_prompt = seq_group_metadata_list[0].is_prompt\n            # Prepare input tensors.\n            if is_prompt:\n                (input_tokens, input_positions, attn_metadata, seq_lens,\n                 multi_modal_kwargs\n                 ) = self._prepare_prompt(seq_group_metadata_list)\n            else:\n                (input_tokens, input_positions,\n                 attn_metadata) = self._prepare_decode(seq_group_metadata_list)\n                seq_lens = []\n            sampling_metadata = SamplingMetadata.prepare(\n                seq_group_metadata_list,\n                seq_lens,\n                # subquery_lens is not needed if chunked prefill is not\n                # supported. Since CPU worker doesn't support chunked prefill\n                # just use seq_lens instead.\n                seq_lens,\n                self.device,\n                pin_memory=False)\n            # Broadcast the metadata.\n            metadata_dict = {\n                \"input_tokens\": input_tokens,\n                \"input_positions\": input_positions,\n                \"selected_token_indices\":\n                sampling_metadata.selected_token_indices,\n                \"multi_modal_kwargs\": multi_modal_kwargs,\n            }\n            metadata_dict.update(attn_metadata.asdict_zerocopy())\n            broadcast_tensor_dict(metadata_dict, src=0)\n        else:\n            metadata_dict = broadcast_tensor_dict(src=0)\n            input_tokens = metadata_dict.pop(\"input_tokens\")\n            input_positions = metadata_dict.pop(\"input_positions\")\n            selected_token_indices = metadata_dict.pop(\n                \"selected_token_indices\")\n            multi_modal_kwargs = metadata_dict.pop(\"multi_modal_kwargs\")\n            attn_metadata = self.attn_backend.make_metadata(**metadata_dict)\n            sampling_metadata = SamplingMetadata(\n                seq_groups=None,\n                selected_token_indices=selected_token_indices,\n                categorized_sample_indices=None,\n                num_prompts=0,\n            )\n\n        return ModelInputForXPU(input_tokens=input_tokens,\n                                input_positions=input_positions,\n                                attn_metadata=attn_metadata,\n                                sampling_metadata=sampling_metadata,\n                                multi_modal_kwargs=multi_modal_kwargs)\n\n    def _prepare_decode(\n        self,\n        seq_group_metadata_list: List[SequenceGroupMetadata],\n    ) -> Tuple[torch.Tensor, torch.Tensor, AttentionMetadata]:\n        assert len(seq_group_metadata_list) > 0\n        input_tokens: List[int] = []\n        input_positions: List[int] = []\n        slot_mapping: List[int] = []\n        seq_lens: List[int] = []\n        block_tables: List[List[int]] = []\n\n        for seq_group_metadata in seq_group_metadata_list:\n            assert not seq_group_metadata.is_prompt\n            assert seq_group_metadata.token_chunk_size == 1\n\n            seq_ids = list(seq_group_metadata.seq_data.keys())\n\n            for seq_id in seq_ids:\n                seq_data = seq_group_metadata.seq_data[seq_id]\n                generation_token = seq_data.get_last_token_id()\n                input_tokens.append(generation_token)\n\n                seq_len = seq_data.get_len()\n                position = seq_len - 1\n                input_positions.append(position)\n\n                seq_len = seq_len if self.sliding_window is None else min(\n                    seq_len, self.sliding_window)\n                seq_lens.append(seq_len)\n\n                block_table = seq_group_metadata.block_tables[seq_id]\n                block_number = block_table[position // self.block_size]\n                block_offset = position % self.block_size\n                slot = block_number * self.block_size + block_offset\n                slot_mapping.append(slot)\n\n                if self.sliding_window is not None:\n                    sliding_window_blocks = (self.sliding_window //\n                                             self.block_size)\n                    block_table = block_table[-sliding_window_blocks:]\n                block_tables.append(block_table)\n\n        max_decode_seq_len = max(seq_lens)\n\n        input_tokens = torch.tensor(input_tokens,\n                                    dtype=torch.long,\n                                    device=self.device)\n        input_positions = torch.tensor(input_positions,\n                                       dtype=torch.long,\n                                       device=self.device)\n        slot_mapping = torch.tensor(slot_mapping,\n                                    dtype=torch.long,\n                                    device=self.device)\n        seq_lens_tensor = torch.tensor(seq_lens,\n                                       dtype=torch.int,\n                                       device=self.device)\n\n        max_block_table_len = max(\n            len(block_table) for block_table in block_tables)\n        block_tables = make_tensor_with_pad(\n            block_tables,\n            max_len=max_block_table_len,\n            pad=0,\n            dtype=torch.int,\n            device=self.device,\n        )\n\n        attn_metadata = self.attn_backend.make_metadata(\n            is_prompt=False,\n            slot_mapping=slot_mapping,\n            seq_lens=seq_lens,\n            seqlen_q=None,\n            max_seqlen=None,\n            seq_lens_tensor=seq_lens_tensor,\n            max_decode_seq_len=max_decode_seq_len,\n            num_prefill_tokens=0,\n            num_decode_tokens=len(input_tokens),\n            num_prefills=0,\n            block_tables=block_tables,\n        )\n        return (\n            input_tokens,\n            input_positions,\n            attn_metadata,\n        )\n\n    @torch.inference_mode()\n    def execute_model(\n        self,\n        model_input: ModelInputForXPU,\n        kv_caches: List[torch.Tensor],\n        intermediate_tensors: Optional[IntermediateTensors] = None,\n        num_steps: int = 1,\n    ) -> Optional[List[SamplerOutput]]:\n        if num_steps > 1:\n            raise ValueError(\n                \"XPUModelRunner does not support multi-step execution.\")\n\n        model_executable = self.model\n        execute_model_kwargs = {\n            \"input_ids\": model_input.input_tokens,\n            \"positions\": model_input.input_positions,\n            \"kv_caches\": kv_caches,\n            \"attn_metadata\": model_input.attn_metadata,\n            **(model_input.multi_modal_kwargs or {}),\n        }\n\n        hidden_states = model_executable(**execute_model_kwargs)\n\n        # Compute the logits.\n        logits = self.model.compute_logits(hidden_states,\n                                           model_input.sampling_metadata)\n\n        # Only perform sampling in the driver worker.\n        if not self.is_driver_worker:\n            return []\n\n        # Sample the next token.\n        output = self.model.sample(\n            logits=logits,\n            sampling_metadata=model_input.sampling_metadata,\n        )\n        return [output]\n\n    def _prepare_prompt(\n        self,\n        seq_group_metadata_list: List[SequenceGroupMetadata],\n    ) -> Tuple[torch.Tensor, torch.Tensor, AttentionMetadata, List[int],\n               Mapping[str, BatchedTensors]]:\n        assert len(seq_group_metadata_list) > 0\n        input_tokens: List[int] = []\n        input_positions: List[int] = []\n        slot_mapping: List[int] = []\n        seq_lens: List[int] = []\n        multi_modal_inputs_list: List[MultiModalInputs] = []\n\n        for seq_group_metadata in seq_group_metadata_list:\n            assert seq_group_metadata.is_prompt\n            seq_ids = list(seq_group_metadata.seq_data.keys())\n            assert len(seq_ids) == 1\n            seq_id = seq_ids[0]\n\n            seq_data = seq_group_metadata.seq_data[seq_id]\n            prompt_tokens = seq_data.get_token_ids()\n            computed_len = seq_data.get_num_computed_tokens()\n            seq_len = len(prompt_tokens)\n\n            seq_lens.append(seq_len)  # Prompt token num\n            input_tokens.extend(prompt_tokens)  # Token ids\n\n            # Token position ids\n            # NOTE(woosuk): Here we assume that the first token in the prompt\n            # is always the first token in the sequence.\n            input_positions.extend(list(range(computed_len, seq_len)))\n\n            mm_data = seq_group_metadata.multi_modal_data\n            if mm_data:\n                mm_kwargs = self.multi_modal_input_mapper(mm_data)\n                multi_modal_inputs_list.append(mm_kwargs)\n\n            if seq_group_metadata.block_tables is None:\n                # During memory profiling, the block tables are not initialized\n                # yet. In this case, we just use a dummy slot mapping.\n                slot_mapping.extend([_PAD_SLOT_ID] * seq_len)\n                continue\n\n            # Compute the slot mapping.\n            block_table = seq_group_metadata.block_tables[seq_id]\n            # Mask the [0, start_idx) tokens of the prompt with _PAD_SLOT_ID,\n            # where start_idx is max(0, seq_len - sliding_window).\n            # For example, if the prompt len is 10, sliding window is 8, and\n            # block size is 4, the first two tokens are masked and the slot\n            # mapping will be [-1, -1, 2, 3, 4, 5, 6, 7, 0, 1].\n            start_idx = 0\n            if self.sliding_window is not None:\n                start_idx = max(0, seq_len - self.sliding_window)\n\n            for i in range(computed_len, seq_len):\n                if i < start_idx:\n                    slot_mapping.append(_PAD_SLOT_ID)\n                    continue\n\n                block_number = block_table[i //\n                                           self.block_size]  # type: ignore\n                block_offset = i % self.block_size  # type: ignore\n                slot = block_number * self.block_size + block_offset\n                slot_mapping.append(slot)\n\n        num_prompt_tokens = len(input_tokens)\n\n        input_tokens = torch.tensor(input_tokens,\n                                    dtype=torch.long,\n                                    device=self.device)  # type: ignore\n        input_positions = torch.tensor(input_positions,\n                                       dtype=torch.long,\n                                       device=self.device)  # type: ignore\n        slot_mapping = torch.tensor(slot_mapping,\n                                    dtype=torch.long,\n                                    device=self.device)  # type: ignore\n\n        max_seqlen = max(seq_lens)\n        tmp = [0]\n        tmp.extend(seq_lens)\n        seqlen = torch.tensor(tmp)\n        seqlen_q = torch.cumsum(seqlen, dim=0).to(device=self.device)\n\n        attn_metadata = self.attn_backend.make_metadata(\n            is_prompt=True,\n            slot_mapping=slot_mapping,\n            seq_lens=seq_lens,\n            seqlen_q=seqlen_q,\n            max_seqlen=max_seqlen,\n            seq_lens_tensor=None,\n            max_decode_seq_len=None,\n            num_prefills=len(seq_lens),\n            num_prefill_tokens=num_prompt_tokens,\n            num_decode_tokens=0,\n            block_tables=torch.tensor([], device=self.device, dtype=torch.int),\n        )\n\n        multi_modal_kwargs = MultiModalInputs.batch(multi_modal_inputs_list,\n                                                    device=self.device)\n\n        return (input_tokens, input_positions, attn_metadata, seq_lens,\n                multi_modal_kwargs)\n",
      "diff": "diff --git a/vllm/worker/xpu_model_runner.py b/vllm/worker/xpu_model_runner.py\nindex 876abb3bf..2f0ca4231 100644\n--- a/vllm/worker/xpu_model_runner.py\n+++ b/vllm/worker/xpu_model_runner.py\n@@ -335,11 +335,8 @@ class XPUModelRunner(ModelRunnerBase[ModelInputForXPU]):\n                                        dtype=torch.int,\n                                        device=self.device)\n \n-        max_block_table_len = max(\n-            len(block_table) for block_table in block_tables)\n         block_tables = make_tensor_with_pad(\n             block_tables,\n-            max_len=max_block_table_len,\n             pad=0,\n             dtype=torch.int,\n             device=self.device,",
      "change_type": "modified",
      "lines_added": 1,
      "lines_removed": 4
    }
  ],
  "affected_apis": [
    "vllm.utils.make_tensor_with_pad",
    "vllm.utils.make_ndarray_with_pad",
    "vllm.utils.TORCH_DTYPE_TO_NUMPY_DTYPE",
    "vllm.model_executor.sampling_metadata.SamplingTensors",
    "vllm.utils.STR_DTYPE_TO_TORCH_DTYPE"
  ],
  "summary": {
    "total_files": 9,
    "files_added": 0,
    "files_deleted": 0,
    "files_modified": 9
  },
  "csv_metadata": {
    "category": "miscellaneous",
    "json_has_tests": "TRUE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "",
    "is_benchmark_actually_there": "",
    "sample_clues": "conftest, cpu_model_runner, flash_attn"
  }
}