{
  "commit_hash": "8c1e77fb585c4f42783a3d88c1efc7c9e15fd89f",
  "parent_hash": "5fc5ce0fe45f974fc8840175e8321652238400f0",
  "message": "[Kernel] Update vllm-flash-attn version to reduce CPU overheads (#10742)\n\nSigned-off-by: Woosuk Kwon <woosuk.kwon@berkeley.edu>",
  "author": "Woosuk Kwon <woosuk.kwon@berkeley.edu>",
  "date": "2024-11-28 08:31:28 -0800",
  "files_changed": [
    {
      "file_path": "CMakeLists.txt",
      "old_content": "cmake_minimum_required(VERSION 3.26)\n\n# When building directly using CMake, make sure you run the install step\n# (it places the .so files in the correct location).\n#\n# Example:\n# mkdir build && cd build\n# cmake -G Ninja -DVLLM_PYTHON_EXECUTABLE=`which python3` -DCMAKE_INSTALL_PREFIX=.. ..\n# cmake --build . --target install\n#\n# If you want to only build one target, make sure to install it manually:\n# cmake --build . --target _C\n# cmake --install . --component _C\nproject(vllm_extensions LANGUAGES CXX)\n\n# CUDA by default, can be overridden by using -DVLLM_TARGET_DEVICE=... (used by setup.py)\nset(VLLM_TARGET_DEVICE \"cuda\" CACHE STRING \"Target device backend for vLLM\")\n\nmessage(STATUS \"Build type: ${CMAKE_BUILD_TYPE}\")\nmessage(STATUS \"Target device: ${VLLM_TARGET_DEVICE}\")\n\ninclude(${CMAKE_CURRENT_LIST_DIR}/cmake/utils.cmake)\n\n# Suppress potential warnings about unused manually-specified variables\nset(ignoreMe \"${VLLM_PYTHON_PATH}\")\n\n# Prevent installation of dependencies (cutlass) by default.\ninstall(CODE \"set(CMAKE_INSTALL_LOCAL_ONLY TRUE)\" ALL_COMPONENTS)\n\n#\n# Supported python versions.  These versions will be searched in order, the\n# first match will be selected.  These should be kept in sync with setup.py.\n#\nset(PYTHON_SUPPORTED_VERSIONS \"3.9\" \"3.10\" \"3.11\" \"3.12\")\n\n# Supported NVIDIA architectures.\nset(CUDA_SUPPORTED_ARCHS \"7.0;7.2;7.5;8.0;8.6;8.7;8.9;9.0\")\n\n# Supported AMD GPU architectures.\nset(HIP_SUPPORTED_ARCHS \"gfx906;gfx908;gfx90a;gfx940;gfx941;gfx942;gfx1030;gfx1100;gfx1101\")\n\n#\n# Supported/expected torch versions for CUDA/ROCm.\n#\n# Currently, having an incorrect pytorch version results in a warning\n# rather than an error.\n#\n# Note: the CUDA torch version is derived from pyproject.toml and various\n# requirements.txt files and should be kept consistent.  The ROCm torch\n# versions are derived from Dockerfile.rocm\n#\nset(TORCH_SUPPORTED_VERSION_CUDA \"2.5.1\")\nset(TORCH_SUPPORTED_VERSION_ROCM \"2.5.1\")\n\n#\n# Try to find python package with an executable that exactly matches\n# `VLLM_PYTHON_EXECUTABLE` and is one of the supported versions.\n#\nif (VLLM_PYTHON_EXECUTABLE)\n  find_python_from_executable(${VLLM_PYTHON_EXECUTABLE} \"${PYTHON_SUPPORTED_VERSIONS}\")\nelse()\n  message(FATAL_ERROR\n    \"Please set VLLM_PYTHON_EXECUTABLE to the path of the desired python version\"\n    \" before running cmake configure.\")\nendif()\n\n#\n# Update cmake's `CMAKE_PREFIX_PATH` with torch location.\n#\nappend_cmake_prefix_path(\"torch\" \"torch.utils.cmake_prefix_path\")\n\n# Ensure the 'nvcc' command is in the PATH\nfind_program(NVCC_EXECUTABLE nvcc)\nif (CUDA_FOUND AND NOT NVCC_EXECUTABLE)\n    message(FATAL_ERROR \"nvcc not found\")\nendif()\n\n#\n# Import torch cmake configuration.\n# Torch also imports CUDA (and partially HIP) languages with some customizations,\n# so there is no need to do this explicitly with check_language/enable_language,\n# etc.\n#\nfind_package(Torch REQUIRED)\n\n#\n# Forward the non-CUDA device extensions to external CMake scripts.\n#\nif (NOT VLLM_TARGET_DEVICE STREQUAL \"cuda\" AND\n    NOT VLLM_TARGET_DEVICE STREQUAL \"rocm\")\n    if (VLLM_TARGET_DEVICE STREQUAL \"cpu\")\n        include(${CMAKE_CURRENT_LIST_DIR}/cmake/cpu_extension.cmake)\n    else()\n        return()\n    endif()\n    return()\nendif()\n\n#\n# Set up GPU language and check the torch version and warn if it isn't\n# what is expected.\n#\nif (NOT HIP_FOUND AND CUDA_FOUND)\n  set(VLLM_GPU_LANG \"CUDA\")\n\n  if (NOT Torch_VERSION VERSION_EQUAL ${TORCH_SUPPORTED_VERSION_CUDA})\n    message(WARNING \"Pytorch version ${TORCH_SUPPORTED_VERSION_CUDA} \"\n      \"expected for CUDA build, saw ${Torch_VERSION} instead.\")\n  endif()\nelseif(HIP_FOUND)\n  set(VLLM_GPU_LANG \"HIP\")\n\n  # Importing torch recognizes and sets up some HIP/ROCm configuration but does\n  # not let cmake recognize .hip files. In order to get cmake to understand the\n  # .hip extension automatically, HIP must be enabled explicitly.\n  enable_language(HIP)\n\n  # ROCm 5.X and 6.X\n  if (ROCM_VERSION_DEV_MAJOR GREATER_EQUAL 5 AND\n      NOT Torch_VERSION VERSION_EQUAL ${TORCH_SUPPORTED_VERSION_ROCM})\n    message(WARNING \"Pytorch version >= ${TORCH_SUPPORTED_VERSION_ROCM} \"\n      \"expected for ROCm build, saw ${Torch_VERSION} instead.\")\n  endif()\nelse()\n  message(FATAL_ERROR \"Can't find CUDA or HIP installation.\")\nendif()\n\n\nif(VLLM_GPU_LANG STREQUAL \"CUDA\")\n  #\n  # For cuda we want to be able to control which architectures we compile for on\n  # a per-file basis in order to cut down on compile time. So here we extract\n  # the set of architectures we want to compile for and remove the from the\n  # CMAKE_CUDA_FLAGS so that they are not applied globally.\n  #\n  clear_cuda_arches(CUDA_ARCH_FLAGS)\n  extract_unique_cuda_archs_ascending(CUDA_ARCHS \"${CUDA_ARCH_FLAGS}\")\n  message(STATUS \"CUDA target architectures: ${CUDA_ARCHS}\")\n  # Filter the target architectures by the supported supported archs\n  # since for some files we will build for all CUDA_ARCHS.\n  cuda_archs_loose_intersection(CUDA_ARCHS\n    \"${CUDA_SUPPORTED_ARCHS}\" \"${CUDA_ARCHS}\")\n  message(STATUS \"CUDA supported target architectures: ${CUDA_ARCHS}\")\nelse()\n  #\n  # For other GPU targets override the GPU architectures detected by cmake/torch\n  # and filter them by the supported versions for the current language.\n  # The final set of arches is stored in `VLLM_GPU_ARCHES`.\n  #\n  override_gpu_arches(VLLM_GPU_ARCHES\n    ${VLLM_GPU_LANG}\n    \"${${VLLM_GPU_LANG}_SUPPORTED_ARCHS}\")\nendif()\n\n#\n# Query torch for additional GPU compilation flags for the given\n# `VLLM_GPU_LANG`.\n# The final set of arches is stored in `VLLM_GPU_FLAGS`.\n#\nget_torch_gpu_compiler_flags(VLLM_GPU_FLAGS ${VLLM_GPU_LANG})\n\n#\n# Set nvcc parallelism.\n#\nif(NVCC_THREADS AND VLLM_GPU_LANG STREQUAL \"CUDA\")\n  list(APPEND VLLM_GPU_FLAGS \"--threads=${NVCC_THREADS}\")\nendif()\n\n\n#\n# Use FetchContent for C++ dependencies that are compiled as part of vLLM's build process.\n# setup.py will override FETCHCONTENT_BASE_DIR to play nicely with sccache.\n# Each dependency that produces build artifacts should override its BINARY_DIR to avoid\n# conflicts between build types. It should instead be set to ${CMAKE_BINARY_DIR}/<dependency>.\n#\ninclude(FetchContent)\nfile(MAKE_DIRECTORY ${FETCHCONTENT_BASE_DIR}) # Ensure the directory exists\nmessage(STATUS \"FetchContent base directory: ${FETCHCONTENT_BASE_DIR}\")\n\n#\n# Define other extension targets\n#\n\n#\n# _C extension\n#\n\nset(VLLM_EXT_SRC\n  \"csrc/cache_kernels.cu\"\n  \"csrc/attention/paged_attention_v1.cu\"\n  \"csrc/attention/paged_attention_v2.cu\"\n  \"csrc/pos_encoding_kernels.cu\"\n  \"csrc/activation_kernels.cu\"\n  \"csrc/layernorm_kernels.cu\"\n  \"csrc/layernorm_quant_kernels.cu\"\n  \"csrc/quantization/gptq/q_gemm.cu\"\n  \"csrc/quantization/compressed_tensors/int8_quant_kernels.cu\"\n  \"csrc/quantization/fp8/common.cu\"\n  \"csrc/quantization/gguf/gguf_kernel.cu\"\n  \"csrc/cuda_utils_kernels.cu\"\n  \"csrc/prepare_inputs/advance_step.cu\"\n  \"csrc/torch_bindings.cpp\")\n\nif(VLLM_GPU_LANG STREQUAL \"CUDA\")\n  SET(CUTLASS_ENABLE_HEADERS_ONLY ON CACHE BOOL \"Enable only the header library\")\n\n  # Set CUTLASS_REVISION manually -- its revision detection doesn't work in this case.\n  set(CUTLASS_REVISION \"v3.5.1\" CACHE STRING \"CUTLASS revision to use\")\n\n  # Use the specified CUTLASS source directory for compilation if VLLM_CUTLASS_SRC_DIR is provided\n  if (DEFINED ENV{VLLM_CUTLASS_SRC_DIR})\n    set(VLLM_CUTLASS_SRC_DIR $ENV{VLLM_CUTLASS_SRC_DIR})\n  endif()\n\n  if(VLLM_CUTLASS_SRC_DIR)\n    if(NOT IS_ABSOLUTE VLLM_CUTLASS_SRC_DIR)\n      get_filename_component(VLLM_CUTLASS_SRC_DIR \"${VLLM_CUTLASS_SRC_DIR}\" ABSOLUTE)\n    endif()\n    message(STATUS \"The VLLM_CUTLASS_SRC_DIR is set, using ${VLLM_CUTLASS_SRC_DIR} for compilation\")\n    FetchContent_Declare(cutlass SOURCE_DIR ${VLLM_CUTLASS_SRC_DIR})\n  else()\n    FetchContent_Declare(\n        cutlass\n        GIT_REPOSITORY https://github.com/nvidia/cutlass.git\n        GIT_TAG v3.5.1\n        GIT_PROGRESS TRUE\n\n        # Speed up CUTLASS download by retrieving only the specified GIT_TAG instead of the history.\n        # Important: If GIT_SHALLOW is enabled then GIT_TAG works only with branch names and tags.\n        # So if the GIT_TAG above is updated to a commit hash, GIT_SHALLOW must be set to FALSE\n        GIT_SHALLOW TRUE\n    )\n  endif()\n  FetchContent_MakeAvailable(cutlass)\n\n  list(APPEND VLLM_EXT_SRC\n    \"csrc/mamba/mamba_ssm/selective_scan_fwd.cu\"\n    \"csrc/mamba/causal_conv1d/causal_conv1d.cu\"\n    \"csrc/quantization/aqlm/gemm_kernels.cu\"\n    \"csrc/quantization/awq/gemm_kernels.cu\"\n    \"csrc/custom_all_reduce.cu\"\n    \"csrc/permute_cols.cu\"\n    \"csrc/quantization/cutlass_w8a8/scaled_mm_entry.cu\")\n\n  set_gencode_flags_for_srcs(\n    SRCS \"${VLLM_EXT_SRC}\"\n    CUDA_ARCHS \"${CUDA_ARCHS}\")\n\n  # Only build Marlin kernels if we are building for at least some compatible archs.\n  # Keep building Marlin for 9.0 as there are some group sizes and shapes that\n  # are not supported by Machete yet.\n  cuda_archs_loose_intersection(MARLIN_ARCHS \"8.0;8.6;8.7;8.9;9.0\" ${CUDA_ARCHS})\n  if (MARLIN_ARCHS)\n    set(MARLIN_SRCS\n       \"csrc/quantization/fp8/fp8_marlin.cu\"\n       \"csrc/quantization/marlin/dense/marlin_cuda_kernel.cu\"\n       \"csrc/quantization/marlin/sparse/marlin_24_cuda_kernel.cu\"\n       \"csrc/quantization/marlin/qqq/marlin_qqq_gemm_kernel.cu\"\n       \"csrc/quantization/gptq_marlin/gptq_marlin.cu\"\n       \"csrc/quantization/gptq_marlin/gptq_marlin_repack.cu\"\n       \"csrc/quantization/gptq_marlin/awq_marlin_repack.cu\")\n    set_gencode_flags_for_srcs(\n      SRCS \"${MARLIN_SRCS}\"\n      CUDA_ARCHS \"${MARLIN_ARCHS}\")\n    list(APPEND VLLM_EXT_SRC \"${MARLIN_SRCS}\")\n    message(STATUS \"Building Marlin kernels for archs: ${MARLIN_ARCHS}\")\n  else()\n    message(STATUS \"Not building Marlin kernels as no compatible archs found\"\n                   \" in CUDA target architectures\")\n  endif()\n\n  #\n  # The cutlass_scaled_mm kernels for Hopper (c3x, i.e. CUTLASS 3.x) require\n  # CUDA 12.0 or later (and only work on Hopper, 9.0/9.0a for now).\n  cuda_archs_loose_intersection(SCALED_MM_3X_ARCHS \"9.0;9.0a\" \"${CUDA_ARCHS}\")\n  if(${CMAKE_CUDA_COMPILER_VERSION} VERSION_GREATER 12.0 AND SCALED_MM_3X_ARCHS)\n    set(SRCS \"csrc/quantization/cutlass_w8a8/scaled_mm_c3x.cu\")\n    set_gencode_flags_for_srcs(\n      SRCS \"${SRCS}\"\n      CUDA_ARCHS \"${SCALED_MM_3X_ARCHS}\")\n    list(APPEND VLLM_EXT_SRC \"${SRCS}\")\n    list(APPEND VLLM_GPU_FLAGS \"-DENABLE_SCALED_MM_C3X=1\")\n    message(STATUS \"Building scaled_mm_c3x for archs: ${SCALED_MM_3X_ARCHS}\")\n  else()\n    if (NOT ${CMAKE_CUDA_COMPILER_VERSION} VERSION_GREATER 12.0 AND SCALED_MM_3X_ARCHS)\n      message(STATUS \"Not building scaled_mm_c3x as CUDA Compiler version is \"\n                     \"not >= 12.0, we recommend upgrading to CUDA 12.0 or \"\n                     \"later if you intend on running FP8 quantized models on \"\n                     \"Hopper.\")\n    else()\n      message(STATUS \"Not building scaled_mm_c3x as no compatible archs found \"\n                     \"in CUDA target architectures\")\n    endif()\n\n    # clear SCALED_MM_3X_ARCHS so the scaled_mm_c2x kernels know we didn't\n    # build any 3x kernels\n    set(SCALED_MM_3X_ARCHS)\n  endif()\n\n  #\n  # For the cutlass_scaled_mm kernels we want to build the c2x (CUTLASS 2.x)\n  # kernels for the remaining archs that are not already built for 3x.\n  cuda_archs_loose_intersection(SCALED_MM_2X_ARCHS \n    \"7.5;8.0;8.6;8.7;8.9;9.0\" \"${CUDA_ARCHS}\")\n  # subtract out the archs that are already built for 3x\n  list(REMOVE_ITEM SCALED_MM_2X_ARCHS ${SCALED_MM_3X_ARCHS})\n  if (SCALED_MM_2X_ARCHS)\n    set(SRCS \"csrc/quantization/cutlass_w8a8/scaled_mm_c2x.cu\")\n    set_gencode_flags_for_srcs(\n      SRCS \"${SRCS}\"\n      CUDA_ARCHS \"${SCALED_MM_2X_ARCHS}\")\n    list(APPEND VLLM_EXT_SRC \"${SRCS}\")\n    list(APPEND VLLM_GPU_FLAGS \"-DENABLE_SCALED_MM_C2X=1\")\n    message(STATUS \"Building scaled_mm_c2x for archs: ${SCALED_MM_2X_ARCHS}\")\n  else()\n    if (SCALED_MM_3X_ARCHS)\n      message(STATUS \"Not building scaled_mm_c2x as all archs are already built\"\n                     \" for and covered by scaled_mm_c3x\")\n    else()\n      message(STATUS \"Not building scaled_mm_c2x as no compatible archs found \"\n                    \"in CUDA target architectures\")\n    endif()\n  endif()\n\n\n  #\n  # Machete kernels\n\n  # The machete kernels only work on hopper and require CUDA 12.0 or later.\n  # Only build Machete kernels if we are building for something compatible with sm90a\n  cuda_archs_loose_intersection(MACHETE_ARCHS \"9.0a\" \"${CUDA_ARCHS}\")\n  if(${CMAKE_CUDA_COMPILER_VERSION} VERSION_GREATER 12.0 AND MACHETE_ARCHS)\n    #\n    # For the Machete kernels we automatically generate sources for various\n    # preselected input type pairs and schedules.\n    # Generate sources:\n    set(MACHETE_GEN_SCRIPT\n      ${CMAKE_CURRENT_SOURCE_DIR}/csrc/quantization/machete/generate.py)\n    file(MD5 ${MACHETE_GEN_SCRIPT} MACHETE_GEN_SCRIPT_HASH)\n\n    message(STATUS \"Machete generation script hash: ${MACHETE_GEN_SCRIPT_HASH}\")\n    message(STATUS \"Last run machete generate script hash: $CACHE{MACHETE_GEN_SCRIPT_HASH}\")\n\n    if (NOT DEFINED CACHE{MACHETE_GEN_SCRIPT_HASH}\n        OR NOT $CACHE{MACHETE_GEN_SCRIPT_HASH} STREQUAL ${MACHETE_GEN_SCRIPT_HASH})\n      execute_process(\n        COMMAND ${CMAKE_COMMAND} -E env\n        PYTHONPATH=${CMAKE_CURRENT_SOURCE_DIR}/csrc/cutlass_extensions/:${CUTLASS_DIR}/python/:${VLLM_PYTHON_PATH}:$PYTHONPATH\n          ${Python_EXECUTABLE} ${MACHETE_GEN_SCRIPT}\n        RESULT_VARIABLE machete_generation_result\n        OUTPUT_VARIABLE machete_generation_output\n        OUTPUT_FILE ${CMAKE_CURRENT_BINARY_DIR}/machete_generation.log\n        ERROR_FILE ${CMAKE_CURRENT_BINARY_DIR}/machete_generation.log\n      )\n\n      if (NOT machete_generation_result EQUAL 0)\n        message(FATAL_ERROR \"Machete generation failed.\"\n                            \" Result: \\\"${machete_generation_result}\\\"\"\n                            \"\\nCheck the log for details: \"\n                            \"${CMAKE_CURRENT_BINARY_DIR}/machete_generation.log\")\n      else()\n        set(MACHETE_GEN_SCRIPT_HASH ${MACHETE_GEN_SCRIPT_HASH}\n            CACHE STRING \"Last run machete generate script hash\" FORCE)\n        message(STATUS \"Machete generation completed successfully.\")\n      endif()\n    else()\n      message(STATUS \"Machete generation script has not changed, skipping generation.\")\n    endif()\n\n    # Add machete generated sources\n    file(GLOB MACHETE_GEN_SOURCES \"csrc/quantization/machete/generated/*.cu\")\n    list(APPEND VLLM_EXT_SRC ${MACHETE_GEN_SOURCES})\n\n    # forward compatible\n    set_gencode_flags_for_srcs(\n      SRCS \"${MACHETE_GEN_SOURCES}\"\n      CUDA_ARCHS \"${MACHETE_ARCHS}\")\n\n    list(APPEND VLLM_EXT_SRC\n      csrc/quantization/machete/machete_pytorch.cu)\n\n    message(STATUS \"Building Machete kernels for archs: ${MACHETE_ARCHS}\")\n  else()\n    if (NOT ${CMAKE_CUDA_COMPILER_VERSION} VERSION_GREATER 12.0\n        AND MACHETE_ARCHS)\n      message(STATUS \"Not building Machete kernels as CUDA Compiler version is \"\n                     \"not >= 12.0, we recommend upgrading to CUDA 12.0 or \"\n                     \"later if you intend on running w4a16 quantized models on \"\n                     \"Hopper.\")\n    else()\n      message(STATUS \"Not building Machete kernels as no compatible archs \"\n                     \"found in CUDA target architectures\")\n    endif()\n  endif()\n# if CUDA endif\nendif()\n\nmessage(STATUS \"Enabling C extension.\")\ndefine_gpu_extension_target(\n  _C\n  DESTINATION vllm\n  LANGUAGE ${VLLM_GPU_LANG}\n  SOURCES ${VLLM_EXT_SRC}\n  COMPILE_FLAGS ${VLLM_GPU_FLAGS}\n  ARCHITECTURES ${VLLM_GPU_ARCHES}\n  INCLUDE_DIRECTORIES ${CUTLASS_INCLUDE_DIR}\n  USE_SABI 3\n  WITH_SOABI)\n\n# If CUTLASS is compiled on NVCC >= 12.5, it by default uses\n# cudaGetDriverEntryPointByVersion as a wrapper to avoid directly calling the\n# driver API. This causes problems when linking with earlier versions of CUDA.\n# Setting this variable sidesteps the issue by calling the driver directly.\ntarget_compile_definitions(_C PRIVATE CUTLASS_ENABLE_DIRECT_CUDA_DRIVER_CALL=1)\n\n#\n# _moe_C extension\n#\n\nset(VLLM_MOE_EXT_SRC\n  \"csrc/moe/torch_bindings.cpp\"\n  \"csrc/moe/moe_align_sum_kernels.cu\"\n  \"csrc/moe/topk_softmax_kernels.cu\")\n\nset_gencode_flags_for_srcs(\n  SRCS \"${VLLM_MOE_EXT_SRC}\"\n  CUDA_ARCHS \"${CUDA_ARCHS}\")\n\nif(VLLM_GPU_LANG STREQUAL \"CUDA\")\n  cuda_archs_loose_intersection(MARLIN_MOE_ARCHS \"8.0;8.6;8.7;8.9;9.0\" \"${CUDA_ARCHS}\")\n  if (MARLIN_MOE_ARCHS)\n    set(MARLIN_MOE_SRC\n        \"csrc/moe/marlin_kernels/marlin_moe_kernel.h\"\n        \"csrc/moe/marlin_kernels/marlin_moe_kernel_ku4b8.h\"\n        \"csrc/moe/marlin_kernels/marlin_moe_kernel_ku4b8.cu\"\n        \"csrc/moe/marlin_kernels/marlin_moe_kernel_ku8b128.h\"\n        \"csrc/moe/marlin_kernels/marlin_moe_kernel_ku8b128.cu\"\n        \"csrc/moe/marlin_kernels/marlin_moe_kernel_ku4.h\"\n        \"csrc/moe/marlin_kernels/marlin_moe_kernel_ku4.cu\"\n        \"csrc/moe/marlin_moe_ops.cu\")\n\n    set_gencode_flags_for_srcs(\n      SRCS \"${MARLIN_MOE_SRC}\"\n      CUDA_ARCHS \"${MARLIN_MOE_ARCHS}\")\n\n    list(APPEND VLLM_MOE_EXT_SRC \"${MARLIN_MOE_SRC}\")\n    message(STATUS \"Building Marlin MOE kernels for archs: ${MARLIN_MOE_ARCHS}\")\n  else()\n    message(STATUS \"Not building Marlin MOE kernels as no compatible archs found\"\n                   \" in CUDA target architectures\")\n  endif()\nendif()\n\nmessage(STATUS \"Enabling moe extension.\")\ndefine_gpu_extension_target(\n  _moe_C\n  DESTINATION vllm\n  LANGUAGE ${VLLM_GPU_LANG}\n  SOURCES ${VLLM_MOE_EXT_SRC}\n  COMPILE_FLAGS ${VLLM_GPU_FLAGS}\n  ARCHITECTURES ${VLLM_GPU_ARCHES}\n  USE_SABI 3\n  WITH_SOABI)\n\nif(VLLM_GPU_LANG STREQUAL \"HIP\")\n  #\n  # _rocm_C extension\n  #\n  set(VLLM_ROCM_EXT_SRC\n    \"csrc/rocm/torch_bindings.cpp\"\n    \"csrc/rocm/attention.cu\")\n\n  define_gpu_extension_target(\n    _rocm_C\n    DESTINATION vllm\n    LANGUAGE ${VLLM_GPU_LANG}\n    SOURCES ${VLLM_ROCM_EXT_SRC}\n    COMPILE_FLAGS ${VLLM_GPU_FLAGS}\n    ARCHITECTURES ${VLLM_GPU_ARCHES}\n    USE_SABI 3\n    WITH_SOABI)\nendif()\n\n# vllm-flash-attn currently only supported on CUDA\nif (NOT VLLM_TARGET_DEVICE STREQUAL \"cuda\")\n  return()\nendif ()\n\n# vLLM flash attention requires VLLM_GPU_ARCHES to contain the set of target\n# arches in the CMake syntax (75-real, 89-virtual, etc), since we clear the\n# arches in the CUDA case (and instead set the gencodes on a per file basis)\n# we need to manually set VLLM_GPU_ARCHES here.\nif(VLLM_GPU_LANG STREQUAL \"CUDA\")\n  foreach(_ARCH ${CUDA_ARCHS})\n    string(REPLACE \".\" \"\" _ARCH \"${_ARCH}\")\n    list(APPEND VLLM_GPU_ARCHES \"${_ARCH}-real\")\n  endforeach()\nendif()\n\n#\n# Build vLLM flash attention from source\n#\n# IMPORTANT: This has to be the last thing we do, because vllm-flash-attn uses the same macros/functions as vLLM.\n# Because functions all belong to the global scope, vllm-flash-attn's functions overwrite vLLMs.\n# They should be identical but if they aren't, this is a massive footgun.\n#\n# The vllm-flash-attn install rules are nested under vllm to make sure the library gets installed in the correct place.\n# To only install vllm-flash-attn, use --component vllm_flash_attn_c.\n# If no component is specified, vllm-flash-attn is still installed.\n\n# If VLLM_FLASH_ATTN_SRC_DIR is set, vllm-flash-attn is installed from that directory instead of downloading.\n# This is to enable local development of vllm-flash-attn within vLLM.\n# It can be set as an environment variable or passed as a cmake argument.\n# The environment variable takes precedence.\nif (DEFINED ENV{VLLM_FLASH_ATTN_SRC_DIR})\n  set(VLLM_FLASH_ATTN_SRC_DIR $ENV{VLLM_FLASH_ATTN_SRC_DIR})\nendif()\n\nif(VLLM_FLASH_ATTN_SRC_DIR)\n  FetchContent_Declare(vllm-flash-attn SOURCE_DIR ${VLLM_FLASH_ATTN_SRC_DIR})\nelse()\n  FetchContent_Declare(\n          vllm-flash-attn\n          GIT_REPOSITORY https://github.com/vllm-project/flash-attention.git\n          GIT_TAG d886f88165702b3c7e7744502772cd98b06be9e1\n          GIT_PROGRESS TRUE\n          # Don't share the vllm-flash-attn build between build types\n          BINARY_DIR ${CMAKE_BINARY_DIR}/vllm-flash-attn\n  )\nendif()\n\n# Set the parent build flag so that the vllm-flash-attn library does not redo compile flag and arch initialization.\nset(VLLM_PARENT_BUILD ON)\n\n# Ensure the vllm/vllm_flash_attn directory exists before installation\ninstall(CODE \"file(MAKE_DIRECTORY \\\"\\${CMAKE_INSTALL_PREFIX}/vllm/vllm_flash_attn\\\")\" COMPONENT vllm_flash_attn_c)\n\n# Make sure vllm-flash-attn install rules are nested under vllm/\ninstall(CODE \"set(CMAKE_INSTALL_LOCAL_ONLY FALSE)\" COMPONENT vllm_flash_attn_c)\ninstall(CODE \"set(OLD_CMAKE_INSTALL_PREFIX \\\"\\${CMAKE_INSTALL_PREFIX}\\\")\" COMPONENT vllm_flash_attn_c)\ninstall(CODE \"set(CMAKE_INSTALL_PREFIX \\\"\\${CMAKE_INSTALL_PREFIX}/vllm/\\\")\" COMPONENT vllm_flash_attn_c)\n\n# Fetch the vllm-flash-attn library\nFetchContent_MakeAvailable(vllm-flash-attn)\nmessage(STATUS \"vllm-flash-attn is available at ${vllm-flash-attn_SOURCE_DIR}\")\n\n# Restore the install prefix\ninstall(CODE \"set(CMAKE_INSTALL_PREFIX \\\"\\${OLD_CMAKE_INSTALL_PREFIX}\\\")\" COMPONENT vllm_flash_attn_c)\ninstall(CODE \"set(CMAKE_INSTALL_LOCAL_ONLY TRUE)\" COMPONENT vllm_flash_attn_c)\n\n# Copy over the vllm-flash-attn python files\ninstall(\n        DIRECTORY ${vllm-flash-attn_SOURCE_DIR}/vllm_flash_attn/\n        DESTINATION vllm/vllm_flash_attn\n        COMPONENT vllm_flash_attn_c\n        FILES_MATCHING PATTERN \"*.py\"\n)\n\n# Nothing after vllm-flash-attn, see comment about macros above\n",
      "diff": "diff --git a/CMakeLists.txt b/CMakeLists.txt\nindex 45a3b484e..f43bf8143 100644\n--- a/CMakeLists.txt\n+++ b/CMakeLists.txt\n@@ -522,7 +522,7 @@ else()\n   FetchContent_Declare(\n           vllm-flash-attn\n           GIT_REPOSITORY https://github.com/vllm-project/flash-attention.git\n-          GIT_TAG d886f88165702b3c7e7744502772cd98b06be9e1\n+          GIT_TAG fdf6d72b48aea41f4ae6a89139a453dae554abc8\n           GIT_PROGRESS TRUE\n           # Don't share the vllm-flash-attn build between build types\n           BINARY_DIR ${CMAKE_BINARY_DIR}/vllm-flash-attn",
      "change_type": "modified",
      "lines_added": 2,
      "lines_removed": 2
    }
  ],
  "affected_apis": [
    "vllm.LLM.generate",
    "vllm.Engine.generate",
    "vllm.Model.generate"
  ],
  "summary": {
    "total_files": 1,
    "files_added": 0,
    "files_deleted": 0,
    "files_modified": 1
  },
  "csv_metadata": {
    "category": "kernel-based",
    "json_has_tests": "FALSE",
    "json_has_benchmarks": "FALSE",
    "is_test_actually_there": "NO (cpu)",
    "is_benchmark_actually_there": "",
    "sample_clues": "cmakelists, none"
  }
}