{
  "commit_hash": "c45f3c3ab60f4bf4eaab791a76028b8b07ffe9bd",
  "parent_hash": "7a7929abe8e2fd6a4688487c471a1ee1fde0edd2",
  "message": "Optimize tensor parallel execution speed (#17)",
  "author": "Zhuohan Li <zhuohan123@gmail.com>",
  "date": "2023-04-01 00:51:08 +0800",
  "files_changed": [
    {
      "file_path": "benchmark/benchmark_latency.py",
      "old_content": "",
      "diff": "diff --git a/benchmark/benchmark_latency.py b/benchmark/benchmark_latency.py\nnew file mode 100644\nindex 000000000..a18ef98f4\n--- /dev/null\n+++ b/benchmark/benchmark_latency.py\n@@ -0,0 +1,99 @@\n+import argparse\n+import time\n+from typing import List\n+\n+from tqdm import tqdm\n+import numpy as np\n+import torch\n+\n+from cacheflow.master.simple_frontend import SimpleFrontend\n+from cacheflow.master.server import (Server, add_server_arguments,\n+                                     initialize_ray_cluster)\n+from cacheflow.sampling_params import SamplingParams\n+from cacheflow.utils import get_gpu_memory, get_cpu_memory\n+\n+\n+def main(args: argparse.Namespace):\n+    # TODO(zhuohan): Support pipeline parallelism.\n+    assert args.pipeline_parallel_size == 1, (\n+        'Pipeline parallelism is not supported yet.')\n+\n+    (num_nodes, num_devices_per_node, distributed_init_method,\n+    all_stage_devices) = (\n+        initialize_ray_cluster(\n+            address='local',\n+            pipeline_parallel_size=args.pipeline_parallel_size,\n+            tensor_parallel_size=args.tensor_parallel_size))\n+\n+    # Create a server.\n+    server = Server(\n+        model=args.model,\n+        model_path=args.model_path,\n+        pipeline_parallel_size=args.pipeline_parallel_size,\n+        tensor_parallel_size=args.tensor_parallel_size,\n+        block_size=args.block_size,\n+        dtype=args.dtype,\n+        seed=args.seed,\n+        swap_space=args.swap_space,\n+        max_batch_size=args.max_batch_size,\n+        num_nodes=num_nodes,\n+        num_devices_per_node=num_devices_per_node,\n+        distributed_init_method=distributed_init_method,\n+        all_stage_devices=all_stage_devices,\n+        gpu_memory=get_gpu_memory(),\n+        cpu_memory=get_cpu_memory(),\n+    )\n+\n+    # Create a frontend.\n+    frontend = SimpleFrontend(\n+        model_name=args.model,\n+        block_size=args.block_size,\n+    )\n+    sampling_params_dict = {\n+        'n': 1,\n+        'temperature': 0.0,\n+        'top_p': 1.0,\n+        'use_beam_search': False,\n+        'stop_token_ids': set(),\n+        'max_num_steps': args.output_len,\n+    }\n+    sampling_params = SamplingParams.from_dict(sampling_params_dict)\n+    input_token_ids = [0] * args.input_len\n+\n+    def profile_step(profile=False):\n+        if profile:\n+            torch.cuda.cudart().cudaProfilerStart()\n+        for _ in range(args.batch_size):\n+            frontend._add_query(input_token_ids, sampling_params)\n+        server.add_sequence_groups(frontend.get_inputs())\n+        start_time = time.time()\n+        while True:\n+            server.step()\n+            if not server.has_unfinished_requests():\n+                break\n+        end_time = time.time()\n+        latency = end_time - start_time\n+        if profile:\n+            torch.cuda.cudart().cudaProfilerStop()\n+        return latency\n+\n+    print(\"Warm up step\")\n+    profile_step()\n+\n+    # Benchmark.\n+    latencies = []\n+    for _ in tqdm(range(3), desc=\"Profile step\"):\n+        latencies.append(profile_step())\n+    print(f'Avg latency: {np.mean(latencies)} seconds')\n+\n+\n+if __name__ == '__main__':\n+    parser = argparse.ArgumentParser(description='CacheFlow simple server.')\n+    parser = add_server_arguments(parser)\n+    parser.add_argument('--input-len', type=int, default=32)\n+    parser.add_argument('--output-len', type=int, default=128)\n+    parser.add_argument('--batch-size', type=int, default=8)\n+    args = parser.parse_args()\n+    args.max_batch_size = max(args.max_batch_size, args.batch_size * args.input_len)\n+    print(args)\n+    main(args)",
      "change_type": "added",
      "lines_added": 100,
      "lines_removed": 1
    },
    {
      "file_path": "cacheflow/parallel_utils/tensor_parallel/__init__.py",
      "old_content": "from .layers import (\n    ColumnParallelLinear,\n    RowParallelLinear,\n    VocabParallelEmbedding,\n    set_tensor_model_parallel_attributes,\n    set_defaults_if_not_set_tensor_model_parallel_attributes,\n    copy_tensor_model_parallel_attributes,\n    param_is_not_tensor_parallel_duplicate,\n    linear_with_grad_accumulation_and_async_allreduce\n\n)\n\nfrom .mappings import (\n    copy_to_tensor_model_parallel_region,\n    gather_from_tensor_model_parallel_region,\n    gather_from_sequence_parallel_region,\n    scatter_to_tensor_model_parallel_region,\n    scatter_to_sequence_parallel_region,\n)\n\nfrom .random import (\n    checkpoint,\n    get_cuda_rng_tracker,\n    model_parallel_cuda_manual_seed,\n)\n\nfrom .utils import (\n    split_tensor_along_last_dim,\n    split_tensor_into_1d_equal_chunks,\n    gather_split_1d_tensor,\n)\n\n__all__ = [\n    #layers.py\n    \"ColumnParallelLinear\",\n    \"RowParallelLinear\",\n    \"VocabParallelEmbedding\",\n    \"set_tensor_model_parallel_attributes\",\n    \"set_defaults_if_not_set_tensor_model_parallel_attributes\",\n    \"copy_tensor_model_parallel_attributes\",\n    \"param_is_not_tensor_parallel_duplicate\",\n    \"linear_with_grad_accumulation_and_async_allreduce\",\n    # mappings.py\n    \"copy_to_tensor_model_parallel_region\",\n    \"gather_from_tensor_model_parallel_region\",\n    \"gather_from_sequence_parallel_region\",\n#    \"reduce_from_tensor_model_parallel_region\",\n    \"scatter_to_tensor_model_parallel_region\",\n    \"scatter_to_sequence_parallel_region\",\n    # random.py\n    \"checkpoint\",\n    \"get_cuda_rng_tracker\",\n    \"model_parallel_cuda_manual_seed\",\n    # utils.py\n    \"split_tensor_along_last_dim\",\n    \"split_tensor_into_1d_equal_chunks\",\n    \"gather_split_1d_tensor\",\n]\n",
      "diff": "diff --git a/cacheflow/parallel_utils/tensor_parallel/__init__.py b/cacheflow/parallel_utils/tensor_parallel/__init__.py\nindex fba4f9abe..246f5f6f2 100644\n--- a/cacheflow/parallel_utils/tensor_parallel/__init__.py\n+++ b/cacheflow/parallel_utils/tensor_parallel/__init__.py\n@@ -6,8 +6,6 @@ from .layers import (\n     set_defaults_if_not_set_tensor_model_parallel_attributes,\n     copy_tensor_model_parallel_attributes,\n     param_is_not_tensor_parallel_duplicate,\n-    linear_with_grad_accumulation_and_async_allreduce\n-\n )\n \n from .mappings import (\n@@ -39,7 +37,6 @@ __all__ = [\n     \"set_defaults_if_not_set_tensor_model_parallel_attributes\",\n     \"copy_tensor_model_parallel_attributes\",\n     \"param_is_not_tensor_parallel_duplicate\",\n-    \"linear_with_grad_accumulation_and_async_allreduce\",\n     # mappings.py\n     \"copy_to_tensor_model_parallel_region\",\n     \"gather_from_tensor_model_parallel_region\",",
      "change_type": "modified",
      "lines_added": 1,
      "lines_removed": 4
    },
    {
      "file_path": "cacheflow/parallel_utils/tensor_parallel/layers.py",
      "old_content": "# Copyright (c) 2022, NVIDIA CORPORATION. All rights reserved.\n\n# Parts of the code here are adapted from PyTorch\n# repo: https://github.com/pytorch/pytorch\n\nimport math\nimport os\nfrom typing import Optional\nimport warnings\n\nimport torch\nimport torch.nn.functional as F\nimport torch.nn.init as init\nfrom torch.nn.parameter import Parameter\n\nfrom cacheflow.parallel_utils.parallel_state import (\n    get_tensor_model_parallel_rank,\n    get_tensor_model_parallel_world_size,\n    get_tensor_model_parallel_group,\n    get_global_memory_buffer,\n)\nfrom .mappings import (\n    copy_to_tensor_model_parallel_region,\n    gather_from_tensor_model_parallel_region,\n    gather_from_sequence_parallel_region,\n    reduce_from_tensor_model_parallel_region,\n    scatter_to_tensor_model_parallel_region,\n    reduce_scatter_to_sequence_parallel_region,\n)\n\nfrom .random import get_cuda_rng_tracker\nfrom .utils import (\n    divide,\n    split_tensor_along_last_dim,\n    VocabUtility,\n)\n\n_grad_accum_fusion_available = True\ntry:\n    import fused_weight_gradient_mlp_cuda\nexcept ImportError:\n    _grad_accum_fusion_available = False\n\n_MODEL_PARALLEL_ATTRIBUTE_DEFAULTS = {'tensor_model_parallel': False,\n                                      'partition_dim': -1,\n                                      'partition_stride': 1}\n\ndef param_is_not_tensor_parallel_duplicate(param):\n    return (hasattr(param, 'tensor_model_parallel') and\n            param.tensor_model_parallel) or (\n                get_tensor_model_parallel_rank() == 0)\n\n\ndef set_tensor_model_parallel_attributes(tensor, is_parallel, dim, stride):\n    # Make sure the attributes are not set.\n    for attribute in _MODEL_PARALLEL_ATTRIBUTE_DEFAULTS:\n        assert not hasattr(tensor, attribute)\n    # Set the attributes.\n    setattr(tensor, 'tensor_model_parallel', is_parallel)\n    setattr(tensor, 'partition_dim', dim)\n    setattr(tensor, 'partition_stride', stride)\n\n\ndef set_defaults_if_not_set_tensor_model_parallel_attributes(tensor):\n    def maybe_set(attribute, value):\n        if not hasattr(tensor, attribute):\n            setattr(tensor, attribute, value)\n    for attribute in _MODEL_PARALLEL_ATTRIBUTE_DEFAULTS:\n        maybe_set(attribute, _MODEL_PARALLEL_ATTRIBUTE_DEFAULTS[attribute])\n\n\ndef copy_tensor_model_parallel_attributes(destination_tensor, source_tensor):\n    def maybe_copy(attribute):\n        if hasattr(source_tensor, attribute):\n            setattr(destination_tensor, attribute,\n                    getattr(source_tensor, attribute))\n    for attribute in _MODEL_PARALLEL_ATTRIBUTE_DEFAULTS:\n        maybe_copy(attribute)\n\n\ndef _initialize_affine_weight_gpu(weight, init_method,\n                                  partition_dim, stride=1):\n    \"\"\"Initialize affine weight for model parallel on GPU.\"\"\"\n\n    set_tensor_model_parallel_attributes(tensor=weight,\n                                         is_parallel=True,\n                                         dim=partition_dim,\n                                         stride=stride)\n\n    with get_cuda_rng_tracker().fork():\n        init_method(weight)\n\n\ndef _initialize_affine_weight_cpu(weight, output_size, input_size,\n                                  per_partition_size, partition_dim,\n                                  init_method, stride=1,\n                                  return_master_weight=False,\n                                  *, params_dtype=None):\n    \"\"\"Initialize affine weight for model parallel.\n\n    Build the master weight on all processes and scatter\n    the relevant chunk.\"\"\"\n\n    set_tensor_model_parallel_attributes(tensor=weight,\n                                         is_parallel=True,\n                                         dim=partition_dim,\n                                         stride=stride)\n\n    if params_dtype is None:\n        params_dtype = torch.get_default_dtype()\n\n    # Initialize master weight\n    master_weight = torch.empty(output_size, input_size,\n                                dtype=torch.float,\n                                requires_grad=False)\n    init_method(master_weight)\n    master_weight = master_weight.to(dtype=params_dtype)\n\n    # Split and copy\n    per_partition_per_stride_size = divide(per_partition_size, stride)\n    weight_list = torch.split(master_weight, per_partition_per_stride_size,\n                              dim=partition_dim)\n    rank = get_tensor_model_parallel_rank()\n    world_size = get_tensor_model_parallel_world_size()\n    my_weight_list = weight_list[rank::world_size]\n\n    with torch.no_grad():\n        torch.cat(my_weight_list, dim=partition_dim, out=weight)\n    if return_master_weight:\n        return master_weight\n    return None\n\n\nclass VocabParallelEmbedding(torch.nn.Module):\n    \"\"\"Embedding parallelized in the vocabulary dimension.\n\n    This is mainly adapted from torch.nn.Embedding and all the default\n    values are kept.\n    Arguments:\n        num_embeddings: vocabulary size.\n        embedding_dim: size of hidden state.\n\n    Keyword Arguments:\n        init_method: method to initialize weights.\n        params_dtype\n        use_cpu_initialization\n        perform_initialization\n    \"\"\"\n\n    def __init__(self, num_embeddings: int, embedding_dim: int, *,\n                 init_method=init.xavier_normal_,\n                 params_dtype: torch.dtype=None,\n                 use_cpu_initialization: bool=False,\n                 perform_initialization: bool=True):\n        super(VocabParallelEmbedding, self).__init__()\n        # Keep the input dimensions.\n        self.num_embeddings = num_embeddings\n        self.embedding_dim = embedding_dim\n        if params_dtype is None:\n            params_dtype = torch.get_default_dtype()\n\n        # Set the defaults for compatibility.\n        self.padding_idx = None\n        self.max_norm = None\n        self.norm_type = 2.\n        self.scale_grad_by_freq = False\n        self.sparse = False\n        self._weight = None\n        self.tensor_model_parallel_size = get_tensor_model_parallel_world_size()\n        # Divide the weight matrix along the vocaburaly dimension.\n        self.vocab_start_index, self.vocab_end_index = \\\n            VocabUtility.vocab_range_from_global_vocab_size(\n                self.num_embeddings, get_tensor_model_parallel_rank(),\n                self.tensor_model_parallel_size)\n        self.num_embeddings_per_partition = self.vocab_end_index - \\\n            self.vocab_start_index\n\n        # Allocate weights and initialize.\n        if use_cpu_initialization:\n            self.weight = Parameter(torch.empty(\n                self.num_embeddings_per_partition, self.embedding_dim,\n                dtype=params_dtype))\n            if perform_initialization:\n                _initialize_affine_weight_cpu(\n                    self.weight, self.num_embeddings, self.embedding_dim,\n                    self.num_embeddings_per_partition, 0, init_method,\n                    params_dtype=params_dtype)\n        else:\n            self.weight = Parameter(torch.empty(\n                self.num_embeddings_per_partition, self.embedding_dim,\n                device=torch.cuda.current_device(), dtype=params_dtype))\n            if perform_initialization:\n                _initialize_affine_weight_gpu(self.weight, init_method,\n                                              partition_dim=0, stride=1)\n\n    def forward(self, input_):\n        if self.tensor_model_parallel_size > 1:\n            # Build the mask.\n            input_mask = (input_ < self.vocab_start_index) | \\\n                         (input_ >= self.vocab_end_index)\n            # Mask the input.\n            masked_input = input_.clone() - self.vocab_start_index\n            masked_input[input_mask] = 0\n        else:\n            masked_input = input_\n            # Get the embeddings.\n        output_parallel = F.embedding(masked_input, self.weight,\n                                      self.padding_idx, self.max_norm,\n                                      self.norm_type, self.scale_grad_by_freq,\n                                      self.sparse)\n        # Mask the output embedding.\n        if self.tensor_model_parallel_size > 1:\n            output_parallel[input_mask, :] = 0.0\n        # Reduce across all the model parallel GPUs.\n        output = reduce_from_tensor_model_parallel_region(output_parallel)\n        return output\n\n\nclass LinearWithGradAccumulationAndAsyncCommunication(torch.autograd.Function):\n    \"\"\"See linear_with_grad_accumulation_and_async_allreduce\"\"\"\n\n    @staticmethod\n    def forward(ctx, input, weight, bias, gradient_accumulation_fusion,\n                async_grad_allreduce, sequence_parallel):\n        ctx.save_for_backward(input, weight)\n        ctx.use_bias = bias is not None\n        ctx.gradient_accumulation_fusion = gradient_accumulation_fusion\n        ctx.async_grad_allreduce = async_grad_allreduce\n        ctx.sequence_parallel = sequence_parallel\n\n        if sequence_parallel:\n            world_size = get_tensor_model_parallel_world_size()\n            dim_size = list(input.size())\n            dim_size[0] = dim_size[0] * world_size\n\n            all_gather_buffer = \\\n                get_global_memory_buffer().get_tensor(dim_size, input.dtype, \"mpu\")\n            torch.distributed._all_gather_base(\n                all_gather_buffer,\n                input,\n                group=get_tensor_model_parallel_group())\n            total_input = all_gather_buffer\n        else:\n            total_input = input\n\n        output = torch.matmul(total_input, weight.t())\n        if bias is not None:\n            output = output + bias\n        return output\n\n    @staticmethod\n    def backward(ctx, grad_output):\n        input, weight = ctx.saved_tensors\n        use_bias = ctx.use_bias\n\n        if ctx.sequence_parallel:\n            world_size = get_tensor_model_parallel_world_size()\n            dim_size = list(input.size())\n            dim_size[0] = dim_size[0] * world_size\n\n            all_gather_buffer = \\\n                get_global_memory_buffer().get_tensor(dim_size, input.dtype, \"mpu\")\n            handle = torch.distributed._all_gather_base(\n                all_gather_buffer,\n                input,\n                group=get_tensor_model_parallel_group(), async_op=True)\n\n            # Here we rely on CUDA_DEVICE_MAX_CONNECTIONS=1 to ensure that the\n            # gather is scheduled before the input gradient computation\n            total_input = all_gather_buffer\n        else:\n            total_input = input\n        grad_input = grad_output.matmul(weight)\n\n        if ctx.sequence_parallel:\n            handle.wait()\n\n        # Convert the tensor shapes to 2D for execution compatibility\n        grad_output = grad_output.view(grad_output.shape[0] * grad_output.shape[1],\n                                       grad_output.shape[2])\n        total_input = total_input.view(total_input.shape[0] * total_input.shape[1],\n\t\t\t\t       total_input.shape[2])\n\n        if ctx.async_grad_allreduce:\n            # Asynchronous all-reduce\n            handle = torch.distributed.all_reduce(\n                    grad_input, group=get_tensor_model_parallel_group(), async_op=True)\n            # Here we rely on CUDA_DEVICE_MAX_CONNECTIONS=1 to ensure that the\n            # all-reduce is scheduled before the weight gradient computation\n\n        if ctx.sequence_parallel:\n            assert not ctx.async_grad_allreduce\n            dim_size = list(input.size())\n            sub_grad_input = torch.empty(dim_size, dtype=input.dtype,\n                                         device=torch.cuda.current_device(),\n                                         requires_grad=False)\n            # reduce_scatter\n            handle = torch.distributed._reduce_scatter_base(sub_grad_input, grad_input,\n                                                            group=get_tensor_model_parallel_group(),\n                                                            async_op=True)\n            # Here we rely on CUDA_DEVICE_MAX_CONNECTIONS=1 to ensure that the\n            # reduce scatter is scheduled before the weight gradient computation\n\n\n        if ctx.gradient_accumulation_fusion:\n            if weight.main_grad.dtype == torch.float32:\n                fused_weight_gradient_mlp_cuda.wgrad_gemm_accum_fp32(total_input, grad_output, weight.main_grad)\n            elif weight.main_grad.dtype == torch.float16:\n                fused_weight_gradient_mlp_cuda.wgrad_gemm_accum_fp16(total_input, grad_output, weight.main_grad)\n            else:\n                raise RuntimeError(\"Unsupported gradient type for gradient accumulation fusion\")\n            grad_weight = None\n        else:\n            grad_weight = grad_output.t().matmul(total_input)\n        grad_bias = grad_output.sum(dim=0) if use_bias else None\n\n        if ctx.sequence_parallel:\n            handle.wait()\n            return sub_grad_input, grad_weight, grad_bias, None, None, None\n\n        if ctx.async_grad_allreduce:\n            handle.wait()\n\n        return grad_input, grad_weight, grad_bias, None, None, None\n\ndef linear_with_grad_accumulation_and_async_allreduce(\n    input: torch.Tensor,\n    weight: torch.Tensor,\n    bias: Optional[torch.Tensor],\n    gradient_accumulation_fusion: bool,\n    async_grad_allreduce: bool,\n    sequence_parallel_enabled: bool,\n) -> torch.Tensor:\n    \"\"\"Linear layer execution with asynchronous communication and\n    gradient accumulation fusion in backprop.\n\n    This has the option to accumulate the result of backprop\n    calculation into an existing gradient buffer, preventing the need\n    to do an additional addition kernel after the gradient\n    calculation.\n\n    Additionally, the tensor parallel all reduce of the input\n    gradients can be done asynchronously with the calculation of\n    the weight gradients.\n\n    In the case of sequence parallelism, the reduce scatter of the\n    input gradients is done asynchronously with the calcluation of the\n    weight gradients.\n\n    Use of this module requires that the environment variable\n    CUDA_DEVICE_MAX_CONNECTIONS=1. There are a few collective\n    operations, noted in the code, that should be scheduled before\n    compute kernels to overlap the communication with the computation,\n    which is necessary for a speedup but not for correctness so that\n    ordering isn't imposed by the scheduler. Setting\n    CUDA_DEVICE_MAX_CONNECTIONS=1 forces the kernels to be scheduled\n    in the order they are called.\n\n    Arguments:\n\n    input (torch.Tensor required): input like torch.nn.functional.linear\n\n    weight (torch.Tensor required): weight like torch.nn.functional.linear\n\n    bias (torch.Tensor optional): bias like torch.nn.functional.linear\n\n    gradient_accumulation_fusion (bool required): Perform the gradient\n        accumulation fusion, requires the custom CUDA extension\n        fused_weight_gradient_mlp_cuda module. To use\n        gradient_accumulation_fusion you must install APEX with\n        --cpp_ext and --cuda_ext. For example: \"pip install\n        --global-option=\\\"--cpp_ext\\\" --global-option=\\\"--cuda_ext .\\\"\n        \" Note that the extension requires CUDA>=11. Otherwise, you\n        must turn off gradient accumulation fusion.\"\n\n    async_grad_allreduce (bool required): Do the allreduce of input\n        gradients asyncronously with the computation of weight\n        gradients. If sequence_parallel_enabled is True, this must be\n        False, as no all reduce is performed.\n\n    sequence_parallel_enabled (bool required): Indicates that sequence\n        parallelism is used and thus in the forward pass the input is\n        all gathered, and the backward pass the input gradients are\n        reduce scattered.\n    \"\"\"\n    args = [\n        input,\n        weight,\n        bias,\n        gradient_accumulation_fusion,\n        async_grad_allreduce,\n        sequence_parallel_enabled,\n    ]\n\n    if not linear_with_grad_accumulation_and_async_allreduce.warned:\n        if os.environ.get('CUDA_DEVICE_MAX_CONNECTIONS') != \"1\":\n            if sequence_parallel_enabled:\n                warnings.warn(\n                    \"When using sequence parallelism it is recommended to set the \"\n                    \"environment variable CUDA_DEVICE_MAX_CONNECTIONS to 1 for \"\n                    \"maximum speedup\")\n                linear_with_grad_accumulation_and_async_allreduce.warned = True\n\n            if async_grad_allreduce:\n                warnings.warn(\n                    \"When using async grad allreduce it is recommended to set the \"\n                    \"environment variable CUDA_DEVICE_MAX_CONNECTIONS to 1 for \"\n                    \"maximum speedup\")\n                linear_with_grad_accumulation_and_async_allreduce.warned = True\n\n    with torch.cuda.amp.autocast(enabled=False):\n        return LinearWithGradAccumulationAndAsyncCommunication.apply(*args)\nlinear_with_grad_accumulation_and_async_allreduce.warned = False\n\nclass ColumnParallelLinear(torch.nn.Module):\n    \"\"\"Linear layer with column parallelism.\n\n    The linear layer is defined as Y = XA + b. A is parallelized along\n    its second dimension as A = [A_1, ..., A_p].\n\n    Arguments:\n        input_size: first dimension of matrix A.\n        output_size: second dimension of matrix A.\n\n    Keyword Arguments\n        bias: If true, add bias\n        gather_output: If true, call all-gather on output and make Y available\n                       to all GPUs, otherwise, every GPU will have its output\n                       which is Y_i = XA_i\n        init_method: method to initialize weights. Note that bias is always set\n                     to zero.\n        stride: For the strided linear layers.\n        keep_master_weight_for_test: This was added for testing and should be\n                                     set to False. It returns the master weights\n                                     used for initialization.\n        skip_bias_add: This was added to enable performance optimations where bias\n                       can be fused with other elementwise operations. we skip\n                       adding bias but instead return it.\n        async_tensor_model_parallel_allreduce:\n        params_dtype:\n        use_cpu_initialization:\n        gradient_accumulation_fusion:\n        sequence_parallel_enabled:\n    \"\"\"\n\n    def __init__(self, input_size, output_size, *,\n                 bias=True, gather_output=True,\n                 init_method=init.xavier_normal_, stride=1,\n                 keep_master_weight_for_test=False,\n                 skip_bias_add=False,\n                 async_tensor_model_parallel_allreduce=True,\n                 params_dtype=None,\n                 use_cpu_initialization=False,\n                 perform_initialization=True,\n                 gradient_accumulation_fusion=False,\n                 sequence_parallel_enabled: bool = False,\n                 ):\n        super(ColumnParallelLinear, self).__init__()\n\n        # Keep input parameters\n        self.input_size = input_size\n        self.output_size = output_size\n        self.gather_output = gather_output\n        # Divide the weight matrix along the last dimension.\n        world_size = get_tensor_model_parallel_world_size()\n        self.output_size_per_partition = divide(output_size, world_size)\n        self.skip_bias_add = skip_bias_add\n\n        if params_dtype is None:\n            params_dtype = torch.get_default_dtype()\n\n        # Parameters.\n        # Note: torch.nn.functional.linear performs XA^T + b and as a result\n        # we allocate the transpose.\n        # Initialize weight.\n        if use_cpu_initialization:\n            self.weight = Parameter(torch.empty(self.output_size_per_partition,\n                                                self.input_size,\n                                                dtype=params_dtype))\n            if perform_initialization:\n                self.master_weight = _initialize_affine_weight_cpu(\n                    self.weight, self.output_size, self.input_size,\n                    self.output_size_per_partition, 0, init_method,\n                    stride=stride, return_master_weight=keep_master_weight_for_test)\n        else:\n            self.weight = Parameter(torch.empty(\n                self.output_size_per_partition, self.input_size,\n                device=torch.cuda.current_device(), dtype=params_dtype))\n            if perform_initialization:\n                _initialize_affine_weight_gpu(self.weight, init_method,\n                                              partition_dim=0, stride=stride)\n\n        if bias:\n            if use_cpu_initialization:\n                self.bias = Parameter(torch.empty(\n                    self.output_size_per_partition, dtype=params_dtype))\n            else:\n                self.bias = Parameter(torch.empty(\n                    self.output_size_per_partition,\n                    device=torch.cuda.current_device(),\n                    dtype=params_dtype))\n            set_tensor_model_parallel_attributes(self.bias, True, 0, stride)\n            # Always initialize bias to zero.\n            with torch.no_grad():\n                self.bias.zero_()\n        else:\n            self.register_parameter('bias', None)\n\n        self.async_tensor_model_parallel_allreduce = (\n                async_tensor_model_parallel_allreduce and\n                world_size > 1)\n        if sequence_parallel_enabled:\n            if world_size <= 1:\n                warnings.warn(\n                    f\"`sequence_parallel_enabled` is set to `True`, but tensor model parallel size is {world_size}. \"\n                    f\"Disabling sequence parallel.\"\n                )\n                sequence_parallel_enabled = False\n        self.sequence_parallel_enabled = sequence_parallel_enabled\n\n        if gradient_accumulation_fusion:\n            if not _grad_accum_fusion_available:\n                raise RuntimeError(\n                    \"ColumnParallelLinear was called with gradient_accumulation_fusion set \"\n                    \"to True but the custom CUDA extension fused_weight_gradient_mlp_cuda \"\n                    \"module is not found. To use gradient_accumulation_fusion you must \"\n                    \"install APEX with --cpp_ext and --cuda_ext. For example: \"\n                    \"pip install --global-option=\\\"--cpp_ext\\\" --global-option=\\\"--cuda_ext .\\\" \"\n                    \"Note that the extension requires CUDA>=11. Otherwise, you must turn off \"\n                    \"gradient accumulation fusion.\"\n                )\n        self.gradient_accumulation_fusion = gradient_accumulation_fusion\n\n        if self.async_tensor_model_parallel_allreduce and self.sequence_parallel_enabled:\n            raise RuntimeError(\n                \"`async_tensor_model_parallel_allreduce` and `sequence_parallel_enabled` \"\n                \"cannot be enabled at the same time.\"\n            )\n\n\n    def forward(self, input_):\n        \"\"\"Forward of ColumnParallelLinear\n\n        Args:\n            input_: 3D tensor whose order of dimension is [sequence, batch, hidden]\n\n        Returns:\n            - output\n            - bias\n        \"\"\"\n        bias = self.bias if not self.skip_bias_add else None\n\n        if self.async_tensor_model_parallel_allreduce or \\\n                self.sequence_parallel_enabled:\n            input_parallel = input_\n        else:\n            input_parallel = copy_to_tensor_model_parallel_region(input_)\n        # Matrix multiply.\n        output_parallel = linear_with_grad_accumulation_and_async_allreduce(\n            input=input_parallel,\n            weight=self.weight,\n            bias=bias,\n            gradient_accumulation_fusion=self.gradient_accumulation_fusion,\n            async_grad_allreduce=self.async_tensor_model_parallel_allreduce,\n            sequence_parallel_enabled=self.sequence_parallel_enabled,\n        )\n        if self.gather_output:\n            # All-gather across the partitions.\n            assert not self.sequence_parallel_enabled\n            output = gather_from_tensor_model_parallel_region(output_parallel)\n        else:\n            output = output_parallel\n        output_bias = self.bias if self.skip_bias_add else None\n        return output, output_bias\n\n\nclass RowParallelLinear(torch.nn.Module):\n    \"\"\"Linear layer with row parallelism.\n\n    The linear layer is defined as Y = XA + b. A is parallelized along\n    its first dimension and X along its second dimension as:\n               -   -\n              | A_1 |\n              | .   |\n          A = | .   |        X = [X_1, ..., X_p]\n              | .   |\n              | A_p |\n               -   -\n    Arguments:\n        input_size: first dimension of matrix A.\n        output_size: second dimension of matrix A.\n\n    Keyword Arguments:\n        bias: If true, add bias. Note that bias is not parallelized.\n        input_is_parallel: If true, we assume that the input is already\n                           split across the GPUs and we do not split\n                           again.\n        init_method: method to initialize weights. Note that bias is always set\n                     to zero.\n        stride: For the strided linear layers.\n        keep_master_weight_for_test: This was added for testing and should be\n                                     set to False. It returns the master weights\n                                     used for initialization.\n        skip_bias_add: This was added to enable performance optimization where bias\n                       can be fused with other elementwise operations. We skip\n                       adding bias but instead return it.\n        params_dtype:\n        use_cpu_initialization:\n        perform_initialization:\n        gradient_accumulation_fusion:\n        sequence_parallel_enabled:\n    \"\"\"\n\n    def __init__(self, input_size, output_size, *,\n                 bias=True, input_is_parallel=False,\n                 init_method=init.xavier_normal_, stride=1,\n                 keep_master_weight_for_test=False,\n                 skip_bias_add=False,\n                 params_dtype=None,\n                 use_cpu_initialization=False,\n                 perform_initialization=True,\n                 gradient_accumulation_fusion=False,\n                 sequence_parallel_enabled: bool = False,\n                 ):\n        super(RowParallelLinear, self).__init__()\n\n        # Keep input parameters\n        self.input_size = input_size\n        self.output_size = output_size\n        self.input_is_parallel = input_is_parallel\n        if params_dtype is None:\n            params_dtype = torch.get_default_dtype()\n\n        # Divide the weight matrix along the last dimension.\n        world_size = get_tensor_model_parallel_world_size()\n        self.input_size_per_partition = divide(input_size, world_size)\n        self.skip_bias_add = skip_bias_add\n        self.gradient_accumulation_fusion = gradient_accumulation_fusion\n        self.sequence_parallel_enabled = sequence_parallel_enabled\n        if self.sequence_parallel_enabled and not self.input_is_parallel:\n            raise RuntimeError(\"To enable `sequence_parallel_enabled`, `input_is_parallel` must be `True`\")\n\n        # Parameters.\n        # Note: torch.nn.functional.linear performs XA^T + b and as a result\n        # we allocate the transpose.\n        # Initialize weight.\n        if use_cpu_initialization:\n            self.weight = Parameter(torch.empty(self.output_size,\n                                                self.input_size_per_partition,\n                                                dtype=params_dtype))\n            if perform_initialization:\n                self.master_weight = _initialize_affine_weight_cpu(\n                    self.weight, self.output_size, self.input_size,\n                    self.input_size_per_partition, 1, init_method,\n                    stride=stride, return_master_weight=keep_master_weight_for_test,\n                    params_dtype=params_dtype)\n        else:\n            self.weight = Parameter(torch.empty(\n                self.output_size, self.input_size_per_partition,\n                device=torch.cuda.current_device(), dtype=params_dtype))\n            if perform_initialization:\n                _initialize_affine_weight_gpu(self.weight, init_method,\n                                              partition_dim=1, stride=stride)\n        if bias:\n            if use_cpu_initialization:\n                self.bias = Parameter(torch.empty(self.output_size,\n                                                  dtype=params_dtype))\n            else:\n                self.bias = Parameter(torch.empty(\n                    self.output_size, device=torch.cuda.current_device(),\n                    dtype=params_dtype))\n            setattr(self.bias, 'sequence_parallel', sequence_parallel_enabled)\n\n            # Always initialize bias to zero.\n            with torch.no_grad():\n                self.bias.zero_()\n        else:\n            self.register_parameter('bias', None)\n\n\n\n    def forward(self, input_):\n        \"\"\"Forward of RowParallelLinear\n\n        Args:\n            input_: 3D tensor whose order of dimension is [sequence, batch, hidden]\n\n        Returns:\n            - output\n            - bias\n        \"\"\"\n        # Set up backprop all-reduce.\n        if self.input_is_parallel:\n            input_parallel = input_\n        else:\n            assert not self.sequence_parallel_enabled\n            input_parallel = scatter_to_tensor_model_parallel_region(input_)\n        # Matrix multiply.\n        output_parallel = linear_with_grad_accumulation_and_async_allreduce(\n            input=input_parallel,\n            weight=self.weight,\n            bias=None,\n            gradient_accumulation_fusion=self.gradient_accumulation_fusion,\n            async_grad_allreduce=False,\n            sequence_parallel_enabled=False,\n        )\n\n        # All-reduce across all the partitions.\n        if self.sequence_parallel_enabled:\n            output_ = reduce_scatter_to_sequence_parallel_region(output_parallel)\n        else:\n            output_ = reduce_from_tensor_model_parallel_region(output_parallel)\n        if not self.skip_bias_add:\n            output = output_ + self.bias if self.bias is not None else output_\n            output_bias = None\n        else:\n            output = output_\n            output_bias = self.bias\n        return output, output_bias\n",
      "diff": "diff --git a/cacheflow/parallel_utils/tensor_parallel/layers.py b/cacheflow/parallel_utils/tensor_parallel/layers.py\nindex 978ca04e6..f9ba8385c 100644\n--- a/cacheflow/parallel_utils/tensor_parallel/layers.py\n+++ b/cacheflow/parallel_utils/tensor_parallel/layers.py\n@@ -3,10 +3,6 @@\n # Parts of the code here are adapted from PyTorch\n # repo: https://github.com/pytorch/pytorch\n \n-import math\n-import os\n-from typing import Optional\n-import warnings\n \n import torch\n import torch.nn.functional as F\n@@ -16,31 +12,20 @@ from torch.nn.parameter import Parameter\n from cacheflow.parallel_utils.parallel_state import (\n     get_tensor_model_parallel_rank,\n     get_tensor_model_parallel_world_size,\n-    get_tensor_model_parallel_group,\n-    get_global_memory_buffer,\n )\n from .mappings import (\n     copy_to_tensor_model_parallel_region,\n     gather_from_tensor_model_parallel_region,\n-    gather_from_sequence_parallel_region,\n     reduce_from_tensor_model_parallel_region,\n     scatter_to_tensor_model_parallel_region,\n-    reduce_scatter_to_sequence_parallel_region,\n )\n \n from .random import get_cuda_rng_tracker\n from .utils import (\n     divide,\n-    split_tensor_along_last_dim,\n     VocabUtility,\n )\n \n-_grad_accum_fusion_available = True\n-try:\n-    import fused_weight_gradient_mlp_cuda\n-except ImportError:\n-    _grad_accum_fusion_available = False\n-\n _MODEL_PARALLEL_ATTRIBUTE_DEFAULTS = {'tensor_model_parallel': False,\n                                       'partition_dim': -1,\n                                       'partition_stride': 1}\n@@ -216,202 +201,6 @@ class VocabParallelEmbedding(torch.nn.Module):\n         return output\n \n \n-class LinearWithGradAccumulationAndAsyncCommunication(torch.autograd.Function):\n-    \"\"\"See linear_with_grad_accumulation_and_async_allreduce\"\"\"\n-\n-    @staticmethod\n-    def forward(ctx, input, weight, bias, gradient_accumulation_fusion,\n-                async_grad_allreduce, sequence_parallel):\n-        ctx.save_for_backward(input, weight)\n-        ctx.use_bias = bias is not None\n-        ctx.gradient_accumulation_fusion = gradient_accumulation_fusion\n-        ctx.async_grad_allreduce = async_grad_allreduce\n-        ctx.sequence_parallel = sequence_parallel\n-\n-        if sequence_parallel:\n-            world_size = get_tensor_model_parallel_world_size()\n-            dim_size = list(input.size())\n-            dim_size[0] = dim_size[0] * world_size\n-\n-            all_gather_buffer = \\\n-                get_global_memory_buffer().get_tensor(dim_size, input.dtype, \"mpu\")\n-            torch.distributed._all_gather_base(\n-                all_gather_buffer,\n-                input,\n-                group=get_tensor_model_parallel_group())\n-            total_input = all_gather_buffer\n-        else:\n-            total_input = input\n-\n-        output = torch.matmul(total_input, weight.t())\n-        if bias is not None:\n-            output = output + bias\n-        return output\n-\n-    @staticmethod\n-    def backward(ctx, grad_output):\n-        input, weight = ctx.saved_tensors\n-        use_bias = ctx.use_bias\n-\n-        if ctx.sequence_parallel:\n-            world_size = get_tensor_model_parallel_world_size()\n-            dim_size = list(input.size())\n-            dim_size[0] = dim_size[0] * world_size\n-\n-            all_gather_buffer = \\\n-                get_global_memory_buffer().get_tensor(dim_size, input.dtype, \"mpu\")\n-            handle = torch.distributed._all_gather_base(\n-                all_gather_buffer,\n-                input,\n-                group=get_tensor_model_parallel_group(), async_op=True)\n-\n-            # Here we rely on CUDA_DEVICE_MAX_CONNECTIONS=1 to ensure that the\n-            # gather is scheduled before the input gradient computation\n-            total_input = all_gather_buffer\n-        else:\n-            total_input = input\n-        grad_input = grad_output.matmul(weight)\n-\n-        if ctx.sequence_parallel:\n-            handle.wait()\n-\n-        # Convert the tensor shapes to 2D for execution compatibility\n-        grad_output = grad_output.view(grad_output.shape[0] * grad_output.shape[1],\n-                                       grad_output.shape[2])\n-        total_input = total_input.view(total_input.shape[0] * total_input.shape[1],\n-\t\t\t\t       total_input.shape[2])\n-\n-        if ctx.async_grad_allreduce:\n-            # Asynchronous all-reduce\n-            handle = torch.distributed.all_reduce(\n-                    grad_input, group=get_tensor_model_parallel_group(), async_op=True)\n-            # Here we rely on CUDA_DEVICE_MAX_CONNECTIONS=1 to ensure that the\n-            # all-reduce is scheduled before the weight gradient computation\n-\n-        if ctx.sequence_parallel:\n-            assert not ctx.async_grad_allreduce\n-            dim_size = list(input.size())\n-            sub_grad_input = torch.empty(dim_size, dtype=input.dtype,\n-                                         device=torch.cuda.current_device(),\n-                                         requires_grad=False)\n-            # reduce_scatter\n-            handle = torch.distributed._reduce_scatter_base(sub_grad_input, grad_input,\n-                                                            group=get_tensor_model_parallel_group(),\n-                                                            async_op=True)\n-            # Here we rely on CUDA_DEVICE_MAX_CONNECTIONS=1 to ensure that the\n-            # reduce scatter is scheduled before the weight gradient computation\n-\n-\n-        if ctx.gradient_accumulation_fusion:\n-            if weight.main_grad.dtype == torch.float32:\n-                fused_weight_gradient_mlp_cuda.wgrad_gemm_accum_fp32(total_input, grad_output, weight.main_grad)\n-            elif weight.main_grad.dtype == torch.float16:\n-                fused_weight_gradient_mlp_cuda.wgrad_gemm_accum_fp16(total_input, grad_output, weight.main_grad)\n-            else:\n-                raise RuntimeError(\"Unsupported gradient type for gradient accumulation fusion\")\n-            grad_weight = None\n-        else:\n-            grad_weight = grad_output.t().matmul(total_input)\n-        grad_bias = grad_output.sum(dim=0) if use_bias else None\n-\n-        if ctx.sequence_parallel:\n-            handle.wait()\n-            return sub_grad_input, grad_weight, grad_bias, None, None, None\n-\n-        if ctx.async_grad_allreduce:\n-            handle.wait()\n-\n-        return grad_input, grad_weight, grad_bias, None, None, None\n-\n-def linear_with_grad_accumulation_and_async_allreduce(\n-    input: torch.Tensor,\n-    weight: torch.Tensor,\n-    bias: Optional[torch.Tensor],\n-    gradient_accumulation_fusion: bool,\n-    async_grad_allreduce: bool,\n-    sequence_parallel_enabled: bool,\n-) -> torch.Tensor:\n-    \"\"\"Linear layer execution with asynchronous communication and\n-    gradient accumulation fusion in backprop.\n-\n-    This has the option to accumulate the result of backprop\n-    calculation into an existing gradient buffer, preventing the need\n-    to do an additional addition kernel after the gradient\n-    calculation.\n-\n-    Additionally, the tensor parallel all reduce of the input\n-    gradients can be done asynchronously with the calculation of\n-    the weight gradients.\n-\n-    In the case of sequence parallelism, the reduce scatter of the\n-    input gradients is done asynchronously with the calcluation of the\n-    weight gradients.\n-\n-    Use of this module requires that the environment variable\n-    CUDA_DEVICE_MAX_CONNECTIONS=1. There are a few collective\n-    operations, noted in the code, that should be scheduled before\n-    compute kernels to overlap the communication with the computation,\n-    which is necessary for a speedup but not for correctness so that\n-    ordering isn't imposed by the scheduler. Setting\n-    CUDA_DEVICE_MAX_CONNECTIONS=1 forces the kernels to be scheduled\n-    in the order they are called.\n-\n-    Arguments:\n-\n-    input (torch.Tensor required): input like torch.nn.functional.linear\n-\n-    weight (torch.Tensor required): weight like torch.nn.functional.linear\n-\n-    bias (torch.Tensor optional): bias like torch.nn.functional.linear\n-\n-    gradient_accumulation_fusion (bool required): Perform the gradient\n-        accumulation fusion, requires the custom CUDA extension\n-        fused_weight_gradient_mlp_cuda module. To use\n-        gradient_accumulation_fusion you must install APEX with\n-        --cpp_ext and --cuda_ext. For example: \"pip install\n-        --global-option=\\\"--cpp_ext\\\" --global-option=\\\"--cuda_ext .\\\"\n-        \" Note that the extension requires CUDA>=11. Otherwise, you\n-        must turn off gradient accumulation fusion.\"\n-\n-    async_grad_allreduce (bool required): Do the allreduce of input\n-        gradients asyncronously with the computation of weight\n-        gradients. If sequence_parallel_enabled is True, this must be\n-        False, as no all reduce is performed.\n-\n-    sequence_parallel_enabled (bool required): Indicates that sequence\n-        parallelism is used and thus in the forward pass the input is\n-        all gathered, and the backward pass the input gradients are\n-        reduce scattered.\n-    \"\"\"\n-    args = [\n-        input,\n-        weight,\n-        bias,\n-        gradient_accumulation_fusion,\n-        async_grad_allreduce,\n-        sequence_parallel_enabled,\n-    ]\n-\n-    if not linear_with_grad_accumulation_and_async_allreduce.warned:\n-        if os.environ.get('CUDA_DEVICE_MAX_CONNECTIONS') != \"1\":\n-            if sequence_parallel_enabled:\n-                warnings.warn(\n-                    \"When using sequence parallelism it is recommended to set the \"\n-                    \"environment variable CUDA_DEVICE_MAX_CONNECTIONS to 1 for \"\n-                    \"maximum speedup\")\n-                linear_with_grad_accumulation_and_async_allreduce.warned = True\n-\n-            if async_grad_allreduce:\n-                warnings.warn(\n-                    \"When using async grad allreduce it is recommended to set the \"\n-                    \"environment variable CUDA_DEVICE_MAX_CONNECTIONS to 1 for \"\n-                    \"maximum speedup\")\n-                linear_with_grad_accumulation_and_async_allreduce.warned = True\n-\n-    with torch.cuda.amp.autocast(enabled=False):\n-        return LinearWithGradAccumulationAndAsyncCommunication.apply(*args)\n-linear_with_grad_accumulation_and_async_allreduce.warned = False\n-\n class ColumnParallelLinear(torch.nn.Module):\n     \"\"\"Linear layer with column parallelism.\n \n@@ -436,11 +225,8 @@ class ColumnParallelLinear(torch.nn.Module):\n         skip_bias_add: This was added to enable performance optimations where bias\n                        can be fused with other elementwise operations. we skip\n                        adding bias but instead return it.\n-        async_tensor_model_parallel_allreduce:\n         params_dtype:\n         use_cpu_initialization:\n-        gradient_accumulation_fusion:\n-        sequence_parallel_enabled:\n     \"\"\"\n \n     def __init__(self, input_size, output_size, *,\n@@ -448,12 +234,9 @@ class ColumnParallelLinear(torch.nn.Module):\n                  init_method=init.xavier_normal_, stride=1,\n                  keep_master_weight_for_test=False,\n                  skip_bias_add=False,\n-                 async_tensor_model_parallel_allreduce=True,\n                  params_dtype=None,\n                  use_cpu_initialization=False,\n                  perform_initialization=True,\n-                 gradient_accumulation_fusion=False,\n-                 sequence_parallel_enabled: bool = False,\n                  ):\n         super(ColumnParallelLinear, self).__init__()\n \n@@ -506,37 +289,6 @@ class ColumnParallelLinear(torch.nn.Module):\n         else:\n             self.register_parameter('bias', None)\n \n-        self.async_tensor_model_parallel_allreduce = (\n-                async_tensor_model_parallel_allreduce and\n-                world_size > 1)\n-        if sequence_parallel_enabled:\n-            if world_size <= 1:\n-                warnings.warn(\n-                    f\"`sequence_parallel_enabled` is set to `True`, but tensor model parallel size is {world_size}. \"\n-                    f\"Disabling sequence parallel.\"\n-                )\n-                sequence_parallel_enabled = False\n-        self.sequence_parallel_enabled = sequence_parallel_enabled\n-\n-        if gradient_accumulation_fusion:\n-            if not _grad_accum_fusion_available:\n-                raise RuntimeError(\n-                    \"ColumnParallelLinear was called with gradient_accumulation_fusion set \"\n-                    \"to True but the custom CUDA extension fused_weight_gradient_mlp_cuda \"\n-                    \"module is not found. To use gradient_accumulation_fusion you must \"\n-                    \"install APEX with --cpp_ext and --cuda_ext. For example: \"\n-                    \"pip install --global-option=\\\"--cpp_ext\\\" --global-option=\\\"--cuda_ext .\\\" \"\n-                    \"Note that the extension requires CUDA>=11. Otherwise, you must turn off \"\n-                    \"gradient accumulation fusion.\"\n-                )\n-        self.gradient_accumulation_fusion = gradient_accumulation_fusion\n-\n-        if self.async_tensor_model_parallel_allreduce and self.sequence_parallel_enabled:\n-            raise RuntimeError(\n-                \"`async_tensor_model_parallel_allreduce` and `sequence_parallel_enabled` \"\n-                \"cannot be enabled at the same time.\"\n-            )\n-\n \n     def forward(self, input_):\n         \"\"\"Forward of ColumnParallelLinear\n@@ -550,23 +302,11 @@ class ColumnParallelLinear(torch.nn.Module):\n         \"\"\"\n         bias = self.bias if not self.skip_bias_add else None\n \n-        if self.async_tensor_model_parallel_allreduce or \\\n-                self.sequence_parallel_enabled:\n-            input_parallel = input_\n-        else:\n-            input_parallel = copy_to_tensor_model_parallel_region(input_)\n+        input_parallel = copy_to_tensor_model_parallel_region(input_)\n         # Matrix multiply.\n-        output_parallel = linear_with_grad_accumulation_and_async_allreduce(\n-            input=input_parallel,\n-            weight=self.weight,\n-            bias=bias,\n-            gradient_accumulation_fusion=self.gradient_accumulation_fusion,\n-            async_grad_allreduce=self.async_tensor_model_parallel_allreduce,\n-            sequence_parallel_enabled=self.sequence_parallel_enabled,\n-        )\n+        output_parallel = F.linear(input_parallel, self.weight, bias)\n         if self.gather_output:\n             # All-gather across the partitions.\n-            assert not self.sequence_parallel_enabled\n             output = gather_from_tensor_model_parallel_region(output_parallel)\n         else:\n             output = output_parallel\n@@ -607,8 +347,6 @@ class RowParallelLinear(torch.nn.Module):\n         params_dtype:\n         use_cpu_initialization:\n         perform_initialization:\n-        gradient_accumulation_fusion:\n-        sequence_parallel_enabled:\n     \"\"\"\n \n     def __init__(self, input_size, output_size, *,\n@@ -619,8 +357,6 @@ class RowParallelLinear(torch.nn.Module):\n                  params_dtype=None,\n                  use_cpu_initialization=False,\n                  perform_initialization=True,\n-                 gradient_accumulation_fusion=False,\n-                 sequence_parallel_enabled: bool = False,\n                  ):\n         super(RowParallelLinear, self).__init__()\n \n@@ -635,10 +371,6 @@ class RowParallelLinear(torch.nn.Module):\n         world_size = get_tensor_model_parallel_world_size()\n         self.input_size_per_partition = divide(input_size, world_size)\n         self.skip_bias_add = skip_bias_add\n-        self.gradient_accumulation_fusion = gradient_accumulation_fusion\n-        self.sequence_parallel_enabled = sequence_parallel_enabled\n-        if self.sequence_parallel_enabled and not self.input_is_parallel:\n-            raise RuntimeError(\"To enable `sequence_parallel_enabled`, `input_is_parallel` must be `True`\")\n \n         # Parameters.\n         # Note: torch.nn.functional.linear performs XA^T + b and as a result\n@@ -669,7 +401,6 @@ class RowParallelLinear(torch.nn.Module):\n                 self.bias = Parameter(torch.empty(\n                     self.output_size, device=torch.cuda.current_device(),\n                     dtype=params_dtype))\n-            setattr(self.bias, 'sequence_parallel', sequence_parallel_enabled)\n \n             # Always initialize bias to zero.\n             with torch.no_grad():\n@@ -693,23 +424,12 @@ class RowParallelLinear(torch.nn.Module):\n         if self.input_is_parallel:\n             input_parallel = input_\n         else:\n-            assert not self.sequence_parallel_enabled\n             input_parallel = scatter_to_tensor_model_parallel_region(input_)\n         # Matrix multiply.\n-        output_parallel = linear_with_grad_accumulation_and_async_allreduce(\n-            input=input_parallel,\n-            weight=self.weight,\n-            bias=None,\n-            gradient_accumulation_fusion=self.gradient_accumulation_fusion,\n-            async_grad_allreduce=False,\n-            sequence_parallel_enabled=False,\n-        )\n+        output_parallel = F.linear(input_parallel, self.weight)\n \n         # All-reduce across all the partitions.\n-        if self.sequence_parallel_enabled:\n-            output_ = reduce_scatter_to_sequence_parallel_region(output_parallel)\n-        else:\n-            output_ = reduce_from_tensor_model_parallel_region(output_parallel)\n+        output_ = reduce_from_tensor_model_parallel_region(output_parallel)\n         if not self.skip_bias_add:\n             output = output_ + self.bias if self.bias is not None else output_\n             output_bias = None",
      "change_type": "modified",
      "lines_added": 5,
      "lines_removed": 285
    }
  ],
  "affected_apis": [
    "linear_with_grad_accumulation_and_async_allreduce",
    "ColumnParallelLinear.__init__",
    "ColumnParallelLinear.forward",
    "RowParallelLinear.__init__",
    "RowParallelLinear.forward"
  ],
  "summary": {
    "total_files": 3,
    "files_added": 1,
    "files_deleted": 0,
    "files_modified": 2
  },
  "csv_metadata": {
    "category": "model-based",
    "json_has_tests": "FALSE",
    "json_has_benchmarks": "TRUE",
    "is_test_actually_there": "Yes (benchmark_latency, not sure about others)",
    "is_benchmark_actually_there": "",
    "sample_clues": "__init__, benchmark_latency, columnparallellinear"
  }
}