{"instance_id": "/home/ubuntu/OmniPerf-Bench/vllm__repo-20478c4", "model_patch": "diff --git a/vllm/core/block_manager.py b/vllm/core/block_manager.py\nindex 8b089a5..946aae7 100644\n--- a/vllm/core/block_manager.py\n+++ b/vllm/core/block_manager.py\n@@ -197,7 +197,8 @@ class BlockSpaceManager:\n         for logical_idx in range(num_prompt_blocks):\n             if (self.block_sliding_window is not None\n                     and logical_idx >= self.block_sliding_window):\n-                block = block_table[logical_idx % self.block_sliding_window]\n+                idx = logical_idx % self.block_sliding_window\n+                block = block_table[idx]\n             else:\n                 block = self.gpu_allocator.allocate(\n                     seq.hash_of_block(logical_idx),\n@@ -296,7 +297,8 @@ class BlockSpaceManager:\n             # If the last block is now complete, promote it to a full block so\n             # that it can be shared\n             new_block = self._maybe_promote_last_block(seq, last_block)\n-            block_table[-1] = new_block\n+            if new_block is not last_block:\n+                block_table[-1] = new_block\n             return None\n         else:\n             # The last block is shared with other sequences.\n@@ -325,10 +327,12 @@ class BlockSpaceManager:\n         # NOTE: Here, we assume that the physical blocks are only shared by\n         # the sequences in the same group.\n         blocks: Set[PhysicalTokenBlock] = set()\n+        blocks_update = blocks.update\n+        tables = self.block_tables\n         for seq in seq_group.get_seqs():\n             if seq.is_finished():\n                 continue\n-            blocks.update(self.block_tables[seq.seq_id])\n+            blocks_update(tables[seq.seq_id])\n         return list(blocks)\n \n     def can_swap_in(self, seq_group: SequenceGroup) -> bool:\n@@ -406,11 +410,13 @@ class BlockSpaceManager:\n         blocks_to_free = (block_table[-self.block_sliding_window:]\n                           if self.block_sliding_window is not None else\n                           block_table)\n+        gpu_free = self.gpu_allocator.free\n+        cpu_free = self.cpu_allocator.free\n         for block in set(blocks_to_free):\n             if block.device == Device.GPU:\n-                self.gpu_allocator.free(block)\n+                gpu_free(block)\n             else:\n-                self.cpu_allocator.free(block)\n+                cpu_free(block)\n \n     def free(self, seq: Sequence) -> None:\n         if seq.seq_id not in self.block_tables:\ndiff --git a/vllm/core/evictor.py b/vllm/core/evictor.py\nindex 1d81f5a..6da56a1 100644\n--- a/vllm/core/evictor.py\n+++ b/vllm/core/evictor.py\n@@ -64,44 +64,29 @@ class LRUEvictor(Evictor):\n     def __contains__(self, block_hash: int) -> bool:\n         return block_hash in self.free_table\n \n-    # TODO: The performance of this evict function can be optimized further.\n     def evict(self) -> PhysicalTokenBlock:\n-        free_blocks: List[PhysicalTokenBlock] = list(self.free_table.values())\n-        if len(free_blocks) == 0:\n+        items = self.free_table\n+        if len(items) == 0:\n             raise ValueError(\"No usable cache memory left\")\n \n-        # Find lowest timestamp\n-        lowest_timestamp = free_blocks[0].last_accessed\n-        for block in free_blocks:\n-            if block.last_accessed < lowest_timestamp:\n-                lowest_timestamp = block.last_accessed\n-\n-        # Find all blocks with the lowest timestamp\n-        least_recent: List[PhysicalTokenBlock] = []\n-        for block in free_blocks:\n-            if block.last_accessed == lowest_timestamp:\n-                least_recent.append(block)\n-\n-        # Find highest prefix count per block\n-        highest_num_hashed_tokens = 0\n-        for block in least_recent:\n-            if block.num_hashed_tokens > highest_num_hashed_tokens:\n-                highest_num_hashed_tokens = block.num_hashed_tokens\n-\n-        evicted_block: Optional[PhysicalTokenBlock] = None\n-\n-        # Find the first block with the lowest timestamp\n-        for block in least_recent:\n-            if block.num_hashed_tokens == highest_num_hashed_tokens:\n-                evicted_block = block\n-                break\n-\n-        assert evicted_block is not None\n-\n-        del self.free_table[evicted_block.block_hash]\n-\n-        evicted_block.computed = False\n-        return evicted_block\n+        # Single pass selection: pick the block with the smallest last_accessed;\n+        # break ties by choosing the one with the largest num_hashed_tokens.\n+        chosen: Optional[PhysicalTokenBlock] = None\n+        chosen_ts = 0.0\n+        chosen_hashed = -1\n+        for block in items.values():\n+            ts = block.last_accessed\n+            nh = block.num_hashed_tokens\n+            if (chosen is None or ts < chosen_ts or\n+                    (ts == chosen_ts and nh > chosen_hashed)):\n+                chosen = block\n+                chosen_ts = ts\n+                chosen_hashed = nh\n+\n+        assert chosen is not None\n+        del items[chosen.block_hash]\n+        chosen.computed = False\n+        return chosen\n \n     def add(self, block: PhysicalTokenBlock):\n         self.free_table[block.block_hash] = block\n@@ -129,11 +114,12 @@ class RandomEvictor(Evictor):\n         return block_hash in self.free_table\n \n     def evict(self) -> PhysicalTokenBlock:\n-        if len(self.free_table) == 0:\n+        items = self.free_table\n+        if len(items) == 0:\n             raise ValueError(\"No usable cache memory left\")\n-        evicted_block = next(iter(self.free_table.values()))\n+        block_hash, evicted_block = next(iter(items.items()))\n         evicted_block.computed = False\n-        del self.free_table[evicted_block.block_hash]\n+        del items[block_hash]\n         return evicted_block\n \n     def add(self, block: PhysicalTokenBlock):\n", "model_name_or_path": "gpt-5-2025-08-07"}
