{
  "commit_hash": "d7740ea4dcee4ab75d7d6eef723f33cae957b288",
  "pr_url": "https://github.com/vllm-project/vllm/pull/4594",
  "pr_date": null,
  "timeline_text": "Copy link Collaborator rkooo567 commented May 4, 2024 ‚Ä¢ edited Loading Uh oh! There was an error while loading. Please reload this page . get_logprobs happen after sampling, which is the point where GPU <> CPU sync happens. It means overhead from get_logprobs are going to be applied to e2e overhead. I found get_logprobs is pretty inefficient at large batch size, which could be pretty common. On batch size 256, get_logprobs take about 5~6ms. This optimizes the get_logprobs. After this, I found the overhead becomes 2.1ms for get_logprobs. There are 2 optimizations Use non blocking device transfer and call it at the right timing where it can overlap with gpu ops Preselect indices and call tolist() instead of repetitively calling .item (which is much slower) Throughput benchmark (--input-len 256 --output-len 256)\nBefore: Throughput: 23.84 requests/s, 12208.54 tokens/s\nAfter: Throughput: 25.77 requests/s, 13196.11 tokens/s PR Checklist (Click to Expand) Thank you for your contribution to vLLM! Before submitting the pull request, please ensure the PR meets the following criteria. This helps vLLM maintain the code quality and improve the efficiency of the review process. PR Title and Classification Only specific types of PRs will be reviewed. The PR title is prefixed appropriately to indicate the type of change. Please use one of the following: [Bugfix] for bug fixes. [CI/Build] for build or continuous integration improvements. [Doc] for documentation fixes and improvements. [Model] for adding a new model or improving an existing model. Model name should appear in the title. [Frontend] For changes on the vLLM frontend (e.g., OpenAI API server, LLM class, etc.) [Kernel] for changes affecting CUDA kernels or other compute kernels. [Core] for changes in the core vLLM logic (e.g., LLMEngine , AsyncLLMEngine , Scheduler , etc.) [Hardware][Vendor] for hardware-specific changes. Vendor name should appear in the prefix (e.g., [Hardware][AMD] ). [Misc] for PRs that do not fit the above categories. Please use this sparingly. Note: If the PR spans more than one category, please include all relevant prefixes. Code Quality The PR need to meet the following code quality standards: We adhere to Google Python style guide and Google C++ style guide . Pass all linter checks. Please use format.sh to format your code. The code need to be well-documented to ensure future contributors can easily understand the code. Include sufficient tests to ensure the project to stay correct and robust. This includes both unit tests and integration tests. Please add documentation to docs/source/ if the PR modifies the user-facing behaviors of vLLM. It helps vLLM user understand and utilize the new features or changes. Notes for Large Changes Please keep the changes as concise as possible. For major architectural changes (>500 LOC excluding kernel/data/config/test), we would expect a GitHub issue (RFC) discussing the technical design and justification. Otherwise, we will tag it with rfc-required and might not go through the PR. What to Expect for the Reviews The goal of the vLLM team is to be a transparent reviewing machine . We would like to make the review process transparent and efficient and make sure no contributor feel confused or frustrated. However, the vLLM team is small, so we need to prioritize some PRs over others. Here is what you can expect from the review process: After the PR is submitted, the PR will be assigned to a reviewer. Every reviewer will pick up the PRs based on their expertise and availability. After the PR is assigned, the reviewer will provide status update every 2-3 days. If the PR is not reviewed within 7 days, please feel free to ping the reviewer or the vLLM team. After the review, the reviewer will put an action-required label on the PR if there are changes required. The contributor should address the comments and ping the reviewer to re-review the PR. Please respond to all comments within a reasonable time frame. If a comment isn't clear or you disagree with a suggestion, feel free to ask for clarification or discuss the suggestion. Thank You Finally, thank you for taking the time to read these guidelines and for your interest in contributing to vLLM. Your contributions make vLLM a great tool for everyone! Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions rkooo567 added 4 commits May 3, 2024 20:49 working 30d6fe4 Merge branch 'main' into logprob-opt 65f9dde . 9205244 done 8ad363e rkooo567 changed the title [WIP] Optimize sampler get_logprobs [Core] Optimize sampler get_logprobs May 7, 2024 rkooo567 commented May 7, 2024 View reviewed changes vllm/model_executor/layers/sampler.py Outdated @@ -769,27 +769,24 @@ def _get_logprobs( selected_logprobs = logprobs[[ query_indices_gpu, next_token_ids_gpu, ]] ]] .to('cpu', non_blocking=True) Copy link Collaborator Author rkooo567 May 4, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment this can overlap device transfer with torch.topk Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions done 2177a7a Yard1 approved these changes May 7, 2024 View reviewed changes Copy link Collaborator Yard1 left a comment There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment LGTM Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . ‚ù§Ô∏è 1 rkooo567 reacted with heart emoji All reactions ‚ù§Ô∏è 1 reaction Copy link Collaborator Author rkooo567 commented May 7, 2024 thanks for the quick review @Yard1 ! All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . rkooo567 added 2 commits May 6, 2024 22:44 done d384dae . 2b2035a Qubitium reviewed May 7, 2024 View reviewed changes vllm/model_executor/layers/sampler.py Outdated # Find prompt/sample logprobs. prompt_logprobs_per_seq_group: List[Optional[PromptLogprobs]] = [] sample_logprobs_per_seq_group: List[SampleLogprobs] = [] top_logprob_idx = 0 selected_logprobs_idx = 0 # Make sure non-blocking .to(\"cpu\", non_blocking=True) is finished assert selected_logprobs.shape[0] == ranks.shape[0] Copy link Contributor Qubitium May 7, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment @rkooo567 Do we still need this assert since non-blocking transfer code is removed? Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions Copy link Collaborator Author rkooo567 May 7, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment Thanks for catching! we don't need comments, but assert is kind of still needed. Removed the comment Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . üëç 1 Qubitium reacted with thumbs up emoji All reactions üëç 1 reaction rkooo567 commented May 7, 2024 View reviewed changes Copy link Collaborator Author rkooo567 left a comment There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment Update; non_blocking=True for GPU -> CPU doesn't guarantee to synchronize when tolist() is called, so it is not safe. I used the blocking op instead. This decreases the perf improvement a bit (0.5~ish) Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions vllm/model_executor/layers/sampler.py Outdated # Find prompt/sample logprobs. prompt_logprobs_per_seq_group: List[Optional[PromptLogprobs]] = [] sample_logprobs_per_seq_group: List[SampleLogprobs] = [] top_logprob_idx = 0 selected_logprobs_idx = 0 # Make sure non-blocking .to(\"cpu\", non_blocking=True) is finished assert selected_logprobs.shape[0] == ranks.shape[0] Copy link Collaborator Author rkooo567 May 7, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment Thanks for catching! we don't need comments, but assert is kind of still needed. Removed the comment Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . üëç 1 Qubitium reacted with thumbs up emoji All reactions üëç 1 reaction done a964163 Yard1 reviewed May 7, 2024 View reviewed changes vllm/model_executor/layers/sampler.py Outdated Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . . 88c0567 simon-mo merged commit d7740ea into vllm-project : main May 8, 2024 z103cb pushed a commit\n        to z103cb/opendatahub_vllm\n      that referenced\n      this pull request May 9, 2024 [Core] Optimize sampler get_logprobs ( vllm-project#4594 ) 4ae5247 Copy link davidthomas426 commented May 9, 2024 Update; non_blocking=True for GPU -> CPU doesn't guarantee to synchronize when tolist() is called, so it is not safe. I used the blocking op instead. This decreases the perf improvement a bit (0.5~ish) As an alternative, you could use a cuda stream for this and do a stream synchronize before the tolist, or just forget the separate cuda stream and just use a full torch cuda synchronize if that wouldn't create a performance issue. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . robertgshaw2-redhat pushed a commit\n        to neuralmagic/nm-vllm\n      that referenced\n      this pull request May 19, 2024 [Core] Optimize sampler get_logprobs ( vllm-project#4594 ) 43bc7e9 dtrifiro pushed a commit\n        to dtrifiro/vllm\n      that referenced\n      this pull request May 21, 2024 [Core] Optimize sampler get_logprobs ( vllm-project#4594 ) 9e4b2e2 Sign up for free to join this conversation on GitHub .\n    Already have an account? Sign in to comment",
  "timeline_extracted_at": "2025-09-07 17:49:00",
  "has_lm_eval": false,
  "has_performance": true,
  "has_serving": true,
  "has_general_test": true,
  "test_details": "PERF: Throughput, Throughput, Throughput | SERVING: API server, OpenAI API server, Frontend | TEST: test, CI, continuous integration",
  "analysis_extracted_at": "2025-09-07 17:49:00",
  "models": [
    "N/A"
  ],
  "lm_eval_commands": null,
  "perf_command": null,
  "commit_subject": "[Core] Optimize sampler get_logprobs (#4594)",
  "commit_message": "[Core] Optimize sampler get_logprobs (#4594)",
  "commit_date": "2024-05-08T08:42:28-07:00",
  "files_changed": [
    "vllm/model_executor/layers/sampler.py"
  ],
  "functions_changed": [],
  "stats": {
    "num_test_files": 0,
    "num_non_test_files": 1,
    "only_test_files": 0,
    "only_non_test_files": 1,
    "num_files": 1,
    "num_hunks": 3,
    "num_edited_lines": 117,
    "num_non_test_edited_lines": 117,
    "commit_year": 2024
  },
  "diff_text": "diff --git a/vllm/model_executor/layers/sampler.py b/vllm/model_executor/layers/sampler.py\nindex 1f19d2053..e52e350d2 100644\n--- a/vllm/model_executor/layers/sampler.py\n+++ b/vllm/model_executor/layers/sampler.py\n@@ -782,13 +782,14 @@ def _get_logprobs(\n         top_logprobs, top_token_ids = torch.topk(logprobs,\n                                                  largest_num_logprobs,\n                                                  dim=-1)\n-        top_logprobs = top_logprobs.cpu()\n-        top_token_ids = top_token_ids.cpu()\n     else:\n         top_logprobs, top_token_ids = None, None\n \n-    selected_logprobs = selected_logprobs.cpu()\n-    ranks = ranks.cpu()\n+    selected_logprobs = selected_logprobs.to('cpu')\n+    ranks = ranks.to('cpu')\n+    if top_logprobs is not None and top_token_ids is not None:\n+        top_logprobs = top_logprobs.to('cpu')\n+        top_token_ids = top_token_ids.to('cpu')\n \n     # Find prompt/sample logprobs.\n     prompt_logprobs_per_seq_group: List[Optional[PromptLogprobs]] = []\n@@ -828,37 +829,48 @@ def _get_prompt_logprob_if_needed(\n \n     # Find prompt logprobs\n     prompt_logprobs: Optional[PromptLogprobs] = None\n-    if (is_prompt and sampling_params.prompt_logprobs is not None):\n+    if is_prompt and sampling_params.prompt_logprobs is not None:\n         prompt_logprobs = []\n         num_logprobs = sampling_params.prompt_logprobs\n         next_prompt_tokens = _get_next_prompt_tokens(seq_group)\n-        for token_id in next_prompt_tokens:\n+        # Pre-select indexes and create a list. It is faster than calling .item\n+        # repetitively.\n+        selected_logprob_items = selected_logprobs[\n+            selected_logprobs_idx:selected_logprobs_idx +\n+            len(next_prompt_tokens)].tolist()\n+        rank_items = ranks[selected_logprobs_idx:selected_logprobs_idx +\n+                           len(next_prompt_tokens)].tolist()\n+\n+        for idx, token_id in enumerate(next_prompt_tokens):\n             # Calculate the prompt logprob of the real prompt tokens.\n-            # Use tuple here for performance (to use to_list()).\n             # {token_id: (logprob, rank_from_vocab)}\n             prompt_logprobs_dict: Dict[int, Tuple[float, int]] = {\n-                token_id: (selected_logprobs[selected_logprobs_idx].item(),\n-                           ranks[selected_logprobs_idx].item())\n+                token_id: (selected_logprob_items[idx], rank_items[idx])\n             }\n \n             # Add top K prompt logprobs along with its rank.\n             if num_logprobs > 0:\n-                prompt_logprobs_dict.update(\n-                    zip(\n-                        top_token_ids[top_logprob_idx, :num_logprobs].tolist(),\n-                        zip(\n-                            top_logprobs[\n-                                top_logprob_idx, :num_logprobs].tolist(),\n-                            # This is ranks. Since top_logprob is sorted,\n-                            # we can just use a range here.\n-                            range(1, num_logprobs + 1))))\n+                top_ids = top_token_ids[\n+                    top_logprob_idx, :num_logprobs].tolist()\n+                top_probs = top_logprobs[\n+                    top_logprob_idx, :num_logprobs].tolist()\n+                # Top K is already sorted by rank, so we can use 1 ~\n+                # num_logprobs + 1 for rank.\n+                top_ranks = range(1, num_logprobs + 1)\n+                prompt_logprobs_dict.update({\n+                    top_id: (top_prob, rank)\n+                    for top_id, top_prob, rank in zip(top_ids, top_probs,\n+                                                      top_ranks)\n+                })\n             prompt_logprobs.append({\n                 token_id: Logprob(*logprob_and_rank)\n                 for token_id, logprob_and_rank in prompt_logprobs_dict.items()\n             })\n             # + 1 to go to the next prompt token.\n             top_logprob_idx += 1\n-            selected_logprobs_idx += 1\n+\n+        # + len(next_prompt_tokens) to go to the next prompt.\n+        selected_logprobs_idx += len(next_prompt_tokens)\n     return prompt_logprobs, top_logprob_idx, selected_logprobs_idx\n \n \n@@ -874,47 +886,54 @@ def _get_sampled_logprob_if_needed(\n ):\n     \"\"\"Compute the sample logprob if needed.\"\"\"\n     seq_ids = seq_group.seq_ids\n-    num_logprobs = seq_group.sampling_params.logprobs\n-    if num_logprobs is None:\n-        num_logprobs = 0\n+    num_logprobs = seq_group.sampling_params.logprobs or 0\n     sampled_logprobs: SampleLogprobs = []\n     next_token_ids, parent_seq_ids = sample_result\n \n     if seq_group.do_sample:\n         assert len(next_token_ids) > 0\n-        for (next_token_id, parent_id) in zip(next_token_ids, parent_seq_ids):\n-            # Calculate the sample logprob of the real sampled tokens.\n-            # Use tuple here for performance (to use to_list()).\n-            # token_id: (logprob, rank_from_vocab)\n-            sampled_logprobs_dict: Dict[int, Tuple[float, int]] = {\n-                next_token_id:\n-                (selected_logprobs[selected_logprobs_idx].item(),\n-                 ranks[selected_logprobs_idx].item())\n+        # Pre-select items from tensor. tolist() is faster than repetitive\n+        # `.item()` calls.\n+        selected_logprob_items = selected_logprobs[\n+            selected_logprobs_idx:selected_logprobs_idx +\n+            len(next_token_ids)].tolist()\n+        rank_items = ranks[selected_logprobs_idx:selected_logprobs_idx +\n+                           len(next_token_ids)].tolist()\n+        for idx, (next_token_id,\n+                  parent_id) in enumerate(zip(next_token_ids, parent_seq_ids)):\n+            # Get the logprob of a sampled token.\n+            sampled_logprobs_dict = {\n+                next_token_id: (selected_logprob_items[idx], rank_items[idx])\n             }\n-            # +1 to go to the next sampled token. Note that\n-            # selected_logprobs can contain duplicates unlike top_logprobs\n-            # when beam search is enabled.\n-            selected_logprobs_idx += 1\n-\n-            # Second, add top K logprobs along with its rank.\n-            if num_logprobs >= 0:\n-                sampled_logprobs_dict.update(\n-                    zip(\n-                        top_token_ids[top_logprob_idx +\n-                                      parent_id, :num_logprobs].tolist(),\n-                        zip(\n-                            top_logprobs[top_logprob_idx +\n-                                         parent_id, :num_logprobs].tolist(),\n-                            # This is rank. Since top_logprob is sorted, we\n-                            # can just use a range here.\n-                            range(1, num_logprobs + 1))))\n+            # Get top K logprobs.\n+            if num_logprobs > 0:\n+                top_ids = top_token_ids[top_logprob_idx +\n+                                        parent_id, :num_logprobs].tolist()\n+                top_probs = top_logprobs[top_logprob_idx +\n+                                         parent_id, :num_logprobs].tolist()\n+                # Top K is already sorted by rank, so we can use 1 ~\n+                # num_logprobs + 1 for rank.\n+                top_ranks = range(1, num_logprobs + 1)\n+                sampled_logprobs_dict.update({\n+                    top_id: (top_prob, rank)\n+                    for top_id, top_prob, rank in zip(top_ids, top_probs,\n+                                                      top_ranks)\n+                })\n+\n             sampled_logprobs.append({\n                 token_id: Logprob(*logprob_and_rank)\n                 for token_id, logprob_and_rank in\n                 sampled_logprobs_dict.items()\n             })\n-        # There are len(seq_ids) number of sampled tokens for the current\n-        # sequence group in top_logprobs. Jump to the next seq_group.\n+\n+        # NOTE: This part of code is not intuitive. `selected_logprobs` include\n+        # logprobs for the current step, which has len(next_token_ids) tokens\n+        # per sequence group. `logprobs` includes logprobs from the previous\n+        # steps, which has len(seq_ids) tokens per sequence group.\n+\n+        # Iterate to the next sequence group in a batch.\n+        selected_logprobs_idx += len(next_token_ids)\n+        # Iterate to the next sequence group in a batch.\n         top_logprob_idx += len(seq_ids)\n     return sampled_logprobs, top_logprob_idx, selected_logprobs_idx",
  "apis": [
    "None"
  ],
  "affected_paths": [
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/v1/sample/sampler.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/model_executor/layers/sampler.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/v1/sample/tpu/sampler.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/engine/llm_engine.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/v1/engine/llm_engine.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/entrypoints/llm.py"
  ],
  "repo_path": "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm",
  "llm_reason": "The commit modifies a core module (sampler.py) and changes the way tensors are transferred to CPU by replacing repeated .cpu() calls with .to('cpu') operations, and it pre-selects items from tensors to avoid repeated .item() calls. These changes aim to reduce overhead in log probability calculations, thereby boosting performance. The modifications are not simple refactoring or bug fixes but performance-related optimizations on a high-level API that runs on CPU and can be tested without specialized hardware.",
  "llm_api_reason": "This commit optimizes how log‚Äêprobabilities are gathered during sampling in the model executor‚Äôs sampler layer. In particular, it replaces direct .cpu() calls with .to(\"cpu\"), adds conditional handling for top‚Äëk values, and batches tensor-to-list conversions (thus reducing repetitive .item() calls) in the internal helper functions (_get_logprobs, _get_prompt_logprob_if_needed, and _get_sampled_logprob_if_needed). These changes improve performance without modifying the external API or interface of the sampler."
}