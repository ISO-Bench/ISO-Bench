{
  "commit_hash": "3a243095e5e7b655b63ab08fbd5936cb40850415",
  "pr_url": "https://github.com/vllm-project/vllm/pull/3623",
  "pr_date": "2024-03-25",
  "timeline_text": "Copy link Collaborator Yard1 commented Mar 25, 2024 Small tweak to CPU<->GPU comms in Sampler's _get_ranks (not a major improvement, just cleanup). PR Checklist (Click to Expand) Thank you for your contribution to vLLM! Before submitting the pull request, please ensure the PR meets the following criteria. This helps vLLM maintain the code quality and improve the efficiency of the review process. PR Title and Classification Only specific types of PRs will be reviewed. The PR title is prefixed appropriately to indicate the type of change. Please use one of the following: [Bugfix] for bug fixes. [CI/Build] for build or continuous integration improvements. [Doc] for documentation fixes and improvements. [Model] for adding a new model or improving an existing model. Model name should appear in the title. [Frontend] For changes on the vLLM frontend (e.g., OpenAI API server, LLM class, etc.) [Kernel] for changes affecting CUDA kernels or other compute kernels. [Core] for changes in the core vLLM logic (e.g., LLMEngine , AsyncLLMEngine , Scheduler , etc.) [Hardware][Vendor] for hardware-specific changes. Vendor name should appear in the prefix (e.g., [Hardware][AMD] ). [Misc] for PRs that do not fit the above categories. Please use this sparingly. Note: If the PR spans more than one category, please include all relevant prefixes. Code Quality The PR need to meet the following code quality standards: We adhere to Google Python style guide and Google C++ style guide . Pass all linter checks. Please use format.sh to format your code. The code need to be well-documented to ensure future contributors can easily understand the code. Include sufficient tests to ensure the project to stay correct and robust. This includes both unit tests and integration tests. Please add documentation to docs/source/ if the PR modifies the user-facing behaviors of vLLM. It helps vLLM user understand and utilize the new features or changes. Notes for Large Changes Please keep the changes as concise as possible. For major architectural changes (>500 LOC excluding kernel/data/config/test), we would expect a GitHub issue (RFC) discussing the technical design and justification. Otherwise, we will tag it with rfc-required and might not go through the PR. What to Expect for the Reviews The goal of the vLLM team is to be a transparent reviewing machine . We would like to make the review process transparent and efficient and make sure no contributor feel confused or frustrated. However, the vLLM team is small, so we need to prioritize some PRs over others. Here is what you can expect from the review process: After the PR is submitted, the PR will be assigned to a reviewer. Every reviewer will pick up the PRs based on their expertise and availability. After the PR is assigned, the reviewer will provide status update every 2-3 days. If the PR is not reviewed within 7 days, please feel free to ping the reviewer or the vLLM team. After the review, the reviewer will put an action-required label on the PR if there are changes required. The contributor should address the comments and ping the reviewer to re-review the PR. Please respond to all comments within a reasonable time frame. If a comment isn't clear or you disagree with a suggestion, feel free to ask for clarification or discuss the suggestion. Thank You Finally, thank you for taking the time to read these guidelines and for your interest in contributing to vLLM. Your contributions make vLLM a great tool for everyone! Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions Optimize _get_ranks in Sampler c8f8eb7 Yard1 requested review from esmeetu , zhuohan123 and simon-mo March 25, 2024 21:28 njhill approved these changes Mar 25, 2024 View reviewed changes Copy link Member njhill left a comment There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment Nice! I didn't realize that you could do this particular kind of indexing with tensors. Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions WoosukKwon merged commit 3a24309 into vllm-project : main Mar 25, 2024 Yard1 deleted the optimize_get_ranks branch March 25, 2024 23:49 xjpang pushed a commit\n        to xjpang/vllm\n      that referenced\n      this pull request Mar 31, 2024 Optimize _get_ranks in Sampler ( vllm-project#3623 ) 19d7628 dtrifiro mentioned this pull request May 15, 2024 bump ubi base image tag opendatahub-io/vllm#24 Merged Sign up for free to join this conversation on GitHub .\n    Already have an account? Sign in to comment",
  "timeline_extracted_at": "2025-09-07 17:49:15",
  "has_lm_eval": false,
  "has_performance": true,
  "has_serving": true,
  "has_general_test": true,
  "test_details": "PERF: improvement | SERVING: API server, OpenAI API server, Frontend | TEST: test, CI, continuous integration",
  "analysis_extracted_at": "2025-09-07 17:49:15",
  "models": [
    "N/A"
  ],
  "lm_eval_commands": null,
  "perf_command": null,
  "commit_subject": "Optimize `_get_ranks` in Sampler (#3623)",
  "commit_message": "Optimize `_get_ranks` in Sampler (#3623)",
  "commit_date": "2024-03-25T16:03:02-07:00",
  "files_changed": [
    "vllm/model_executor/layers/sampler.py"
  ],
  "functions_changed": [],
  "stats": {
    "num_test_files": 0,
    "num_non_test_files": 1,
    "only_test_files": 0,
    "only_non_test_files": 1,
    "num_files": 1,
    "num_hunks": 3,
    "num_edited_lines": 27,
    "num_non_test_edited_lines": 27,
    "commit_year": 2024
  },
  "diff_text": "diff --git a/vllm/model_executor/layers/sampler.py b/vllm/model_executor/layers/sampler.py\nindex d07527304..06135192c 100644\n--- a/vllm/model_executor/layers/sampler.py\n+++ b/vllm/model_executor/layers/sampler.py\n@@ -506,22 +506,23 @@ def _sample(\n     #                                   sampling_tensors)\n \n \n-def _get_ranks(x: torch.Tensor, indices: List[int]) -> torch.Tensor:\n+def _get_ranks(x: torch.Tensor, indices: torch.Tensor) -> torch.Tensor:\n     \"\"\"\n     This function calculates the ranks of the chosen tokens in a logprob tensor.\n \n     Args:\n         x (torch.Tensor): 2D logprob tensor of shape (N, M)\n                         where N is the no. of tokens and M is the vocab dim.\n-        indices (List[int]): List of chosen token indices.\n+        indices (torch.Tensor): List of chosen token indices.\n \n     Returns:\n         torch.Tensor: 1D tensor of shape (N,) where N is the no. of tokens.\n                     Each element in the returned tensor represents the rank \n                     of the chosen token in the input logprob tensor.\n     \"\"\"\n-    vals = x[range(len(x)), indices]\n-    return (x > vals[:, None]).long().sum(1) + 1\n+    vals = x[torch.arange(0, len(x), device=x.device, dtype=indices.dtype),\n+             indices]\n+    return (x > vals[:, None]).long().sum(1).add_(1)\n \n \n def _get_logprobs(\n@@ -561,12 +562,21 @@ def _get_logprobs(\n         sample_idx += num_parent_seqs\n     assert sample_idx == logprobs.size(0)\n \n+    batched_logprobs_query_seq_indices_gpu = torch.tensor(\n+        batched_logprobs_query_seq_indices, device=logprobs.device)\n+    batched_logprobs_query_token_indices_gpu = torch.tensor(\n+        batched_logprobs_query_token_indices, device=logprobs.device)\n+\n     # Batched query for logprobs of selected token\n     batched_logprobs_query_result = logprobs[[\n-        batched_logprobs_query_seq_indices,\n-        batched_logprobs_query_token_indices\n+        batched_logprobs_query_seq_indices_gpu,\n+        batched_logprobs_query_token_indices_gpu\n     ]]\n \n+    batched_ranks_query_result = _get_ranks(\n+        logprobs[batched_logprobs_query_seq_indices_gpu],\n+        batched_logprobs_query_token_indices_gpu)\n+\n     # Batched query for logprobs of topk tokens\n     if largest_num_logprobs > 0:\n         top_logprobs, top_token_ids = torch.topk(logprobs,\n@@ -578,10 +588,7 @@ def _get_logprobs(\n         top_logprobs, top_token_ids = None, None\n \n     batched_logprobs_query_result = batched_logprobs_query_result.cpu()\n-\n-    batched_ranks_query_result = _get_ranks(\n-        logprobs[batched_logprobs_query_seq_indices],\n-        batched_logprobs_query_token_indices)\n+    batched_ranks_query_result = batched_ranks_query_result.cpu()\n \n     # Gather results\n     result_prompt_logprobs: List[Optional[PromptLogprobs]] = []",
  "apis": [
    "vllm.model_executor.layers.sampler._get_ranks",
    "vllm.model_executor.layers.sampler._get_logprobs"
  ],
  "affected_paths": [
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/v1/sample/sampler.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/model_executor/layers/sampler.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/v1/sample/tpu/sampler.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/engine/llm_engine.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/v1/engine/llm_engine.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/entrypoints/llm.py"
  ],
  "repo_path": "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm",
  "llm_reason": "The commit modifies a source code file and changes implementations in the _get_ranks and _get_logprobs functions to improve efficiency. It converts a Python list into a tensor, uses in-place operations (add_), and creates tensors on the appropriate device to likely reduce overhead. These changes are not just cosmetic or simple refactoring; they aim to enhance performance on CPU by optimizing the computational workflow. Despite the commit message mentioning \"Optimize\", the modifications are clearly performance-related rather than being a bug fix or adding a new feature.",
  "llm_api_reason": "This commit optimizes the token ranking computation within the sampler layer. The helper function _get_ranks was refactored to use torch.arange with proper device and dtype parameters instead of Python’s range, ensuring better compatibility with the input tensor’s device. In addition, the batched querying in _get_logprobs has been updated to build GPU tensors for the sequence and token indices before passing them to _get_ranks, reducing unnecessary data transfers and improving performance."
}