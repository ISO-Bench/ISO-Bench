{
  "commit_hash": "2a052011ca473a9dc8160f3daa1f5f63a2ad1fe3",
  "pr_url": "https://github.com/vllm-project/vllm/pull/4527",
  "pr_date": "2024-05-04",
  "timeline_text": "Copy link Member mgoin commented May 1, 2024 • edited by pcmoritz Loading Uh oh! There was an error while loading. Please reload this page . Follow on to #4332 to enable FP8 checkpoint loading for Mixtral and supersedes #4436 . This PR enables the following checkpoint loading features for Mixtral: Supports loading fp8 checkpoints for Mixtral, such as this \"nm-testing/Mixtral-8x7B-Instruct-v0.1-FP8\" test model Supports static or dynamic activation quantization with static weight quantization (all per tensor) Supports different scales for each expert weight Supports Fp8 in QKV layer Notes: The Expert Gate/Router always runs at half / full precision for now. If there are different weight scales between QKV layer (for separate QKV weights), they are re-quantized using layer.weight_scale.max() so we can have a single gemm for performance. Future work: cutlass kernels for separate QKV weight scales support memory compression from loading fp16 checkpoints and dynamically quantizing to fp8 (blocked on weight loader refactor) generalize MoE implementation to apply to other MoE models Smoke test output: python test-mixtral-fp8.py \nWARNING 05-03 01:42:29 config.py:187] fp8 quantization is not fully optimized yet. The speed can be slower than non-quantized models.\nINFO 05-03 01:42:29 llm_engine.py:100] Initializing an LLM engine (v0.4.1) with config: model='nm-testing/Mixtral-8x7B-Instruct-v0.1-FP8', speculative_config=None, tokenizer='nm-testing/Mixtral-8x7B-Instruct-v0.1-FP8', skip_tokenizer_init=False, tokenizer_mode=auto, revision=None, tokenizer_revision=None, trust_remote_code=False, dtype=torch.bfloat16, max_seq_len=32768, download_dir=None, load_format=LoadFormat.AUTO, tensor_parallel_size=1, disable_custom_all_reduce=False, quantization=fp8, enforce_eager=False, kv_cache_dtype=auto, quantization_param_path=None, device_config=cuda, decoding_config=DecodingConfig(guided_decoding_backend='outlines'), seed=0)\nINFO 05-03 01:42:29 utils.py:623] Found nccl from library /home/paperspace/.config/vllm/nccl/cu12/libnccl.so.2.18.1\nINFO 05-03 01:42:30 selector.py:75] Cannot use FlashAttention-2 backend because the flash_attn package is not found. Please install it for better performance.\nINFO 05-03 01:42:30 selector.py:31] Using XFormers backend.\nWARNING 05-03 01:42:31 fp8.py:29] Detected fp8 checkpoint. Please note that the format is experimental and subject to change.\nINFO 05-03 01:42:31 weight_utils.py:199] Using model weights format ['*.safetensors']\nWARNING 05-03 01:42:41 utils.py:428] Found act_scales that are not equal for fp8 MoE layer. Using the maximum across experts for each layer. \nINFO 05-03 01:42:42 model_runner.py:172] Loading model weights took 43.7487 GB\nINFO 05-03 01:42:51 gpu_executor.py:114] # GPU blocks: 9689, # CPU blocks: 2048\nINFO 05-03 01:42:53 model_runner.py:872] Capturing the model for CUDA graphs. This may lead to unexpected consequences if the model is not static. To run the model in eager mode, set 'enforce_eager=True' or use '--enforce-eager' in the CLI.\nINFO 05-03 01:42:53 model_runner.py:876] CUDA graphs can take additional 1~3 GiB memory per GPU. If you are running out of memory, consider decreasing `gpu_memory_utilization` or enforcing eager mode. You can also reduce the `max_num_seqs` as needed to decrease memory usage.\nINFO 05-03 01:43:00 model_runner.py:953] Graph capturing finished in 7 secs.\nProcessed prompts: 100%|█████████████████████████████████████████████████████████████████████████████████████████████| 4/4 [00:00<00:00,  4.30it/s]\nPrompt: 'Hello, my name is', Generated text: ' Alyssa and I am a 17-year-old girl'\nPrompt: 'The president of the United States is', Generated text: ' the head of the executive branch of the United States government and is the highest political'\nPrompt: 'The capital of France is', Generated text: \" a beautiful and historic city that is home to some of the world's most\"\nPrompt: 'The future of AI is', Generated text: ' a rapidly evolving field, with new developments and innovations happening all the time' PR Checklist (Click to Expand) Thank you for your contribution to vLLM! Before submitting the pull request, please ensure the PR meets the following criteria. This helps vLLM maintain the code quality and improve the efficiency of the review process. PR Title and Classification Only specific types of PRs will be reviewed. The PR title is prefixed appropriately to indicate the type of change. Please use one of the following: [Bugfix] for bug fixes. [CI/Build] for build or continuous integration improvements. [Doc] for documentation fixes and improvements. [Model] for adding a new model or improving an existing model. Model name should appear in the title. [Frontend] For changes on the vLLM frontend (e.g., OpenAI API server, LLM class, etc.) [Kernel] for changes affecting CUDA kernels or other compute kernels. [Core] for changes in the core vLLM logic (e.g., LLMEngine , AsyncLLMEngine , Scheduler , etc.) [Hardware][Vendor] for hardware-specific changes. Vendor name should appear in the prefix (e.g., [Hardware][AMD] ). [Misc] for PRs that do not fit the above categories. Please use this sparingly. Note: If the PR spans more than one category, please include all relevant prefixes. Code Quality The PR need to meet the following code quality standards: We adhere to Google Python style guide and Google C++ style guide . Pass all linter checks. Please use format.sh to format your code. The code need to be well-documented to ensure future contributors can easily understand the code. Include sufficient tests to ensure the project to stay correct and robust. This includes both unit tests and integration tests. Please add documentation to docs/source/ if the PR modifies the user-facing behaviors of vLLM. It helps vLLM user understand and utilize the new features or changes. Notes for Large Changes Please keep the changes as concise as possible. For major architectural changes (>500 LOC excluding kernel/data/config/test), we would expect a GitHub issue (RFC) discussing the technical design and justification. Otherwise, we will tag it with rfc-required and might not go through the PR. What to Expect for the Reviews The goal of the vLLM team is to be a transparent reviewing machine . We would like to make the review process transparent and efficient and make sure no contributor feel confused or frustrated. However, the vLLM team is small, so we need to prioritize some PRs over others. Here is what you can expect from the review process: After the PR is submitted, the PR will be assigned to a reviewer. Every reviewer will pick up the PRs based on their expertise and availability. After the PR is assigned, the reviewer will provide status update every 2-3 days. If the PR is not reviewed within 7 days, please feel free to ping the reviewer or the vLLM team. After the review, the reviewer will put an action-required label on the PR if there are changes required. The contributor should address the comments and ping the reviewer to re-review the PR. Please respond to all comments within a reasonable time frame. If a comment isn't clear or you disagree with a suggestion, feel free to ask for clarification or discuss the suggestion. Thank You Finally, thank you for taking the time to read these guidelines and for your interest in contributing to vLLM. Your contributions make vLLM a great tool for everyone! Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions mgoin added 3 commits May 1, 2024 14:16 [Kernel] Support Fp8 Checkpoints for Mixtral (Dynamic + Static … b5002df Activations) Cleanup 4378f4f Fix circular import with all_close_1d ce2051a robertgshaw2-redhat mentioned this pull request May 1, 2024 [Kernel] Support Fp8 Checkpoints for Mixtral (Dynamic + Static) #4436 Closed comaniac approved these changes May 1, 2024 View reviewed changes Copy link Collaborator comaniac left a comment There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment LGTM Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions vllm/model_executor/models/mixtral.py Outdated Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . robertgshaw2-redhat mentioned this pull request May 1, 2024 v0.4.2 Release Tracker #4505 Closed pcmoritz reviewed May 1, 2024 View reviewed changes vllm/model_executor/models/mixtral.py Outdated Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . pcmoritz reviewed May 1, 2024 View reviewed changes vllm/model_executor/models/mixtral.py Show resolved Hide resolved Uh oh! There was an error while loading. Please reload this page . mgoin added 3 commits May 2, 2024 14:53 Merge branch 'main' into fp8-mixtral-serialization 1dc1d2d Address review 56ff89c Fix test 66febef pcmoritz reviewed May 4, 2024 View reviewed changes vllm/model_executor/models/mixtral.py # ACT_SCALE (for fp8) if quant_config.activation_scheme == \"static\": if not quant_config.is_checkpoint_fp8_serialized: Copy link Collaborator pcmoritz May 4, 2024 • edited Loading Uh oh! There was an error while loading. Please reload this page . There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment This needs to be removed -- we do support activation scales for FP16 checkpoints too (same as kv store scales going forward) Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions Copy link Collaborator pcmoritz May 4, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment Ah never mind, I misunderstood -- FP16 checkpoints with \"quantization\": \"fp8\" are also considered fp8 serialized (this is pretty confusing) Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions pcmoritz approved these changes May 4, 2024 View reviewed changes pcmoritz merged commit 2a05201 into vllm-project : main May 4, 2024 robertgshaw2-redhat pushed a commit\n        to neuralmagic/nm-vllm\n      that referenced\n      this pull request May 6, 2024 [Kernel] Support MoE Fp8 Checkpoints for Mixtral (Static Weights with… … 55dd119 … Dynamic/Static Activations) ( vllm-project#4527 )\n\nFollow on to vllm-project#4332 to enable FP8 checkpoint loading for Mixtral and supersedes vllm-project#4436 .\n\nThis PR enables the following checkpoint loading features for Mixtral:\n\nSupports loading fp8 checkpoints for Mixtral, such as this \"nm-testing/Mixtral-8x7B-Instruct-v0.1-FP8\" test model\nSupports static or dynamic activation quantization with static weight quantization (all per tensor)\nSupports different scales for each expert weight\nSupports Fp8 in QKV layer\nNotes:\n\nThe Expert Gate/Router always runs at half / full precision for now.\nIf there are different weight scales between QKV layer (for separate QKV weights), they are re-quantized using layer.weight_scale.max() so we can have a single gemm for performance. z103cb pushed a commit\n        to z103cb/opendatahub_vllm\n      that referenced\n      this pull request May 7, 2024 [Kernel] Support MoE Fp8 Checkpoints for Mixtral (Static Weights with… … ba2be94 … Dynamic/Static Activations) ( vllm-project#4527 )\n\nFollow on to vllm-project#4332 to enable FP8 checkpoint loading for Mixtral and supersedes vllm-project#4436 .\n\nThis PR enables the following checkpoint loading features for Mixtral:\n\nSupports loading fp8 checkpoints for Mixtral, such as this \"nm-testing/Mixtral-8x7B-Instruct-v0.1-FP8\" test model\nSupports static or dynamic activation quantization with static weight quantization (all per tensor)\nSupports different scales for each expert weight\nSupports Fp8 in QKV layer\nNotes:\n\nThe Expert Gate/Router always runs at half / full precision for now.\nIf there are different weight scales between QKV layer (for separate QKV weights), they are re-quantized using layer.weight_scale.max() so we can have a single gemm for performance. dtrifiro pushed a commit\n        to opendatahub-io/vllm\n      that referenced\n      this pull request May 7, 2024 [Kernel] Support MoE Fp8 Checkpoints for Mixtral (Static Weights with… … 111b1a5 … Dynamic/Static Activations) ( vllm-project#4527 )\n\nFollow on to vllm-project#4332 to enable FP8 checkpoint loading for Mixtral and supersedes vllm-project#4436 .\n\nThis PR enables the following checkpoint loading features for Mixtral:\n\nSupports loading fp8 checkpoints for Mixtral, such as this \"nm-testing/Mixtral-8x7B-Instruct-v0.1-FP8\" test model\nSupports static or dynamic activation quantization with static weight quantization (all per tensor)\nSupports different scales for each expert weight\nSupports Fp8 in QKV layer\nNotes:\n\nThe Expert Gate/Router always runs at half / full precision for now.\nIf there are different weight scales between QKV layer (for separate QKV weights), they are re-quantized using layer.weight_scale.max() so we can have a single gemm for performance. dtrifiro mentioned this pull request May 15, 2024 bump ubi base image tag opendatahub-io/vllm#24 Merged Sign up for free to join this conversation on GitHub .\n    Already have an account? Sign in to comment",
  "timeline_extracted_at": "2025-09-07 17:49:03",
  "has_lm_eval": false,
  "has_performance": false,
  "has_serving": true,
  "has_general_test": true,
  "test_details": "SERVING: API server, OpenAI API server, Frontend | TEST: test, test, test",
  "analysis_extracted_at": "2025-09-07 17:49:03",
  "models": [
    "mistralai/Mixtral-8x7B-Instruct-v0.1"
  ],
  "lm_eval_commands": [
    "lm_eval --model vllm --model_args pretrained=mistralai/Mixtral-8x7B-Instruct-v0.1,quantization=fp8,tensor_parallel_size=1 --tasks gsm8k --num_fewshot 5"
  ],
  "perf_command": "python benchmarks/benchmark_serving.py --model mistralai/Mixtral-8x7B-Instruct-v0.1 --quantization fp8",
  "commit_subject": "[Kernel] Support MoE Fp8 Checkpoints for Mixtral (Static Weights with Dynamic/Static Activations) (#4527)",
  "commit_message": "[Kernel] Support MoE Fp8 Checkpoints for Mixtral (Static Weights with Dynamic/Static Activations) (#4527)\n\nFollow on to #4332 to enable FP8 checkpoint loading for Mixtral and supersedes #4436.\n\nThis PR enables the following checkpoint loading features for Mixtral:\n\nSupports loading fp8 checkpoints for Mixtral, such as this \"nm-testing/Mixtral-8x7B-Instruct-v0.1-FP8\" test model\nSupports static or dynamic activation quantization with static weight quantization (all per tensor)\nSupports different scales for each expert weight\nSupports Fp8 in QKV layer\nNotes:\n\nThe Expert Gate/Router always runs at half / full precision for now.\nIf there are different weight scales between QKV layer (for separate QKV weights), they are re-quantized using layer.weight_scale.max() so we can have a single gemm for performance.",
  "commit_date": "2024-05-04T11:45:16-07:00",
  "files_changed": [
    "tests/kernels/test_moe.py",
    "vllm/model_executor/models/mixtral.py"
  ],
  "functions_changed": [],
  "stats": {
    "num_test_files": 1,
    "num_non_test_files": 1,
    "only_test_files": 0,
    "only_non_test_files": 0,
    "num_files": 2,
    "num_hunks": 8,
    "num_edited_lines": 175,
    "num_non_test_edited_lines": 171,
    "commit_year": 2024
  },
  "diff_text": "diff --git a/tests/kernels/test_moe.py b/tests/kernels/test_moe.py\nindex 046f11d95..2356b9ec1 100644\n--- a/tests/kernels/test_moe.py\n+++ b/tests/kernels/test_moe.py\n@@ -77,8 +77,8 @@ def test_mixtral_moe(dtype: torch.dtype):\n     for i in range(config.num_local_experts):\n         weights = (hf_moe.experts[i].w1.weight.data,\n                    hf_moe.experts[i].w3.weight.data)\n-        vllm_moe.ws[i][:] = torch.cat(weights, dim=0)\n-        vllm_moe.w2s[i][:] = hf_moe.experts[i].w2.weight.data\n+        vllm_moe.w13_weight[i][:] = torch.cat(weights, dim=0)\n+        vllm_moe.w2_weight[i][:] = hf_moe.experts[i].w2.weight.data\n \n     # Generate input batch of dimensions [batch_size, seq_len, hidden_dim]\n     hf_inputs = torch.randn((1, 64, config.hidden_size)).to(dtype).to(\"cuda\")\ndiff --git a/vllm/model_executor/models/mixtral.py b/vllm/model_executor/models/mixtral.py\nindex 9ff9ba298..efa4de751 100644\n--- a/vllm/model_executor/models/mixtral.py\n+++ b/vllm/model_executor/models/mixtral.py\n@@ -78,6 +78,8 @@ class MixtralMoE(nn.Module):\n         self.top_k = top_k\n         self.hidden_size = hidden_size\n         self.intermediate_size = intermediate_size // self.tp_size\n+        self.quant_config = quant_config\n+\n         # FIXME(pcmoritz): Make this more general to support different\n         # quantization schemes\n         self.use_fp8 = isinstance(quant_config, Fp8Config)\n@@ -86,55 +88,79 @@ class MixtralMoE(nn.Module):\n             params_dtype = torch.get_default_dtype()\n         self.params_dtype = params_dtype\n \n+        # Gate always runs at half / full precision for now.\n         self.gate = ReplicatedLinear(self.hidden_size,\n                                      self.num_total_experts,\n                                      bias=False,\n                                      params_dtype=self.params_dtype,\n                                      quant_config=None)\n \n-        self.ws = nn.Parameter(\n+        if self.use_fp8:\n+            params_dtype = torch.float8_e4m3fn\n+\n+        self.w13_weight = nn.Parameter(\n             torch.empty(self.num_total_experts,\n                         2 * self.intermediate_size,\n                         self.hidden_size,\n-                        dtype=self.params_dtype))\n-        self.w2s = nn.Parameter(\n+                        dtype=params_dtype))\n+        self.w2_weight = nn.Parameter(\n             torch.empty(self.num_total_experts,\n                         self.hidden_size,\n                         self.intermediate_size,\n-                        dtype=self.params_dtype))\n+                        dtype=params_dtype))\n \n-        set_weight_attrs(self.ws, {\n+        set_weight_attrs(self.w13_weight, {\n             \"weight_loader\": self.weight_loader,\n         })\n-        set_weight_attrs(self.w2s, {\n+        set_weight_attrs(self.w2_weight, {\n             \"weight_loader\": self.weight_loader,\n         })\n \n-        # Scaling factors for FP8 weights\n-        self.ws_scale = nn.Parameter(\n-            torch.ones(self.num_total_experts, dtype=torch.float32),\n-            requires_grad=False) if self.use_fp8 else None\n-        self.w2s_scale = nn.Parameter(\n-            torch.ones(self.num_total_experts, dtype=torch.float32),\n-            requires_grad=False) if self.use_fp8 else None\n-\n-        # Scaling factors for FP8 activations\n-        need_act_scales = (self.use_fp8\n-                           and quant_config.activation_scheme == \"static\")\n-        self.as_scale = nn.Parameter(\n-            torch.zeros(1, dtype=torch.float32),\n-            requires_grad=False) if need_act_scales else None\n-        self.a2s_scale = nn.Parameter(\n-            torch.zeros(1, dtype=torch.float32),\n-            requires_grad=False) if need_act_scales else None\n-\n-        if need_act_scales:\n-            set_weight_attrs(self.as_scale, {\n-                \"weight_loader\": self.weight_loader,\n-            })\n-            set_weight_attrs(self.a2s_scale, {\n-                \"weight_loader\": self.weight_loader,\n-            })\n+        # Used for fp8.\n+        self.w13_scale = None\n+        self.w2_scale = None\n+        self.a13_scale = None\n+        self.a2_scale = None\n+\n+        if self.use_fp8:\n+            # WEIGHT_SCALE (for fp8)\n+            self.w13_scale = nn.Parameter(torch.ones(self.num_total_experts,\n+                                                     dtype=torch.float32),\n+                                          requires_grad=False)\n+            self.w2_scale = nn.Parameter(torch.ones(self.num_total_experts,\n+                                                    dtype=torch.float32),\n+                                         requires_grad=False)\n+\n+            # If loading fp8 checkpoint, pass the weight loaders.\n+            # If loading an fp16 checkpoint, do not (we will quantize in\n+            #   process_weights_after_loading()\n+            if quant_config.is_checkpoint_fp8_serialized:\n+                set_weight_attrs(self.w13_scale, {\n+                    \"weight_loader\": self.weight_loader,\n+                })\n+                set_weight_attrs(self.w2_scale, {\n+                    \"weight_loader\": self.weight_loader,\n+                })\n+\n+            # ACT_SCALE (for fp8)\n+            if quant_config.activation_scheme == \"static\":\n+                if not quant_config.is_checkpoint_fp8_serialized:\n+                    raise ValueError(\n+                        \"Found static activation scheme for checkpoint that \"\n+                        \"was not serialized fp8.\")\n+                self.a13_scale = nn.Parameter(torch.zeros(\n+                    self.num_total_experts, dtype=torch.float32),\n+                                              requires_grad=False)\n+                self.a2_scale = nn.Parameter(torch.zeros(\n+                    self.num_total_experts, dtype=torch.float32),\n+                                             requires_grad=False)\n+\n+                set_weight_attrs(self.a13_scale, {\n+                    \"weight_loader\": self.weight_loader,\n+                })\n+                set_weight_attrs(self.a2_scale, {\n+                    \"weight_loader\": self.weight_loader,\n+                })\n \n     def weight_loader(self, param: nn.Parameter, loaded_weight: torch.Tensor,\n                       weight_name: str, expert_id: int):\n@@ -149,20 +175,49 @@ class MixtralMoE(nn.Module):\n                        shard_size:2 * shard_size, :] = loaded_weight[shard, :]\n         if weight_name.endswith(\"w2.weight\"):\n             param_data[expert_id, :, :] = loaded_weight[:, shard]\n-        if \"act_scale\" in weight_name:\n-            param_data[:] = param_data[:].max(loaded_weight)\n+        if \"act_scale\" in weight_name or \"weight_scale\" in weight_name:\n+            param_data[expert_id] = loaded_weight\n \n     def process_weights_after_loading(self):\n-        if self.use_fp8:\n-            ws = torch.empty_like(self.ws.data, dtype=torch.float8_e4m3fn)\n-            w2s = torch.empty_like(self.w2s.data, dtype=torch.float8_e4m3fn)\n+        # Fp8 is the only case where we need to process after loading.\n+        if not self.use_fp8:\n+            return\n+\n+        # If checkpoint is fp16, quantize here.\n+        if not self.quant_config.is_checkpoint_fp8_serialized:\n+            w13_weight = torch.empty_like(self.w13_weight.data,\n+                                          dtype=torch.float8_e4m3fn)\n+            w2_weight = torch.empty_like(self.w2_weight.data,\n+                                         dtype=torch.float8_e4m3fn)\n             for expert in range(self.num_total_experts):\n-                ws[expert, :, :], self.ws_scale[expert] = ops.scaled_fp8_quant(\n-                    self.ws.data[expert, :, :])\n-                w2s[expert, :, :], self.w2s_scale[\n-                    expert] = ops.scaled_fp8_quant(self.w2s.data[expert, :, :])\n-            self.ws = nn.Parameter(ws, requires_grad=False)\n-            self.w2s = nn.Parameter(w2s, requires_grad=False)\n+                w13_weight[expert, :, :], self.w13_scale[\n+                    expert] = ops.scaled_fp8_quant(\n+                        self.w13_weight.data[expert, :, :])\n+                w2_weight[expert, :, :], self.w2_scale[\n+                    expert] = ops.scaled_fp8_quant(\n+                        self.w2_weight.data[expert, :, :])\n+            self.w13_weight = nn.Parameter(w13_weight, requires_grad=False)\n+            self.w2_weight = nn.Parameter(w2_weight, requires_grad=False)\n+\n+        # If checkpoint is fp8 + static, cleanup act_scales.\n+        #   Since state_dict has an act_scale per expert but our kernels\n+        #   are passed one act_scale shared across all experts.\n+        elif self.quant_config.activation_scheme == \"static\":\n+            if self.a13_scale is None or self.a2_scale is None:\n+                raise ValueError(\n+                    \"QuantConfig has static quantization, but found \"\n+                    \"activation scales are None.\")\n+\n+            if (not all_close_1d(self.a13_scale)\n+                    or not all_close_1d(self.a2_scale)):\n+                print_warning_once(\n+                    \"Found act_scales that are not equal for fp8 MoE layer. \"\n+                    \"Using the maximum across experts for each layer. \")\n+\n+            self.a13_scale = nn.Parameter(self.a13_scale.max(),\n+                                          requires_grad=False)\n+            self.a2_scale = nn.Parameter(self.a2_scale.max(),\n+                                         requires_grad=False)\n \n     def forward(self, hidden_states: torch.Tensor) -> torch.Tensor:\n         num_tokens, hidden_size = hidden_states.shape\n@@ -170,17 +225,17 @@ class MixtralMoE(nn.Module):\n         # router_logits: (num_tokens, n_experts)\n         router_logits, _ = self.gate(hidden_states)\n         final_hidden_states = fused_moe(hidden_states,\n-                                        self.ws,\n-                                        self.w2s,\n+                                        self.w13_weight,\n+                                        self.w2_weight,\n                                         router_logits,\n                                         self.top_k,\n                                         renormalize=True,\n                                         inplace=True,\n                                         use_fp8=self.use_fp8,\n-                                        w1_scale=self.ws_scale,\n-                                        w2_scale=self.w2s_scale,\n-                                        a1_scale=self.as_scale,\n-                                        a2_scale=self.a2s_scale)\n+                                        w1_scale=self.w13_scale,\n+                                        w2_scale=self.w2_scale,\n+                                        a1_scale=self.a13_scale,\n+                                        a2_scale=self.a2_scale)\n \n         if self.tp_size > 1:\n             final_hidden_states = tensor_model_parallel_all_reduce(\n@@ -222,7 +277,9 @@ class MixtralAttention(nn.Module):\n         self.rope_theta = rope_theta\n         self.sliding_window = sliding_window\n \n-        if isinstance(quant_config, Fp8Config):\n+        if isinstance(\n+                quant_config,\n+                Fp8Config) and not quant_config.is_checkpoint_fp8_serialized:\n             print_warning_once(\n                 \"For Mixtral FP8 quantization, we currently do not quantize \"\n                 \"the attention layers until their FP8 performance is improved.\"\n@@ -461,16 +518,23 @@ class MixtralForCausalLM(nn.Module):\n         ]\n \n         expert_params_mapping = [\n+            # These are the weight scales for the experts\n+            # (param_name, weight_name, expert_id)\n+            (\"w13_scale\" if weight_name in [\"w1\", \"w3\"] else \"w2_scale\",\n+             f\"experts.{expert_id}.{weight_name}.weight_scale\", expert_id)\n+            for expert_id in range(self.config.num_local_experts)\n+            for weight_name in [\"w1\", \"w2\", \"w3\"]\n+        ] + [\n             # These are the weights for the experts\n             # (param_name, weight_name, expert_id)\n-            (\"ws\" if weight_name in [\"w1\", \"w3\"] else \"w2s\",\n+            (\"w13_weight\" if weight_name in [\"w1\", \"w3\"] else \"w2_weight\",\n              f\"experts.{expert_id}.{weight_name}.weight\", expert_id)\n             for expert_id in range(self.config.num_local_experts)\n             for weight_name in [\"w1\", \"w2\", \"w3\"]\n         ] + [\n             # These are the activation scales for the experts\n             # (param_name, weight_name, expert_id)\n-            (\"as_scale\" if weight_name in [\"w1\", \"w3\"] else \"a2s_scale\",\n+            (\"a13_scale\" if weight_name in [\"w1\", \"w3\"] else \"a2_scale\",\n              f\"experts.{expert_id}.{weight_name}.act_scale\", expert_id)\n             for expert_id in range(self.config.num_local_experts)\n             for weight_name in [\"w1\", \"w2\", \"w3\"]\n@@ -512,3 +576,8 @@ class MixtralForCausalLM(nn.Module):\n                     weight_loader = getattr(param, \"weight_loader\",\n                                             default_weight_loader)\n                     weight_loader(param, loaded_weight)\n+\n+\n+def all_close_1d(x: torch.Tensor) -> bool:\n+    assert len(x.shape) == 1\n+    return all(torch.allclose(x[0], x[i]) for i in range(x.shape[0]))",
  "apis": [
    "MixtralMoE",
    "MixtralModel",
    "MixtralForCausalLM"
  ],
  "affected_paths": [
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/model_executor/models/mixtral.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/model_executor/models/mixtral_quant.py"
  ],
  "repo_path": "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm",
  "llm_reason": "The commit introduces changes in the core Mixtral model (in mixtral.py) to support FP8 checkpoint loading, including new parameter names, handling of FP8-specific quantization, and weight/activation scaling adjustments. These modifications are not mere refactoring or documentation fixes—they alter the internal behavior of the model to perform lower-precision computations (FP8) which can be expected to improve performance by reducing memory bandwidth and potentially accelerating inference operations. Additionally, changes like re-quantization via max across scales for a unified GEMM further indicate performance considerations. Although the changes also touch a test file, the primary modifications are in non-test source code and aim to improve runtime efficiency on standard CPU hardware. Therefore, this commit is performance/optimization related.",
  "llm_api_reason": "This commit extends the Mixtral MoE functionality to support FP8 checkpoints by changing internal weight parameter names, adding new scaling parameters, and adjusting the weight‐processing logic. The modifications are made in the MixtralMoE layer (in both mixtral.py and mixtral_quant.py) as well as the weight mapping in MixtralForCausalLM, which affect how expert weights and activations are quantized and loaded for FP8 support. These updates impact the high‐level APIs that instantiate these models for causal language modeling."
}