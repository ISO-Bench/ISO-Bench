{
  "commit_hash": "9ed82e7074a18e25680ab106fc846364ad97bc00",
  "pr_url": "https://github.com/vllm-project/vllm/pull/6520",
  "pr_date": "2024-07-17",
  "timeline_text": "Copy link Collaborator Yard1 commented Jul 17, 2024 Small performance improvements in different components, discovered during profiling. Look at commit list for details! PR Checklist (Click to Expand) Thank you for your contribution to vLLM! Before submitting the pull request, please ensure the PR meets the following criteria. This helps vLLM maintain the code quality and improve the efficiency of the review process. PR Title and Classification Only specific types of PRs will be reviewed. The PR title is prefixed appropriately to indicate the type of change. Please use one of the following: [Bugfix] for bug fixes. [CI/Build] for build or continuous integration improvements. [Doc] for documentation fixes and improvements. [Model] for adding a new model or improving an existing model. Model name should appear in the title. [Frontend] For changes on the vLLM frontend (e.g., OpenAI API server, LLM class, etc.) [Kernel] for changes affecting CUDA kernels or other compute kernels. [Core] for changes in the core vLLM logic (e.g., LLMEngine , AsyncLLMEngine , Scheduler , etc.) [Hardware][Vendor] for hardware-specific changes. Vendor name should appear in the prefix (e.g., [Hardware][AMD] ). [Misc] for PRs that do not fit the above categories. Please use this sparingly. Note: If the PR spans more than one category, please include all relevant prefixes. Code Quality The PR need to meet the following code quality standards: We adhere to Google Python style guide and Google C++ style guide . Pass all linter checks. Please use format.sh to format your code. The code need to be well-documented to ensure future contributors can easily understand the code. Include sufficient tests to ensure the project to stay correct and robust. This includes both unit tests and integration tests. Please add documentation to docs/source/ if the PR modifies the user-facing behaviors of vLLM. It helps vLLM user understand and utilize the new features or changes. Notes for Large Changes Please keep the changes as concise as possible. For major architectural changes (>500 LOC excluding kernel/data/config/test), we would expect a GitHub issue (RFC) discussing the technical design and justification. Otherwise, we will tag it with rfc-required and might not go through the PR. What to Expect for the Reviews The goal of the vLLM team is to be a transparent reviewing machine . We would like to make the review process transparent and efficient and make sure no contributor feel confused or frustrated. However, the vLLM team is small, so we need to prioritize some PRs over others. Here is what you can expect from the review process: After the PR is submitted, the PR will be assigned to a reviewer. Every reviewer will pick up the PRs based on their expertise and availability. After the PR is assigned, the reviewer will provide status update every 2-3 days. If the PR is not reviewed within 7 days, please feel free to ping the reviewer or the vLLM team. After the review, the reviewer will put an action-required label on the PR if there are changes required. The contributor should address the comments and ping the reviewer to re-review the PR. Please respond to all comments within a reasonable time frame. If a comment isn't clear or you disagree with a suggestion, feel free to ask for clarification or discuss the suggestion. Thank You Finally, thank you for taking the time to read these guidelines and for your interest in contributing to vLLM. Your contributions make vLLM a great tool for everyone! Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions Yard1 added 4 commits July 17, 2024 14:11 Cache importlib in ModelRegistry c5e350b Fast return for get_common_computed_block_ids f269738 chunk_list into an iterator a36da80 Cache _first_seq in SequenceGroup 47ce44f Copy link github-actions bot commented Jul 17, 2024 ðŸ‘‹ Hi! Thank you for contributing to the vLLM project. Just a reminder: PRs would not trigger full CI run by default. Instead, it would only trigger fastcheck CI to run, which consists only a small and essential subset of tests to quickly catch errors with the flexibility to run extra individual tests on top (you can do this by unblocking test steps in the Buildkite run). Full CI run is still required to merge this PR so once the PR is ready to go, please make sure to run it. If you need all test signals in between PR commits, you can trigger full CI as well. To run full CI, you can do one of these: Comment /ready on the PR Add ready label to the PR Enable auto-merge. ðŸš€ All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Yard1 requested a review\n  from njhill July 17, 2024 21:15 Copy link Collaborator Author Yard1 commented Jul 17, 2024 /ready All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . github-actions bot added\n  the ready ONLY add when PR is ready to merge/full CI is needed label Jul 17, 2024 Yard1 added 3 commits July 17, 2024 14:16 Lint 69d73a3 Lint bbef0e1 Lint 34c30df comaniac approved these changes Jul 17, 2024 View reviewed changes Copy link Collaborator comaniac left a comment There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment LGTM Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions Yard1 enabled auto-merge (squash) July 17, 2024 21:52 rkooo567 approved these changes Jul 17, 2024 View reviewed changes Yard1 added 4 commits July 17, 2024 15:06 Fix test 6b45138 Fix f27f653 Lint 31e4c76 Fix dd897db cadedaniel approved these changes Jul 18, 2024 View reviewed changes Copy link Collaborator cadedaniel left a comment There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment Some test failure Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions Copy link Member DarkLight1337 commented Jul 18, 2024 â€¢ edited Loading Uh oh! There was an error while loading. Please reload this page . It looks like you are calling list after chunk_list in each case. Wouldn't that defeat the point of making it a generator function? Edit: Never mind, I see it being used in https://github.com/vllm-project/vllm/blob/main/vllm/core/block/block_table.py#L265 To make the code a bit cleaner (by reducing the number of list calls), I suggest adding a new generator function iter_chunk_list to be used in for loops (e.g. in the above case), while keeping the existing semantics of chunk_list . All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . mgoin approved these changes Jul 18, 2024 View reviewed changes Fix ebf4794 Yard1 disabled auto-merge July 18, 2024 20:13 Yard1 enabled auto-merge (squash) July 18, 2024 20:13 Yard1 added 2 commits July 18, 2024 20:17 Merge branch 'upstream_main' into small_improvements 5eddc37 Merge branch 'upstream_main' into small_improvements e39f05c simon-mo disabled auto-merge July 19, 2024 19:10 simon-mo merged commit 9ed82e7 into main Jul 19, 2024 Yard1 deleted the small_improvements branch July 19, 2024 22:17 xjpang pushed a commit\n        to xjpang/vllm\n      that referenced\n      this pull request Jul 24, 2024 [Misc] Small perf improvements ( vllm-project#6520 ) 2660a29 mawong-amd mentioned this pull request Sep 3, 2024 Reconcile merge differences [fix Custom All Reduce; remove Torchrun & Cython] ROCm/vllm#163 Closed Alvant pushed a commit\n        to compressa-ai/vllm\n      that referenced\n      this pull request Oct 26, 2024 [Misc] Small perf improvements ( vllm-project#6520 ) â€¦ b1401bc Signed-off-by: Alvant <alvasian@yandex.ru> LeiWang1999 pushed a commit\n        to LeiWang1999/vllm-bitblas\n      that referenced\n      this pull request Mar 26, 2025 [Misc] Small perf improvements ( vllm-project#6520 ) â€¦ b0b4998 Signed-off-by: LeiWang1999 <leiwang1999@outlook.com> Sign up for free to join this conversation on GitHub .\n    Already have an account? Sign in to comment",
  "timeline_extracted_at": "2025-09-07 17:48:29",
  "has_lm_eval": false,
  "has_performance": true,
  "has_serving": true,
  "has_general_test": true,
  "test_details": "PERF: profiling | SERVING: API server, OpenAI API server, Frontend | TEST: test, test, test",
  "analysis_extracted_at": "2025-09-07 17:48:29",
  "models": [
    "N/A"
  ],
  "lm_eval_commands": null,
  "perf_command": null,
  "commit_subject": "[Misc] Small perf improvements (#6520)",
  "commit_message": "[Misc] Small perf improvements (#6520)",
  "commit_date": "2024-07-19T12:10:56-07:00",
  "files_changed": [
    "tests/core/block/test_block_manager_v2.py",
    "tests/core/block/test_cpu_gpu_block_allocator.py",
    "vllm/core/block/block_table.py",
    "vllm/core/block/prefix_caching_block.py",
    "vllm/model_executor/models/__init__.py",
    "vllm/sequence.py",
    "vllm/utils.py"
  ],
  "functions_changed": [],
  "stats": {
    "num_test_files": 2,
    "num_non_test_files": 5,
    "only_test_files": 0,
    "only_non_test_files": 0,
    "num_files": 7,
    "num_hunks": 11,
    "num_edited_lines": 69,
    "num_non_test_edited_lines": 50,
    "commit_year": 2024
  },
  "diff_text": "diff --git a/tests/core/block/test_block_manager_v2.py b/tests/core/block/test_block_manager_v2.py\nindex d0ca09c4b..d7863a9ae 100644\n--- a/tests/core/block/test_block_manager_v2.py\n+++ b/tests/core/block/test_block_manager_v2.py\n@@ -249,10 +249,13 @@ def test_append_slots(block_size, prompt_len, num_slots_to_append,\n \n     # Expect consumed blocks to be new blocks required to support the new slots.\n     expected_consumed_blocks = len(\n-        chunk_list(\n-            list(\n-                range(prompt_len + num_slots_to_append + num_lookahead_slots)),\n-            block_size)) - len(chunk_list(list(range(prompt_len)), block_size))\n+        list(\n+            chunk_list(\n+                list(\n+                    range(prompt_len + num_slots_to_append +\n+                          num_lookahead_slots)),\n+                block_size))) - len(\n+                    list(chunk_list(list(range(prompt_len)), block_size)))\n     assert num_consumed_blocks == expected_consumed_blocks\n \n \ndiff --git a/tests/core/block/test_cpu_gpu_block_allocator.py b/tests/core/block/test_cpu_gpu_block_allocator.py\nindex 15b76d909..a9e38d404 100644\n--- a/tests/core/block/test_cpu_gpu_block_allocator.py\n+++ b/tests/core/block/test_cpu_gpu_block_allocator.py\n@@ -58,10 +58,10 @@ def test_allocate_immutable_block(num_cpu_blocks: int, num_gpu_blocks: int,\n \n     unique_token_ids = list(\n         range((num_cpu_blocks + num_gpu_blocks) * block_size))\n-    gpu_token_ids = chunk_list(unique_token_ids[:num_gpu_blocks * block_size],\n-                               block_size)\n-    cpu_token_ids = chunk_list(unique_token_ids[num_gpu_blocks * block_size:],\n-                               block_size)\n+    gpu_token_ids = list(\n+        chunk_list(unique_token_ids[:num_gpu_blocks * block_size], block_size))\n+    cpu_token_ids = list(\n+        chunk_list(unique_token_ids[num_gpu_blocks * block_size:], block_size))\n \n     assert allocator.get_num_free_blocks(Device.CPU) == num_cpu_blocks\n     assert allocator.get_num_free_blocks(Device.GPU) == num_gpu_blocks\ndiff --git a/vllm/core/block/block_table.py b/vllm/core/block/block_table.py\nindex 49e63c231..06b816eb3 100644\n--- a/vllm/core/block/block_table.py\n+++ b/vllm/core/block/block_table.py\n@@ -1,3 +1,4 @@\n+import math\n from typing import List, Optional\n \n from vllm.core.block.common import BlockList\n@@ -337,10 +338,17 @@ class BlockTable:\n         This is required for the scheduler to determine whether a sequence can\n         continue generation, or if it must be preempted.\n         \"\"\"\n+        # Math below is equivalent to:\n+        # all_token_ids = token_ids + [-1] * num_lookahead_slots\n+        # token_blocks = self._chunk_token_blocks_for_append(all_token_ids)\n+        # return len(token_blocks)\n \n-        all_token_ids = token_ids + [-1] * num_lookahead_slots\n-        token_blocks = self._chunk_token_blocks_for_append(all_token_ids)\n-        return len(token_blocks)\n+        num_token_ids = len(token_ids) + num_lookahead_slots\n+        first_chunk_size = self._block_size - (self._num_full_slots %\n+                                               self._block_size)\n+        num_token_blocks = (1 + math.ceil(\n+            (num_token_ids - first_chunk_size) / self._block_size))\n+        return num_token_blocks\n \n     def _chunk_token_blocks_for_append(\n             self, token_ids: List[int]) -> List[List[int]]:\n@@ -351,6 +359,7 @@ class BlockTable:\n         \"\"\"\n         first_chunk_size = self._block_size - (self._num_full_slots %\n                                                self._block_size)\n-        token_blocks = [token_ids[:first_chunk_size]] + chunk_list(\n-            token_ids[first_chunk_size:], self._block_size)\n+        token_blocks = [token_ids[:first_chunk_size]]\n+        token_blocks.extend(\n+            chunk_list(token_ids[first_chunk_size:], self._block_size))\n         return token_blocks\ndiff --git a/vllm/core/block/prefix_caching_block.py b/vllm/core/block/prefix_caching_block.py\nindex f272e23ee..d102ad404 100644\n--- a/vllm/core/block/prefix_caching_block.py\n+++ b/vllm/core/block/prefix_caching_block.py\n@@ -552,9 +552,12 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n         # runner.\n \n         # It returns a list of int although type annotation says list of string.\n+        if len(computed_seq_block_ids) == 1:\n+            return computed_seq_block_ids[0]\n+\n         return commonprefix([\n             ids for ids in computed_seq_block_ids  # type: ignore\n-            if ids != []\n+            if ids\n         ])\n \n     def get_num_blocks_touched(self,\ndiff --git a/vllm/model_executor/models/__init__.py b/vllm/model_executor/models/__init__.py\nindex 87508a116..aa5a70757 100644\n--- a/vllm/model_executor/models/__init__.py\n+++ b/vllm/model_executor/models/__init__.py\n@@ -1,3 +1,4 @@\n+import functools\n import importlib\n from typing import Dict, List, Optional, Type\n \n@@ -98,6 +99,14 @@ _ROCM_PARTIALLY_SUPPORTED_MODELS: Dict[str, str] = {\n \n class ModelRegistry:\n \n+    @staticmethod\n+    @functools.lru_cache(maxsize=128)\n+    def _get_model(model_arch: str):\n+        module_name, model_cls_name = _MODELS[model_arch]\n+        module = importlib.import_module(\n+            f\"vllm.model_executor.models.{module_name}\")\n+        return getattr(module, model_cls_name, None)\n+\n     @staticmethod\n     def load_model_cls(model_arch: str) -> Optional[Type[nn.Module]]:\n         if model_arch in _OOT_MODELS:\n@@ -114,10 +123,7 @@ class ModelRegistry:\n                     \"Model architecture %s is partially supported by ROCm: %s\",\n                     model_arch, _ROCM_PARTIALLY_SUPPORTED_MODELS[model_arch])\n \n-        module_name, model_cls_name = _MODELS[model_arch]\n-        module = importlib.import_module(\n-            f\"vllm.model_executor.models.{module_name}\")\n-        return getattr(module, model_cls_name, None)\n+        return ModelRegistry._get_model(model_arch)\n \n     @staticmethod\n     def get_supported_archs() -> List[str]:\ndiff --git a/vllm/sequence.py b/vllm/sequence.py\nindex 1cebf68d4..6c12a01bd 100644\n--- a/vllm/sequence.py\n+++ b/vllm/sequence.py\n@@ -457,24 +457,25 @@ class SequenceGroup:\n         self.prompt_adapter_request = prompt_adapter_request\n         self.encoder_seq = encoder_seq\n         self.trace_headers = trace_headers\n+        self._first_seq = next(iter(self.seqs_dict.values()))\n \n     @property\n     def prompt(self) -> Optional[str]:\n         # All sequences in the group should have the same prompt.\n         # We use the prompt of an arbitrary sequence.\n-        return next(iter(self.seqs_dict.values())).prompt\n+        return self._first_seq.prompt\n \n     @property\n     def prompt_token_ids(self) -> List[int]:\n         # All sequences in the group should have the same prompt.\n         # We use the prompt of an arbitrary sequence.\n-        return next(iter(self.seqs_dict.values())).prompt_token_ids\n+        return self._first_seq.prompt_token_ids\n \n     @property\n     def multi_modal_data(self) -> \"MultiModalDataDict\":\n         # All sequences in the group should have the same multi-modal data.\n         # We use the multi-modal data of an arbitrary sequence.\n-        return next(iter(self.seqs_dict.values())).multi_modal_data\n+        return self._first_seq.multi_modal_data\n \n     @property\n     def lora_int_id(self) -> int:\ndiff --git a/vllm/utils.py b/vllm/utils.py\nindex f3025a68d..f906d8258 100644\n--- a/vllm/utils.py\n+++ b/vllm/utils.py\n@@ -415,9 +415,10 @@ def init_kmp_env():\n     os.environ['KMP_REDUCTION_BARRIER_PATTERN'] = \"dist,dist\"\n \n \n-def chunk_list(lst: List[T], chunk_size: int) -> List[List[T]]:\n+def chunk_list(lst: List[T], chunk_size: int):\n     \"\"\"Yield successive chunk_size chunks from lst.\"\"\"\n-    return [lst[i:i + chunk_size] for i in range(0, len(lst), chunk_size)]\n+    for i in range(0, len(lst), chunk_size):\n+        yield lst[i:i + chunk_size]\n \n \n def cdiv(a: int, b: int) -> int:",
  "apis": [
    "BlockTable.get_num_token_blocks",
    "ModelRegistry.load_model_cls",
    "SequenceGroup.prompt",
    "SequenceGroup.prompt_token_ids",
    "SequenceGroup.multi_modal_data"
  ],
  "affected_paths": [],
  "repo_path": "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm",
  "llm_reason": "The commit makes modifications in multiple non-test source files (e.g., in vllm/core/block/block_table.py, vllm/model_executor/models/__init__.py, vllm/sequence.py, and vllm/utils.py) with changes aimed at improving performance. For instance, it replaces a list-building approach with a mathematical calculation for token chunks, introduces caching via lru_cache to avoid repetitive imports, and optimizes repeated dictionary iteration by storing a value. These modifications are non-trivial changes to production code and target CPU performance improvements rather than bug fixes or simple refactoring. Hence, the commit satisfies the specified conditions.",
  "llm_api_reason": "The commit makes several minor performance and code cleanup improvements. In tests, it wraps generator calls from a modified chunk_list to ensure correct list conversion. In the core, it updates the block tableâ€™s logic for computing token blocks using math.ceil instead of recomputing list lengths. It also caches the first sequence in SequenceGroup to avoid repeatedly iterating over the sequence dictionary for properties like prompt, prompt_token_ids and multi_modal_data. Finally, it adds an lru_cache wrapper to the model lookup in ModelRegistry.load_model_cls. These changes affect the public interfaces that users rely on for model loading and sequence management."
}