{
  "commit_hash": "6e36f4fa6ce64619b9ea94c88a157f5783a63a65",
  "pr_url": "https://github.com/vllm-project/vllm/pull/7874",
  "pr_date": "2024-08-26",
  "timeline_text": "Copy link Contributor noooop commented Aug 26, 2024 ‚Ä¢ edited Loading Uh oh! There was an error while loading. Please reload this page . SUMMARY: vllm 0.5.4 enable_chunked_prefill throughput is slightly lower than 0.5.3~0.5.0. Prioritizing prefill causes and aggravate system thrashing. FILL IN THE PR DESCRIPTION HERE FIX #7592 by definition By default, vLLM scheduler prioritizes prefills ... Once chunked prefill is enabled, the policy is changed to prioritize decode requests. The easiest fix is sort the running queue. Keeping chunked prefill performance the untouched, everyone is happy. BEFORE SUBMITTING, PLEASE READ THE CHECKLIST BELOW AND FILL IN THE DESCRIPTION ABOVE PR Checklist (Click to Expand) Thank you for your contribution to vLLM! Before submitting the pull request, please ensure the PR meets the following criteria. This helps vLLM maintain the code quality and improve the efficiency of the review process. PR Title and Classification Only specific types of PRs will be reviewed. The PR title is prefixed appropriately to indicate the type of change. Please use one of the following: [Bugfix] for bug fixes. [CI/Build] for build or continuous integration improvements. [Doc] for documentation fixes and improvements. [Model] for adding a new model or improving an existing model. Model name should appear in the title. [Frontend] For changes on the vLLM frontend (e.g., OpenAI API server, LLM class, etc.) [Kernel] for changes affecting CUDA kernels or other compute kernels. [Core] for changes in the core vLLM logic (e.g., LLMEngine , AsyncLLMEngine , Scheduler , etc.) [Hardware][Vendor] for hardware-specific changes. Vendor name should appear in the prefix (e.g., [Hardware][AMD] ). [Misc] for PRs that do not fit the above categories. Please use this sparingly. Note: If the PR spans more than one category, please include all relevant prefixes. Code Quality The PR need to meet the following code quality standards: We adhere to Google Python style guide and Google C++ style guide . Pass all linter checks. Please use format.sh to format your code. The code need to be well-documented to ensure future contributors can easily understand the code. Include sufficient tests to ensure the project to stay correct and robust. This includes both unit tests and integration tests. Please add documentation to docs/source/ if the PR modifies the user-facing behaviors of vLLM. It helps vLLM user understand and utilize the new features or changes. Notes for Large Changes Please keep the changes as concise as possible. For major architectural changes (>500 LOC excluding kernel/data/config/test), we would expect a GitHub issue (RFC) discussing the technical design and justification. Otherwise, we will tag it with rfc-required and might not go through the PR. What to Expect for the Reviews The goal of the vLLM team is to be a transparent reviewing machine . We would like to make the review process transparent and efficient and make sure no contributor feel confused or frustrated. However, the vLLM team is small, so we need to prioritize some PRs over others. Here is what you can expect from the review process: After the PR is submitted, the PR will be assigned to a reviewer. Every reviewer will pick up the PRs based on their expertise and availability. After the PR is assigned, the reviewer will provide status update every 2-3 days. If the PR is not reviewed within 7 days, please feel free to ping the reviewer or the vLLM team. After the review, the reviewer will put an action-required label on the PR if there are changes required. The contributor should address the comments and ping the reviewer to re-review the PR. Please respond to all comments within a reasonable time frame. If a comment isn't clear or you disagree with a suggestion, feel free to ask for clarification or discuss the suggestion. Thank You Finally, thank you for taking the time to read these guidelines and for your interest in contributing to vLLM. Your contributions make vLLM a great tool for everyone! Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . üëç 1 lambdaq reacted with thumbs up emoji üöÄ 2 Juelianqvq and simon-mo reacted with rocket emoji All reactions üëç 1 reaction üöÄ 2 reactions Copy link github-actions bot commented Aug 26, 2024 üëã Hi! Thank you for contributing to the vLLM project. Just a reminder: PRs would not trigger full CI run by default. Instead, it would only run fastcheck CI which consists a small and essential subset of CI tests to quickly catch errors. You can run other CI tests on top of default ones by unblocking the steps in your fast-check build on Buildkite UI. Once the PR is approved and ready to go, please make sure to run full CI as it is required to merge (or just use auto-merge). To run full CI, you can do one of these: Comment /ready on the PR Add ready label to the PR Enable auto-merge. üöÄ All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 26, 2024 @youkaichao All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Member youkaichao commented Aug 26, 2024 thanks for the contribution! please fix the format issue. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Member youkaichao commented Aug 26, 2024 I don't get it though, why this would affect chunked prefill so much üëÄ All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Collaborator comaniac commented Aug 26, 2024 Thanks for the fix! I have the same question as Kaichao. Why sorting running requests by their arrival time impacts the throughput significantly? All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 27, 2024 ‚Ä¢ edited Loading Uh oh! There was an error while loading. Please reload this page . Putting definitions and conventions aside first, let's discuss the pros and cons of chunked_prefill prioritizing scheduling prefill and prioritizing decoding. GPU memory limitations (gpu cache block limitations) When the GPU memory is sufficient, or max_num_batched_tokens and max_num_seqs are within a reasonable range, priority scheduling prefill can allow as many tasks as possible to enter decode mode, and even the entire batch is in decode mode, triggering CUDA graph optimization to improve throughput, but This (CUDA graph) is particularly effective for small models and when using tensor parallelism. , and when the batch is less than 256 (_BATCH_SIZES_TO_CAPTURE[-1]). So.Scenarios that favor priority scheduling of prefill are difficult to satisfy. In reality, when llm is deployed, the GPU memory is often limited, or max_num_batched_tokens and max_num_seqs are set too large, and preemption inevitably occurs. Priority scheduling decode can finish running tasks as soon as possible and release GPU memory, while priority scheduling prefill increases the number of tasks that are running at the same time, increasing the possibility of preemption. When preemption occurs, scheduling decode first means that tasks in the prefill phase are preempted and the cost is relatively small. When scheduling prefill first, tasks in the decode phase are preempted and the cost is relatively high. In short, when the GPU memory is limited, scheduling prefill first is Disaster, this is what I encountered. User satisfaction Prioritize scheduling decode, As mentioned in the documentation, \"It improves ITL and generation decode because decode requests are prioritized.\" Why sorting matters? Give an example max_num_seqs = max_num_batched_tokens= 256 input_len = output_len = 511 init request 0: num_computed_tokens: 0, num_uncomputed_tokens 511 request 1: num_computed_tokens: 0, num_uncomputed_tokens 511 step 1: Scheduled [0] request 0: num_computed_tokens: 256, num_uncomputed_tokens 255 request 1: num_computed_tokens: 0, num_uncomputed_tokens 511 step 2: Scheduled [0, 1] request 0: num_computed_tokens: 511, num_uncomputed_tokens 1, (to enter decode mode,) request 1: num_computed_tokens: 1, num_uncomputed_tokens 510 step 3: prioritizing scheduling prefill Ôºà0.5.4~0.5.5 Scheduled [1]  (Why not let request 0 decode ??????? request 0: num_computed_tokens: 511, num_uncomputed_tokens 1 request 1: num_computed_tokens: 257, num_uncomputed_tokens 254 prioritizing scheduling decode Ôºà0.5.0~0.5.3 Scheduled [0, 1] request 0: num_computed_tokens: 512, num_uncomputed_tokens 1 request 1: num_computed_tokens: 256, num_uncomputed_tokens 255 sorting matters All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 27, 2024 by the way prioritizing scheduling prefill and prioritizing decoding. the order of running_queue is exactly the opposite. But you can't just reverse the running_queue, you need modify every self.running.extend or as i said 'The easiest fix is sort the running queue.' All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 27, 2024 ‚Ä¢ edited Loading Uh oh! There was an error while loading. Please reload this page . Add more It is also a normal performance tuning behavior to set max_num_batched_tokens and max_num_seqs slightly larger Ôºàto slightly trigger preemptionÔºâ, increase parallelism, and improve throughput. But prioritizing prefill causes and aggravate system thrashing. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Member youkaichao commented Aug 27, 2024 ‚Ä¢ edited Loading Uh oh! There was an error while loading. Please reload this page . LGTM to add the sorting to get back to the behavior of 0.5.3. Please fix the format. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . noooop force-pushed the main branch\n    from 408b727 to dd12bc8 Compare August 27, 2024 02:42 Copy link Contributor Author noooop commented Aug 27, 2024 Submit code to vllm for the first time. Is there anything else I need to do? All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Member youkaichao commented Aug 27, 2024 as long as it does not break any tests, we can merge it. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 27, 2024 Thanks All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Collaborator rkooo567 commented Aug 27, 2024 ‚Ä¢ edited Loading Uh oh! There was an error while loading. Please reload this page . @noooop I think the issue is that after the refactoring, we should've changed the order of these lines to guarantee the ordering. Before the refactoring, the order was guranteed because we always sorted. Now we should more carefully extend the queue to preserve the right order. https://github.com/vllm-project/vllm/blob/ed6f002d3340888142cb67c13a37c060b51fa889/vllm/core/scheduler.py#L1029C1-L1029C72 I think if we change the order to be extend(swapped_in.decode)\nextend(swapped_in.prefill)\nextend(running.decode)\nextend(running.prefill)\nextend(new_prefill) The same behavior is preserved. can you test it? Note: without sorting, it may be difficult to always guarantee the right ordering when preemption happens, but I think that's the tradeoff üëç 1 comaniac reacted with thumbs up emoji All reactions üëç 1 reaction Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Collaborator rkooo567 commented Aug 27, 2024 ‚Ä¢ edited Loading Uh oh! There was an error while loading. Please reload this page . more specifically, change these lines self.running.extend([s.seq_group for s in prefills.seq_groups])\n        self.running.extend(\n            [s.seq_group for s in running_scheduled.decode_seq_groups])\n        self.running.extend(\n            [s.seq_group for s in running_scheduled.prefill_seq_groups])\n        self.running.extend(\n            [s.seq_group for s in swapped_in.decode_seq_groups])\n        self.running.extend(\n            [s.seq_group for s in swapped_in.prefill_seq_groups]) to self.running.extend(\n            [s.seq_group for s in swapped_in.decode_seq_groups])\n        self.running.extend(\n            [s.seq_group for s in swapped_in.prefill_seq_groups])\n        self.running.extend(\n            [s.seq_group for s in running_scheduled.decode_seq_groups])\n        self.running.extend(\n            [s.seq_group for s in running_scheduled.prefill_seq_groups])\n        self.running.extend([s.seq_group for s in prefills.seq_groups]) can you try testing it and see if it works? üëç 1 youkaichao reacted with thumbs up emoji All reactions üëç 1 reaction Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 28, 2024 @rkooo567 We need to maintain the priority order of the queue. There are at least four methods to choose from. We can choose the best method from efficiency, readability, ease of use, scalability, and maybe minimal modification. Sorting when dequeue.  Although slightly inefficient, no one can break itÔºåease to useÔºåease to readÔºåand minimal modification. use PriorityQueue.  Priority queue is very good optionÔºåwe need priority queue, we use priority queue. The following methods are not recommended Manually maintain queue order when inqueueÔºåwith online check.  maybe efficient. code that maintains order is everywhere, difficult to useÔºå difficult to readÔºå difficult to modification. Manually maintain queue order when inqueueÔºåwithout check.  ????? No one can modify this code in the future The performance bottleneck is in the GPU. I think there won't be much performance difference between Sorting and PriorityQueue, even manually maintaining queue order when inqueue. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Collaborator comaniac commented Aug 28, 2024 The performance bottleneck is in the GPU. I think there won't be much performance difference between Sorting and PriorityQueue, even manually maintaining queue order when inqueue. This may not be true especially for online serving which we are talking about a few millisecond ITL. In fact, Python overheads like these are the main performance bottleneck. We now even need to pre-allocate and reuse Python objects, use array.array, or add a branch for edge cases (e.g., do not call sum , count when there's only one element in a list). The easiest way to verify whether this sort creates ineligible overhead is running a performance benchmark. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Collaborator rkooo567 commented Aug 28, 2024 ‚Ä¢ edited Loading Uh oh! There was an error while loading. Please reload this page . Sorting when dequeue. Although slightly inefficient, no one can break itÔºåease to useÔºåease to readÔºåand minimal modification. Also to be clear, we used this implementation originally for exactly this reason, but vLLM currently has python overhead, and that's why we removed the sorting logic that requires repetitive queue copy. Often times, model forward only takes 10-20ms overhead only, and having 2-3ms overhead in the scheduler is critical in this kind of scenario. (if we eventually support async scheduler, we can probably come back to this implementation) I think manual sorting is the best workaround. I am not opposed to use priority queue as well if it turns out that it has no perf impact. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 28, 2024 I understand that strict orderliness is not necessary. I'm testing to see if certain queues may need to be reversed. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 28, 2024 Actually I was implementing async scheduler and stumbled upon this bug üëç 2 rkooo567 and QuantumGhost reacted with thumbs up emoji All reactions üëç 2 reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . noooop force-pushed the main branch\n    from dd12bc8 to 5245f4f Compare August 28, 2024 05:41 Copy link Contributor Author noooop commented Aug 28, 2024 It works,  in fact I love is  tradeoff . My own manual sorting method required too many changes, so I gave up. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . comaniac approved these changes Aug 28, 2024 View reviewed changes Copy link Collaborator comaniac left a comment There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment LGTM. Thanks Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions Copy link Contributor Author noooop commented Aug 28, 2024 this manual sorting  comparison with 0.5.3 and sorting on 1,000 requestsÔºåscheduling sequence exactly the same ‚ù§Ô∏è 1 rkooo567 reacted with heart emoji All reactions ‚ù§Ô∏è 1 reaction Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . rkooo567 approved these changes Aug 28, 2024 View reviewed changes Copy link Collaborator rkooo567 commented Aug 28, 2024 Awesome to hear that! btw I don't know if basic correctness test failure is related. can you try merging the latest master? All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 28, 2024 ok All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . noooop force-pushed the main branch\n    from 370de52 to 90885c2 Compare August 28, 2024 06:46 Copy link Contributor Author noooop commented Aug 28, 2024 By the way I was implementing async scheduler. During this process, I made a huge modularization and added dynamic workflow to vllm. I don't know if you want to see it. https://github.com/noooop/light-vllm üöÄ 2 Juelianqvq and youkaichao reacted with rocket emoji All reactions üöÄ 2 reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 28, 2024 I don't know why the test failed. This pr is too simple to break anything. Or the test is set up based on the wrong scheduling method All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . 25 hidden items Load more‚Ä¶ noooop reopened this Aug 30, 2024 Copy link Contributor Author noooop commented Aug 30, 2024 merg to the latest master Can anyone help me with the test? All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 30, 2024 @jon-chuang Can you give me some suggestions to pass the test. Can I delete test7? HowÔºü I can't find example.txt All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor jon-chuang commented Aug 30, 2024 For this test, try making NUM_LOGPROBS contingent on fp8 dtype and set to 8 if e5m2 and something higher (16 or 32) for e4m3. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor jon-chuang commented Aug 30, 2024 ‚Ä¢ edited Loading Uh oh! There was an error while loading. Please reload this page . If you can't fix it this way, you can mark that specific parameters for the test which fail (model type, dtype) as pytest.mark.skip(\"flakey test, see: #XXX\") or create an issue and link to that and I can fix it in another PR. All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . noooop mentioned this pull request Aug 31, 2024 [Bug]: flakey test found in #7874 #8051 Closed 1 task Copy link Contributor Author noooop commented Aug 31, 2024 ‚Ä¢ edited Loading Uh oh! There was an error while loading. Please reload this page . # We use float32 for probabilities and log probabilities. In Sampler float32 precise is is high enough. Can NUM_LOGPROBS be enlarged to achieve the original testing purpose? I choose to skip this test and let professionals solve it. @jon-chuang #8051 All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . noooop force-pushed the main branch\n    from 95aab1c to 57dc722 Compare August 31, 2024 04:33 noooop force-pushed the main branch\n    from 57dc722 to a05dd0b Compare August 31, 2024 04:36 flakey test, see: vllm-project#7874 vllm-project#8051 ad5f1db noooop force-pushed the main branch\n    from a05dd0b to ad5f1db Compare August 31, 2024 04:48 Copy link Contributor Author noooop commented Aug 31, 2024 @youkaichao @rkooo567 @comaniac Is it ready to launch? All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Copy link Contributor Author noooop commented Aug 31, 2024 /ready All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . github-actions bot added\n  the ready ONLY add when PR is ready to merge/full CI is needed label Aug 31, 2024 Copy link Member youkaichao commented Sep 2, 2024 thanks for the contribution! I triggered the test again, as long as the tests pass, we can merge it. üëç 1 noooop reacted with thumbs up emoji All reactions üëç 1 reaction Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . Hide details View details youkaichao merged commit 6e36f4f into vllm-project : main Sep 2, 2024 45 of 47 checks passed Uh oh! There was an error while loading. Please reload this page . gongdao123 pushed a commit\n        to bartsolutions/vllm\n      that referenced\n      this pull request Oct 18, 2024 improve chunked prefill performance ‚Ä¶ 100fcc9 [Bugfix] Fix vllm-project#7592 vllm 0.5.4 enable_chunked_prefill throughput is slightly lower than 0.5.3~0.5.0. ( vllm-project#7874 ) Alvant pushed a commit\n        to compressa-ai/vllm\n      that referenced\n      this pull request Oct 26, 2024 improve chunked prefill performance ‚Ä¶ 5a69ab1 [Bugfix] Fix vllm-project#7592 vllm 0.5.4 enable_chunked_prefill throughput is slightly lower than 0.5.3~0.5.0. ( vllm-project#7874 )\n\nSigned-off-by: Alvant <alvasian@yandex.ru> LeiWang1999 pushed a commit\n        to LeiWang1999/vllm-bitblas\n      that referenced\n      this pull request Mar 26, 2025 improve chunked prefill performance ‚Ä¶ 9e6de1c [Bugfix] Fix vllm-project#7592 vllm 0.5.4 enable_chunked_prefill throughput is slightly lower than 0.5.3~0.5.0. ( vllm-project#7874 )\n\nSigned-off-by: LeiWang1999 <leiwang1999@outlook.com> Sign up for free to join this conversation on GitHub .\n    Already have an account? Sign in to comment",
  "timeline_extracted_at": "2025-09-07 17:48:01",
  "has_lm_eval": false,
  "has_performance": true,
  "has_serving": true,
  "has_general_test": true,
  "test_details": "PERF: throughput, throughput, throughput | SERVING: serving, API server, OpenAI API server | TEST: test, test, test",
  "analysis_extracted_at": "2025-09-07 17:48:01",
  "models": [
    "N/A"
  ],
  "lm_eval_commands": null,
  "perf_command": null,
  "commit_subject": "improve chunked prefill performance",
  "commit_message": "improve chunked prefill performance\n\n[Bugfix] Fix #7592 vllm 0.5.4 enable_chunked_prefill throughput is slightly lower than 0.5.3~0.5.0. (#7874)",
  "commit_date": "2024-09-02T14:20:12-07:00",
  "files_changed": [
    "tests/basic_correctness/test_chunked_prefill.py",
    "vllm/core/scheduler.py"
  ],
  "functions_changed": [],
  "stats": {
    "num_test_files": 1,
    "num_non_test_files": 1,
    "only_test_files": 0,
    "only_non_test_files": 0,
    "num_files": 2,
    "num_hunks": 2,
    "num_edited_lines": 18,
    "num_non_test_edited_lines": 15,
    "commit_year": 2024
  },
  "diff_text": "diff --git a/tests/basic_correctness/test_chunked_prefill.py b/tests/basic_correctness/test_chunked_prefill.py\nindex fc6f829c3..a63ac380e 100644\n--- a/tests/basic_correctness/test_chunked_prefill.py\n+++ b/tests/basic_correctness/test_chunked_prefill.py\n@@ -116,6 +116,9 @@ def test_models_with_fp8_kv_cache(\n         pytest.skip(\n             \"#7378: CUDA illegal memory access (undiagnosed) facebook/opt-125m\"\n         )\n+    if ((model, kv_cache_dtype, chunked_prefill_token_size) == (\n+            \"nm-testing/Qwen2-1.5B-Instruct-FP8-K-V\", \"fp8_e4m3\", 4)):\n+        pytest.skip(\"flakey test, see: #7874 #8051\")\n \n     max_num_seqs = chunked_prefill_token_size\n     max_num_batched_tokens = chunked_prefill_token_size\ndiff --git a/vllm/core/scheduler.py b/vllm/core/scheduler.py\nindex 4c2f71582..81c78bda3 100644\n--- a/vllm/core/scheduler.py\n+++ b/vllm/core/scheduler.py\n@@ -1027,16 +1027,21 @@ class Scheduler:\n \n         # Update waiting requests.\n         self.waiting.extendleft(running_scheduled.preempted)\n+\n         # Update new running requests.\n-        self.running.extend([s.seq_group for s in prefills.seq_groups])\n-        self.running.extend(\n-            [s.seq_group for s in running_scheduled.decode_seq_groups])\n-        self.running.extend(\n-            [s.seq_group for s in running_scheduled.prefill_seq_groups])\n+        # By default, vLLM scheduler prioritizes prefills.\n+        # Once chunked prefill is enabled,\n+        # the policy is changed to prioritize decode requests.\n         self.running.extend(\n             [s.seq_group for s in swapped_in.decode_seq_groups])\n         self.running.extend(\n             [s.seq_group for s in swapped_in.prefill_seq_groups])\n+        self.running.extend(\n+            [s.seq_group for s in running_scheduled.decode_seq_groups])\n+        self.running.extend(\n+            [s.seq_group for s in running_scheduled.prefill_seq_groups])\n+        self.running.extend([s.seq_group for s in prefills.seq_groups])\n+\n         # Update swapped requests.\n         self.swapped.extend(running_scheduled.swapped_out)\n         return SchedulerOutputs(",
  "apis": [
    "vllm.core.scheduler.Scheduler.schedule",
    "vllm.core.scheduler.SchedulerOutputs"
  ],
  "affected_paths": [
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/core/scheduler.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/v1/core/sched/scheduler.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/attention/ops/chunked_prefill_paged_decode.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/engine/llm_engine.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/v1/engine/llm_engine.py"
  ],
  "repo_path": "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm",
  "llm_reason": "The commit modifies a non-test file (vllm/core/scheduler.py) where scheduling logic for handling requests is changed, effectively reordering elements and adjusting the prioritization, which is aimed at improving throughput and overall performance. Although the commit message also mentions fixing a throughput regression in a bugfix context, the changes directly target performance improvement of a core component affecting high-level API usage on CPU. Therefore, the commit meets the criteria for performance or optimization related changes.",
  "llm_api_reason": "This commit changes the scheduling logic in the vLLM scheduler by reordering how sequence groups are added to the running queue. Instead of simply concatenating prefills then decode groups, the updated code now prepends swapped‚Äêin decode and prefill groups first and then adds running decoded and prefill groups followed by the original prefills. This reordering, which is enabled when chunked prefill is active, prioritizes decode requests to improve throughput performance. The test file was also modified to skip a flaky test case for a specific model configuration."
}