{
  "commit_hash": "379da6dcb5f5d062d0452b2fc23291e5113dcf04",
  "pr_url": "https://github.com/vllm-project/vllm/pull/4691",
  "pr_date": "2024-05-08",
  "timeline_text": "Copy link Collaborator pcmoritz commented May 8, 2024 â€¢ edited Loading Uh oh! There was an error while loading. Please reload this page . This PR improves the FP8 performance of linear layers, which had been lacking before ( #4118 (comment) and #4118 (comment) ). We noticed that CUBLASLt can find a better algorithm if the first dimension of the matrix is at least 16. So this PR enlarges matrices appropriately during quantization. This improves FP8 performance and removes the performance regression vs. FP16, in many cases exceeding FP16 performance. Here are benchmarks on llama3 70b (ITL numbers for 1000 input and 50 output tokens at fixed qps and at TP 4), all FP8 measurements are for dynamic quantization: qps = 1: 24 ms (FP8, this PR), 32 ms (FP8, previous main), 26 ms (FP16)\nqps = 2: 26 ms (FP8, this PR), 34ms (FP8, previous main), 28 ms (FP16) \nqps = 4: 33 ms (FP8, this PR), 44 ms (FP8, previous main), 36 ms (FP16)\nqps = 6: 46 ms (FP8, this PR), 56 ms (FP8, previous main), 54 ms (FP16)\nqps = 8: 85 ms (FP8, this PR), 85 ms (FP8, previous main), 138 ms (FP16) PR Checklist (Click to Expand) Thank you for your contribution to vLLM! Before submitting the pull request, please ensure the PR meets the following criteria. This helps vLLM maintain the code quality and improve the efficiency of the review process. PR Title and Classification Only specific types of PRs will be reviewed. The PR title is prefixed appropriately to indicate the type of change. Please use one of the following: [Bugfix] for bug fixes. [CI/Build] for build or continuous integration improvements. [Doc] for documentation fixes and improvements. [Model] for adding a new model or improving an existing model. Model name should appear in the title. [Frontend] For changes on the vLLM frontend (e.g., OpenAI API server, LLM class, etc.) [Kernel] for changes affecting CUDA kernels or other compute kernels. [Core] for changes in the core vLLM logic (e.g., LLMEngine , AsyncLLMEngine , Scheduler , etc.) [Hardware][Vendor] for hardware-specific changes. Vendor name should appear in the prefix (e.g., [Hardware][AMD] ). [Misc] for PRs that do not fit the above categories. Please use this sparingly. Note: If the PR spans more than one category, please include all relevant prefixes. Code Quality The PR need to meet the following code quality standards: We adhere to Google Python style guide and Google C++ style guide . Pass all linter checks. Please use format.sh to format your code. The code need to be well-documented to ensure future contributors can easily understand the code. Include sufficient tests to ensure the project to stay correct and robust. This includes both unit tests and integration tests. Please add documentation to docs/source/ if the PR modifies the user-facing behaviors of vLLM. It helps vLLM user understand and utilize the new features or changes. Notes for Large Changes Please keep the changes as concise as possible. For major architectural changes (>500 LOC excluding kernel/data/config/test), we would expect a GitHub issue (RFC) discussing the technical design and justification. Otherwise, we will tag it with rfc-required and might not go through the PR. What to Expect for the Reviews The goal of the vLLM team is to be a transparent reviewing machine . We would like to make the review process transparent and efficient and make sure no contributor feel confused or frustrated. However, the vLLM team is small, so we need to prioritize some PRs over others. Here is what you can expect from the review process: After the PR is submitted, the PR will be assigned to a reviewer. Every reviewer will pick up the PRs based on their expertise and availability. After the PR is assigned, the reviewer will provide status update every 2-3 days. If the PR is not reviewed within 7 days, please feel free to ping the reviewer or the vLLM team. After the review, the reviewer will put an action-required label on the PR if there are changes required. The contributor should address the comments and ping the reviewer to re-review the PR. Please respond to all comments within a reasonable time frame. If a comment isn't clear or you disagree with a suggestion, feel free to ask for clarification or discuss the suggestion. Thank You Finally, thank you for taking the time to read these guidelines and for your interest in contributing to vLLM. Your contributions make vLLM a great tool for everyone! Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . ðŸ‘ 3 comaniac, AnyISalIn, and mgoin reacted with thumbs up emoji All reactions ðŸ‘ 3 reactions pcmoritz added 9 commits May 8, 2024 13:04 Initial commit d6b8e14 fix 3b77b56 adapt fp8 matmul code to use batch_dim_padding 5a0f28b Merge branch 'fp8-gemm-performance' of github.com:pcmoritz/vllm-publiâ€¦ â€¦ 91f544f â€¦c into fp8-gemm-performance add docstring b435641 format 6178aa3 yapf 99ef55f comments 8373dad format be94800 pcmoritz requested review from comaniac and robertgshaw2-redhat May 8, 2024 21:45 tlrmchlsmth approved these changes May 8, 2024 View reviewed changes vllm/model_executor/layers/quantization/fp8.py Outdated Comment on lines 236 to 240 batch_dim_padding=32) # Fused GEMM_DQ # Fused GEMM_DQ -- note we padded the input above because # torch._scaled_mm is more performant for matrices with # batch dimension at least 32. Copy link Collaborator tlrmchlsmth May 8, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment What is the perf effect when padding to 32 vs 16? (I ask because here it's 32 and in the PR description it's 16) Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions Copy link Collaborator Author pcmoritz May 8, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment So when I write my own wrappers for CUBLASLt, I'm getting the following error when calling the cublasLtMatmulAlgoGetHeuristic with FP8: [2024-05-08 19:00:00][cublasLt][1533][Info][cublasLtMatmulAlgoGetHeuristic] Unsupported M dimension for FP8 matrix multiplication. M must be divisible by 16. Got 2. (this is with highest logging CUBLASLT_LOG_LEVEL=5 ) -- that's why I wrote 16 in the description. For the setting we are using however, 32 is actually the best setting -- I tried them both and with 16 it is much closer to what it was previously. It is however possible that this will change in the future (e.g. once we use FP8 outputs I think things will change). Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . ðŸ‘ 1 tlrmchlsmth reacted with thumbs up emoji All reactions ðŸ‘ 1 reaction Copy link Collaborator Author pcmoritz May 8, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment I clarified this in the description now -- I wrote 16 since I didn't want to bias people for the future :) Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . ðŸ‘ 3 tlrmchlsmth, mgoin, and comaniac reacted with thumbs up emoji All reactions ðŸ‘ 3 reactions Copy link Contributor courage17340 May 9, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment Hello, I have two questions: I never saw the M must be divisible by 16 error when testing cublasLt. In fact, I can perform 1 x 1024 x 16 matmul with torch._scaled_mm . But it seems that there are some constraints on N, cublasLt requires N % 8 == 0 , while torch requires N % 16 == 0 . I guess your error is also on N, because cublasLt api is col major and we pass N as M to it when using row major tensors. In my experiment, matmul is slower when M is in range [1, 16], and is faster in range [17, 32], so maybe 17 is a better choice instead of 32? Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions Copy link Collaborator Author pcmoritz May 9, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment Thanks for the suggestion, let me try if 17 is better than 32 :) Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions Copy link Collaborator Author pcmoritz May 9, 2024 There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment I found the performance of 17 to be exactly the same as the performance of 32 , so I'll switch to 17 since it uses less memory. Thanks for the suggestion @courage17340 :) Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions robertgshaw2-redhat approved these changes May 8, 2024 View reviewed changes Copy link Collaborator robertgshaw2-redhat commented May 8, 2024 kinda wild - I suspect we will be able to improve performance significantly with our kernels All reactions Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . robertgshaw2-redhat enabled auto-merge (squash) May 8, 2024 22:18 mgoin approved these changes May 8, 2024 View reviewed changes Copy link Member mgoin left a comment There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment This makes sense! :) Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions comaniac approved these changes May 9, 2024 View reviewed changes Copy link Collaborator comaniac left a comment There was a problem hiding this comment. Choose a reason for hiding this comment The reason will be displayed to describe this comment to others. Learn more . Choose a reason Spam Abuse Off Topic Outdated Duplicate Resolved Hide comment Great! Sorry, something went wrong. Uh oh! There was an error while loading. Please reload this page . All reactions pcmoritz added 5 commits May 8, 2024 18:27 rerun ci 6b87e6f rerun ci 6a4e533 rerun ci af7b9f7 rerun ci 4cc1991 Merge branch 'main' into fp8-gemm-performance 3462ba7 pcmoritz disabled auto-merge May 9, 2024 20:26 pcmoritz added 2 commits May 9, 2024 13:47 use 17 instead of 32 9bafda5 rerun ci 3439917 pcmoritz merged commit 379da6d into vllm-project : main May 9, 2024 robertgshaw2-redhat pushed a commit\n        to neuralmagic/nm-vllm\n      that referenced\n      this pull request May 19, 2024 [Kernel] [FP8] Improve FP8 linear layer performance ( vllm-project#4691 ) â€¦ 56c100c This PR improves the FP8 performance of linear layers, which had been lacking before ( vllm-project#4118 (comment) and vllm-project#4118 (comment)).\n\nWe noticed that CUBLASLt can find a better algorithm if the first dimension of the matrix is greater than 16. So this PR enlarges matrices appropriately during quantization. This improves FP8 performance and removes the performance regression vs. FP16, in many cases exceeding FP16 performance.\n\nHere are benchmarks on llama3 70b (ITL numbers for 1000 input and 50 output tokens at fixed qps and at TP 4), all FP8 measurements are for dynamic quantization:\n\nqps = 1: 24 ms (FP8, this PR), 32 ms (FP8, previous main), 26 ms (FP16)\nqps = 2: 26 ms (FP8, this PR), 34ms (FP8, previous main), 28 ms (FP16) \nqps = 4: 33 ms (FP8, this PR), 44 ms (FP8, previous main), 36 ms (FP16)\nqps = 6: 46 ms (FP8, this PR), 56 ms (FP8, previous main), 54 ms (FP16)\nqps = 8: 85 ms (FP8, this PR), 85 ms (FP8, previous main), 138 ms (FP16) dtrifiro pushed a commit\n        to dtrifiro/vllm\n      that referenced\n      this pull request May 21, 2024 [Kernel] [FP8] Improve FP8 linear layer performance ( vllm-project#4691 ) â€¦ d7e6b3f This PR improves the FP8 performance of linear layers, which had been lacking before ( vllm-project#4118 (comment) and vllm-project#4118 (comment)).\n\nWe noticed that CUBLASLt can find a better algorithm if the first dimension of the matrix is greater than 16. So this PR enlarges matrices appropriately during quantization. This improves FP8 performance and removes the performance regression vs. FP16, in many cases exceeding FP16 performance.\n\nHere are benchmarks on llama3 70b (ITL numbers for 1000 input and 50 output tokens at fixed qps and at TP 4), all FP8 measurements are for dynamic quantization:\n\nqps = 1: 24 ms (FP8, this PR), 32 ms (FP8, previous main), 26 ms (FP16)\nqps = 2: 26 ms (FP8, this PR), 34ms (FP8, previous main), 28 ms (FP16) \nqps = 4: 33 ms (FP8, this PR), 44 ms (FP8, previous main), 36 ms (FP16)\nqps = 6: 46 ms (FP8, this PR), 56 ms (FP8, previous main), 54 ms (FP16)\nqps = 8: 85 ms (FP8, this PR), 85 ms (FP8, previous main), 138 ms (FP16) Sign up for free to join this conversation on GitHub .\n    Already have an account? Sign in to comment",
  "timeline_extracted_at": "2025-09-07 17:48:57",
  "has_lm_eval": false,
  "has_performance": true,
  "has_serving": true,
  "has_general_test": true,
  "test_details": "PERF: qps, qps, qps | SERVING: API server, OpenAI API server, Frontend | TEST: test, testing, CI",
  "analysis_extracted_at": "2025-09-07 17:48:57",
  "models": [
    "meta-llama/Meta-Llama-3-70B"
  ],
  "lm_eval_commands": [
    "lm_eval --model vllm --model_args pretrained=meta-llama/Meta-Llama-3-70B,tensor_parallel_size=4,quantization=fp8 --tasks lambada_openai --batch_size auto"
  ],
  "perf_command": "python benchmarks/benchmark_serving.py --model meta-llama/Meta-Llama-3-70B --input-len 1000 --output-len 50 --tensor-parallel-size 4 --quantization fp8",
  "commit_subject": "[Kernel] [FP8] Improve FP8 linear layer performance (#4691)",
  "commit_message": "[Kernel] [FP8] Improve FP8 linear layer performance (#4691)\n\nThis PR improves the FP8 performance of linear layers, which had been lacking before (#4118 (comment) and #4118 (comment)).\n\nWe noticed that CUBLASLt can find a better algorithm if the first dimension of the matrix is greater than 16. So this PR enlarges matrices appropriately during quantization. This improves FP8 performance and removes the performance regression vs. FP16, in many cases exceeding FP16 performance.\n\nHere are benchmarks on llama3 70b (ITL numbers for 1000 input and 50 output tokens at fixed qps and at TP 4), all FP8 measurements are for dynamic quantization:\n\nqps = 1: 24 ms (FP8, this PR), 32 ms (FP8, previous main), 26 ms (FP16)\nqps = 2: 26 ms (FP8, this PR), 34ms (FP8, previous main), 28 ms (FP16) \nqps = 4: 33 ms (FP8, this PR), 44 ms (FP8, previous main), 36 ms (FP16)\nqps = 6: 46 ms (FP8, this PR), 56 ms (FP8, previous main), 54 ms (FP16)\nqps = 8: 85 ms (FP8, this PR), 85 ms (FP8, previous main), 138 ms (FP16)",
  "commit_date": "2024-05-09T16:38:07-07:00",
  "files_changed": [
    "vllm/_custom_ops.py",
    "vllm/model_executor/layers/quantization/fp8.py"
  ],
  "functions_changed": [],
  "stats": {
    "num_test_files": 0,
    "num_non_test_files": 2,
    "only_test_files": 0,
    "only_non_test_files": 1,
    "num_files": 2,
    "num_hunks": 3,
    "num_edited_lines": 41,
    "num_non_test_edited_lines": 41,
    "commit_year": 2024
  },
  "diff_text": "diff --git a/vllm/_custom_ops.py b/vllm/_custom_ops.py\nindex 5b5643748..829c47003 100644\n--- a/vllm/_custom_ops.py\n+++ b/vllm/_custom_ops.py\n@@ -189,8 +189,34 @@ def gptq_marlin_gemm(a: torch.Tensor, b_q_weight: torch.Tensor,\n def scaled_fp8_quant(\n     input: torch.Tensor,\n     scale: Optional[torch.Tensor] = None,\n+    batch_dim_padding: Optional[int] = None,\n ) -> Tuple[torch.Tensor, torch.Tensor]:\n-    output = torch.empty_like(input, dtype=torch.float8_e4m3fn)\n+    \"\"\"\n+    Quantize input tensor to FP8 and return quantized tensor and scale.\n+\n+    This function supports both static and dynamic quantization: If you\n+    provide the scale, it will use static scaling and if you omit it,\n+    the scale will be determined dynamically. The function also allows\n+    optional padding of the output tensor for downstream kernels that\n+    will benefit from padding.\n+\n+    Args:\n+        input: The input tensor to be quantized to FP8\n+        scale: Optional scaling factor for the FP8 quantization\n+        batch_dim_padding: If specified, pad the first dimension\n+            of the output to at least this value.\n+\n+    Returns:\n+        Tuple[torch.Tensor, torch.Tensor]: The output tensor in FP8 and\n+            scaling factor.\n+    \"\"\"\n+    if batch_dim_padding:\n+        shape = (max(batch_dim_padding, input.shape[0]), *input.shape[1:])\n+        output = torch.empty(shape,\n+                             device=input.device,\n+                             dtype=torch.float8_e4m3fn)\n+    else:\n+        output = torch.empty_like(input, dtype=torch.float8_e4m3fn)\n     if scale is None:\n         scale = torch.zeros(1, device=input.device, dtype=torch.float32)\n         vllm_ops.dynamic_scaled_fp8_quant(output, input, scale)\ndiff --git a/vllm/model_executor/layers/quantization/fp8.py b/vllm/model_executor/layers/quantization/fp8.py\nindex b57e1dde8..ff996741c 100644\n--- a/vllm/model_executor/layers/quantization/fp8.py\n+++ b/vllm/model_executor/layers/quantization/fp8.py\n@@ -231,9 +231,14 @@ class Fp8LinearMethod(LinearMethodBase):\n         # ops.scaled_fp8_quant supports both dynamic and static quant.\n         #   If dynamic, layer.act_scale is None and x_scale computed from x.\n         #   If static,  layer.act_scale is scalar and x_scale set to act_scale.\n-        qinput, x_scale = ops.scaled_fp8_quant(x, layer.act_scale)\n-\n-        # Fused GEMM_DQ\n+        qinput, x_scale = ops.scaled_fp8_quant(x,\n+                                               layer.act_scale,\n+                                               batch_dim_padding=17)\n+\n+        # Fused GEMM_DQ -- note we padded the input above because\n+        # torch._scaled_mm is more performant for matrices with\n+        # batch dimension > 16. Note that this could change\n+        # in the future.\n         output, _ = torch._scaled_mm(\n             qinput,\n             layer.weight,\n@@ -243,7 +248,7 @@ class Fp8LinearMethod(LinearMethodBase):\n             bias=bias,\n         )\n \n-        return output\n+        return torch.narrow(output, 0, 0, x.shape[0])\n \n \n def all_close_1d(x: torch.Tensor) -> bool:",
  "apis": [
    "vllm._custom_ops.scaled_fp8_quant",
    "vllm.model_executor.layers.quantization.fp8.Fp8LinearMethod.apply"
  ],
  "affected_paths": [
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/model_executor/layers/quantization/fp8.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/_custom_ops.py",
    "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm/vllm/model_executor/layers/linear.py"
  ],
  "repo_path": "/Users/fortuna/buckets/gso_bucket/analysis/repos/vllm",
  "llm_reason": "The commit modifies two source files (vllm/_custom_ops.py and vllm/model_executor/layers/quantization/fp8.py), both of which are non-test files. The modifications introduce a new parameter (batch_dim_padding) to pad the input matrix's first dimension during FP8 quantization, thereby enabling a more efficient GEMM_DQ operation via torch._scaled_mm when the first dimension exceeds 16. The commit message clearly explains that this change is targeted at performance improvement, specifically enhancing FP8 linear layer performance by optimizing matrix dimension padding. There is no indication that the change is merely a bug fix, refactoring, or addition of a new feature; it is directly focused on performance optimization that is testable on CPU.",
  "llm_api_reason": "The commit adds a new optional parameter, \"batch_dim_padding\", to the FP8 quantization function in the custom ops module. When provided, this parameter causes the output tensor to be padded along the batch (first) dimension so that its size is at least the given value. In the FP8 linear method (Fp8LinearMethod.apply), the call to the scaled FP8 quantization function is updated to include a fixed padding value (17) to improve performance by aligning the matrixâ€™s batch dimension to a size where CUBLASLt can select a better algorithm. Finally, the output of the matrix multiply is narrowed to remove the padded rows so that it matches the original input size. These changes affect the FP8 quantization API and the FP8 linear layerâ€™s apply method."
}