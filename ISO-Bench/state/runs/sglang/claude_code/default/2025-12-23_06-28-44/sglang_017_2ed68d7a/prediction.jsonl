{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-e984d50", "model_patch": "diff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py\nindex 29e861e9f..61bcfb763 100644\n--- a/python/sglang/srt/disaggregation/mooncake/conn.py\n+++ b/python/sglang/srt/disaggregation/mooncake/conn.py\n@@ -106,13 +106,16 @@ class KVArgsRegisterInfo:\n \n     @classmethod\n     def from_zmq(cls, msg: List[bytes]):\n+        # Optimized: compute format strings once\n+        kv_count = len(msg[4]) // 8\n+        aux_count = len(msg[5]) // 8\n         return cls(\n             room=str(msg[0].decode(\"ascii\")),\n             endpoint=msg[1].decode(\"ascii\"),\n             dst_port=int(msg[2].decode(\"ascii\")),\n             mooncake_session_id=msg[3].decode(\"ascii\"),\n-            dst_kv_ptrs=list(struct.unpack(f\"{len(msg[4])//8}Q\", msg[4])),\n-            dst_aux_ptrs=list(struct.unpack(f\"{len(msg[5])//8}Q\", msg[5])),\n+            dst_kv_ptrs=list(struct.unpack(f\"{kv_count}Q\", msg[4])),\n+            dst_aux_ptrs=list(struct.unpack(f\"{aux_count}Q\", msg[5])),\n         )\n \n \n@@ -146,6 +149,8 @@ class MooncakeKVManager(BaseKVManager):\n         self.request_status: Dict[int, KVPoll] = {}\n         self.rank_port = None\n         self.server_socket = zmq.Context().socket(zmq.PULL)\n+        # Cache for session port extraction to avoid repeated string splits\n+        self._session_port_cache: Dict[str, int] = {}\n         self.register_buffer_to_engine()\n         if self.disaggregation_mode == DisaggregationMode.PREFILL:\n             self.transfer_infos: Dict[int, Dict[str, TransferInfo]] = {}\n@@ -250,13 +255,15 @@ class MooncakeKVManager(BaseKVManager):\n         ]\n \n         # Worker function for processing a single layer\n+        # Optimized: reduce function call overhead in tight loop\n+        engine_transfer = self.engine.transfer_sync\n         def process_layer(src_ptr: int, dst_ptr: int, item_len: int) -> int:\n             for prefill_index, decode_index in zip(prefill_kv_blocks, dst_kv_blocks):\n                 src_addr = src_ptr + int(prefill_index[0]) * item_len\n                 dst_addr = dst_ptr + int(decode_index[0]) * item_len\n                 length = item_len * len(prefill_index)\n \n-                status = self.engine.transfer_sync(\n+                status = engine_transfer(\n                     mooncake_session_id, src_addr, dst_addr, length\n                 )\n                 if status != 0:\n@@ -302,9 +309,11 @@ class MooncakeKVManager(BaseKVManager):\n     def sync_status_to_decode_endpoint(\n         self, remote: str, dst_port: int, room: int, status: int\n     ):\n+        # Optimized: avoid multiple string operations\n         if \":\" in remote:\n-            remote = remote.split(\":\")[0]\n-        self._connect(\"tcp://\" + remote + \":\" + str(dst_port)).send_multipart(\n+            remote = remote.split(\":\", 1)[0]\n+        endpoint = f\"tcp://{remote}:{dst_port}\"\n+        self._connect(endpoint).send_multipart(\n             [\n                 str(room).encode(\"ascii\"),\n                 str(status).encode(\"ascii\"),\n@@ -356,12 +365,12 @@ class MooncakeKVManager(BaseKVManager):\n                                 f\"len(chunked_dst_kv_indice) = {len(chunked_dst_kv_indice)}, len(kv_chunk.prefill_kv_indices) = {len(kv_chunk.prefill_kv_indices)}\"\n                             )\n \n+                        # Optimized: cache table lookup\n+                        decode_kv_args = self.decode_kv_args_table[req.mooncake_session_id]\n                         ret = self.send_kvcache(\n                             req.mooncake_session_id,\n                             kv_chunk.prefill_kv_indices,\n-                            self.decode_kv_args_table[\n-                                req.mooncake_session_id\n-                            ].dst_kv_ptrs,\n+                            decode_kv_args.dst_kv_ptrs,\n                             chunked_dst_kv_indice,\n                             executor,\n                         )\n@@ -386,12 +395,11 @@ class MooncakeKVManager(BaseKVManager):\n \n                         if kv_chunk.is_last:\n                             # Only the last chunk we need to send the aux data\n+                            # Reuse the cached decode_kv_args from above\n                             ret = self.send_aux(\n                                 req.mooncake_session_id,\n                                 kv_chunk.prefill_aux_index,\n-                                self.decode_kv_args_table[\n-                                    req.mooncake_session_id\n-                                ].dst_aux_ptrs,\n+                                decode_kv_args.dst_aux_ptrs,\n                                 req.dst_aux_index,\n                             )\n                             polls.append(True if ret == 0 else False)\n@@ -568,7 +576,12 @@ class MooncakeKVManager(BaseKVManager):\n         # requests with the same dst_sessions will be added into the same\n         # queue, which enables early abort with failed sessions.\n         dst_infos = self.transfer_infos[bootstrap_room].keys()\n-        session_port_sum = sum(int(session.split(\":\")[1]) for session in dst_infos)\n+        # Optimized: cache session port extraction to avoid repeated splits\n+        session_port_sum = 0\n+        for session in dst_infos:\n+            if session not in self._session_port_cache:\n+                self._session_port_cache[session] = int(session.split(\":\")[1])\n+            session_port_sum += self._session_port_cache[session]\n         shard_idx = session_port_sum % len(self.transfer_queues)\n \n         self.transfer_queues[shard_idx].put(\n@@ -937,12 +950,11 @@ class MooncakeKVReceiver(BaseKVReceiver):\n             self.prefill_server_url = (\n                 f\"{bootstrap_info['rank_ip']}:{bootstrap_info['rank_port']}\"\n             )\n-            packed_kv_data_ptrs = b\"\".join(\n-                struct.pack(\"Q\", ptr) for ptr in self.kv_mgr.kv_args.kv_data_ptrs\n-            )\n-            packed_aux_data_ptrs = b\"\".join(\n-                struct.pack(\"Q\", ptr) for ptr in self.kv_mgr.kv_args.aux_data_ptrs\n-            )\n+            # Optimized: use single struct.pack call instead of join\n+            kv_ptrs = self.kv_mgr.kv_args.kv_data_ptrs\n+            packed_kv_data_ptrs = struct.pack(f\"{len(kv_ptrs)}Q\", *kv_ptrs)\n+            aux_ptrs = self.kv_mgr.kv_args.aux_data_ptrs\n+            packed_aux_data_ptrs = struct.pack(f\"{len(aux_ptrs)}Q\", *aux_ptrs)\n \n             sock, lock = self._connect(\"tcp://\" + self.prefill_server_url)\n             with lock:\ndiff --git a/python/sglang/srt/disaggregation/mooncake/transfer_engine.py b/python/sglang/srt/disaggregation/mooncake/transfer_engine.py\nindex 5643af70b..ad8d2ccad 100644\n--- a/python/sglang/srt/disaggregation/mooncake/transfer_engine.py\n+++ b/python/sglang/srt/disaggregation/mooncake/transfer_engine.py\n@@ -32,21 +32,19 @@ class MooncakeTransferEngine:\n     def register(self, ptr, length):\n         try:\n             ret_value = self.engine.register_memory(ptr, length)\n+            if ret_value != 0:\n+                logger.debug(\"Mooncake memory registration %s failed.\", ptr)\n         except Exception:\n-            # Mark register as failed\n-            ret_value = -1\n-\n-        if ret_value != 0:\n+            # Mark register as failed and log\n             logger.debug(\"Mooncake memory registration %s failed.\", ptr)\n \n     def deregister(self, ptr):\n         try:\n             ret_value = self.engine.unregister_memory(ptr)\n+            if ret_value != 0:\n+                logger.debug(\"Mooncake memory deregistration %s failed.\", ptr)\n         except Exception:\n-            # Mark deregister as failed\n-            ret_value = -1\n-\n-        if ret_value != 0:\n+            # Mark deregister as failed and log\n             logger.debug(\"Mooncake memory deregistration %s failed.\", ptr)\n \n     def initialize(\n", "model_name_or_path": "gpt-5-2025-08-07"}
