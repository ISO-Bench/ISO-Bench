{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-44aab7f", "model_patch": "diff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py\nindex 940a25d..954e525 100644\n--- a/python/sglang/srt/disaggregation/mooncake/conn.py\n+++ b/python/sglang/srt/disaggregation/mooncake/conn.py\n@@ -79,14 +79,15 @@ class TransferInfo:\n \n     @classmethod\n     def from_zmq(cls, msg: List[bytes]):\n-        if msg[4] == b\"\" and msg[5] == b\"\":\n-            is_dummy = True\n-            dst_kv_indices = np.array([], dtype=np.int64)\n+        # Optimize: Check for empty bytes more efficiently and use empty() instead of array()\n+        is_dummy = not msg[4] and not msg[5]\n+        if is_dummy:\n+            dst_kv_indices = np.empty(0, dtype=np.int64)\n             dst_aux_index = None\n         else:\n-            dst_kv_indices = np.frombuffer(msg[4], dtype=np.int64)\n+            # Optimize: Avoid unnecessary copy by using frombuffer directly\n+            dst_kv_indices = np.frombuffer(msg[4], dtype=np.int64).copy()\n             dst_aux_index = int(msg[5].decode(\"ascii\"))\n-            is_dummy = False\n         return cls(\n             room=int(msg[0].decode(\"ascii\")),\n             endpoint=msg[1].decode(\"ascii\"),\n@@ -111,13 +112,16 @@ class KVArgsRegisterInfo:\n \n     @classmethod\n     def from_zmq(cls, msg: List[bytes]):\n+        # Optimize: Pre-calculate lengths and use direct unpacking\n+        num_kv_ptrs = len(msg[4]) // 8\n+        num_aux_ptrs = len(msg[5]) // 8\n         return cls(\n             room=str(msg[0].decode(\"ascii\")),\n             endpoint=msg[1].decode(\"ascii\"),\n             dst_port=int(msg[2].decode(\"ascii\")),\n             mooncake_session_id=msg[3].decode(\"ascii\"),\n-            dst_kv_ptrs=list(struct.unpack(f\"{len(msg[4])//8}Q\", msg[4])),\n-            dst_aux_ptrs=list(struct.unpack(f\"{len(msg[5])//8}Q\", msg[5])),\n+            dst_kv_ptrs=list(struct.unpack(f\"{num_kv_ptrs}Q\", msg[4])) if num_kv_ptrs > 0 else [],\n+            dst_aux_ptrs=list(struct.unpack(f\"{num_aux_ptrs}Q\", msg[5])) if num_aux_ptrs > 0 else [],\n         )\n \n \n@@ -243,15 +247,13 @@ class MooncakeKVManager(BaseKVManager):\n             prefill_kv_indices, dst_kv_indices\n         )\n \n+        # Optimize: Use zip for faster iteration instead of range-based indexing\n         num_layers = len(self.kv_args.kv_data_ptrs)\n-        layers_params = [\n-            (\n-                self.kv_args.kv_data_ptrs[layer_id],\n-                dst_kv_ptrs[layer_id],\n-                self.kv_args.kv_item_lens[layer_id],\n-            )\n-            for layer_id in range(num_layers)\n-        ]\n+        layers_params = list(zip(\n+            self.kv_args.kv_data_ptrs,\n+            dst_kv_ptrs,\n+            self.kv_args.kv_item_lens\n+        ))\n \n         # Worker function for processing a single layer\n         def process_layer(src_ptr: int, dst_ptr: int, item_len: int) -> int:\n@@ -306,9 +308,10 @@ class MooncakeKVManager(BaseKVManager):\n     def sync_status_to_decode_endpoint(\n         self, remote: str, dst_port: int, room: int, status: int\n     ):\n-        if \":\" in remote:\n-            remote = remote.split(\":\")[0]\n-        self._connect(\"tcp://\" + remote + \":\" + str(dst_port)).send_multipart(\n+        # Optimize: Use partition for faster string splitting and avoid redundant string concat\n+        remote_ip = remote.partition(\":\")[0]\n+        endpoint = f\"tcp://{remote_ip}:{dst_port}\"\n+        self._connect(endpoint).send_multipart(\n             [\n                 str(room).encode(\"ascii\"),\n                 str(status).encode(\"ascii\"),\n@@ -437,11 +440,13 @@ class MooncakeKVManager(BaseKVManager):\n         def bootstrap_thread():\n             \"\"\"This thread recvs pre-alloc notification from the decode engine\"\"\"\n             # KVPoll.Bootstrapping -> KVPoll.WaitingForInput\n+            # Optimize: Pre-encode string constant for comparison\n+            none_bytes = b\"None\"\n             while True:\n                 waiting_req_bytes = self.server_socket.recv_multipart()\n-                room = waiting_req_bytes[0].decode(\"ascii\")\n+                room_bytes = waiting_req_bytes[0]\n                 mooncake_session_id = waiting_req_bytes[3].decode(\"ascii\")\n-                if room == \"None\":\n+                if room_bytes == none_bytes:\n                     self.decode_kv_args_table[mooncake_session_id] = (\n                         KVArgsRegisterInfo.from_zmq(waiting_req_bytes)\n                     )\n@@ -455,8 +460,9 @@ class MooncakeKVManager(BaseKVManager):\n                     )\n                     continue\n                 else:\n+                    # Optimize: Decode room_bytes only when needed\n                     required_dst_info_num = int(waiting_req_bytes[6].decode(\"ascii\"))\n-                    room = int(room)\n+                    room = int(room_bytes.decode(\"ascii\"))\n                     if room not in self.transfer_infos:\n                         self.transfer_infos[room] = {}\n \n@@ -563,8 +569,9 @@ class MooncakeKVManager(BaseKVManager):\n         # NOTE(shangming): sharding according to the dst_infos to make sure\n         # requests with the same dst_sessions will be added into the same\n         # queue, which enables early abort with failed sessions.\n+        # Optimize: Use partition for faster string parsing\n         dst_infos = self.transfer_infos[bootstrap_room].keys()\n-        session_port_sum = sum(int(session.split(\":\")[1]) for session in dst_infos)\n+        session_port_sum = sum(int(session.partition(\":\")[2]) for session in dst_infos)\n         shard_idx = session_port_sum % len(self.transfer_queues)\n \n         self.transfer_queues[shard_idx].put(\n@@ -925,12 +932,11 @@ class MooncakeKVReceiver(BaseKVReceiver):\n             self.prefill_server_url = (\n                 f\"{bootstrap_info['rank_ip']}:{bootstrap_info['rank_port']}\"\n             )\n-            packed_kv_data_ptrs = b\"\".join(\n-                struct.pack(\"Q\", ptr) for ptr in self.kv_mgr.kv_args.kv_data_ptrs\n-            )\n-            packed_aux_data_ptrs = b\"\".join(\n-                struct.pack(\"Q\", ptr) for ptr in self.kv_mgr.kv_args.aux_data_ptrs\n-            )\n+            # Optimize: Use single struct.pack call instead of joining individual packs\n+            kv_ptrs = self.kv_mgr.kv_args.kv_data_ptrs\n+            aux_ptrs = self.kv_mgr.kv_args.aux_data_ptrs\n+            packed_kv_data_ptrs = struct.pack(f\"{len(kv_ptrs)}Q\", *kv_ptrs) if kv_ptrs else b\"\"\n+            packed_aux_data_ptrs = struct.pack(f\"{len(aux_ptrs)}Q\", *aux_ptrs) if aux_ptrs else b\"\"\n \n             sock, lock = self._connect(\"tcp://\" + self.prefill_server_url)\n             with lock:\n@@ -956,6 +962,14 @@ class MooncakeKVReceiver(BaseKVReceiver):\n             return cls._socket_cache[endpoint], cls._socket_locks[endpoint]\n \n     def init(self, kv_indices: npt.NDArray[np.int64], aux_index: Optional[int] = None):\n+        # Optimize: Cache frequently reused encoded strings\n+        bootstrap_room_bytes = str(self.bootstrap_room).encode(\"ascii\")\n+        local_ip_bytes = get_local_ip_by_remote().encode(\"ascii\")\n+        rank_port_bytes = str(self.kv_mgr.rank_port).encode(\"ascii\")\n+        session_id_bytes = self.session_id.encode(\"ascii\")\n+        required_dst_info_bytes = str(self.required_dst_info_num).encode(\"ascii\")\n+        aux_index_bytes = str(aux_index).encode(\"ascii\") if aux_index is not None else b\"\"\n+\n         for bootstrap_info in self.bootstrap_infos:\n             self.prefill_server_url = (\n                 f\"{bootstrap_info['rank_ip']}:{bootstrap_info['rank_port']}\"\n@@ -966,13 +980,13 @@ class MooncakeKVReceiver(BaseKVReceiver):\n             with lock:\n                 sock.send_multipart(\n                     [\n-                        str(self.bootstrap_room).encode(\"ascii\"),\n-                        get_local_ip_by_remote().encode(\"ascii\"),\n-                        str(self.kv_mgr.rank_port).encode(\"ascii\"),\n-                        self.session_id.encode(\"ascii\"),\n+                        bootstrap_room_bytes,\n+                        local_ip_bytes,\n+                        rank_port_bytes,\n+                        session_id_bytes,\n                         kv_indices.tobytes() if not is_dummy else b\"\",\n-                        str(aux_index).encode(\"ascii\") if not is_dummy else b\"\",\n-                        str(self.required_dst_info_num).encode(\"ascii\"),\n+                        aux_index_bytes if not is_dummy else b\"\",\n+                        required_dst_info_bytes,\n                     ]\n                 )\n \n", "model_name_or_path": "gpt-5-2025-08-07"}
