{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-b1c8d4e", "model_patch": "diff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py\nindex 8ab5066..6ab8d9c 100644\n--- a/python/sglang/srt/disaggregation/mooncake/conn.py\n+++ b/python/sglang/srt/disaggregation/mooncake/conn.py\n@@ -227,11 +227,14 @@ class MooncakeKVManager(BaseKVManager):\n         )\n \n         num_layers = len(self.kv_args.kv_data_ptrs)\n+        # Cache attributes to avoid repeated lookups\n+        kv_data_ptrs = self.kv_args.kv_data_ptrs\n+        kv_item_lens = self.kv_args.kv_item_lens\n         layers_params = [\n             (\n-                self.kv_args.kv_data_ptrs[layer_id],\n+                kv_data_ptrs[layer_id],\n                 dst_kv_ptrs[layer_id],\n-                self.kv_args.kv_item_lens[layer_id],\n+                kv_item_lens[layer_id],\n             )\n             for layer_id in range(num_layers)\n         ]\n@@ -239,8 +242,9 @@ class MooncakeKVManager(BaseKVManager):\n         # Worker function for processing a single layer\n         def process_layer(src_ptr: int, dst_ptr: int, item_len: int) -> int:\n             for prefill_index, decode_index in zip(prefill_kv_blocks, dst_kv_blocks):\n-                src_addr = src_ptr + int(prefill_index[0]) * item_len\n-                dst_addr = dst_ptr + int(decode_index[0]) * item_len\n+                # Avoid unnecessary int() conversions in hot loop\n+                src_addr = src_ptr + prefill_index[0] * item_len\n+                dst_addr = dst_ptr + decode_index[0] * item_len\n                 length = item_len * len(prefill_index)\n \n                 status = self.engine.transfer_sync(\n@@ -291,7 +295,8 @@ class MooncakeKVManager(BaseKVManager):\n     ):\n         if \":\" in remote:\n             remote = remote.split(\":\")[0]\n-        self._connect(\"tcp://\" + remote + \":\" + str(dst_port)).send_multipart(\n+        # Use f-string for more efficient string concatenation\n+        self._connect(f\"tcp://{remote}:{dst_port}\").send_multipart(\n             [\n                 str(room).encode(\"ascii\"),\n                 str(status).encode(\"ascii\"),\n@@ -907,25 +912,35 @@ class MooncakeKVReceiver(BaseKVReceiver):\n             return None, None\n \n     def _register_kv_args(self):\n+        # Pre-pack data pointers once to avoid repeated packing\n+        kv_data_ptrs = self.kv_mgr.kv_args.kv_data_ptrs\n+        aux_data_ptrs = self.kv_mgr.kv_args.aux_data_ptrs\n+        packed_kv_data_ptrs = b\"\".join(\n+            struct.pack(\"Q\", ptr) for ptr in kv_data_ptrs\n+        )\n+        packed_aux_data_ptrs = b\"\".join(\n+            struct.pack(\"Q\", ptr) for ptr in aux_data_ptrs\n+        )\n+\n+        # Cache encoded strings to avoid repeated encoding\n+        none_encoded = b\"None\"\n+        local_ip_encoded = get_local_ip_by_remote().encode(\"ascii\")\n+        rank_port_encoded = str(self.kv_mgr.rank_port).encode(\"ascii\")\n+        session_id_encoded = self.session_id.encode(\"ascii\")\n+\n         for bootstrap_info in self.bootstrap_infos:\n             self.prefill_server_url = (\n                 f\"{bootstrap_info['rank_ip']}:{bootstrap_info['rank_port']}\"\n             )\n-            packed_kv_data_ptrs = b\"\".join(\n-                struct.pack(\"Q\", ptr) for ptr in self.kv_mgr.kv_args.kv_data_ptrs\n-            )\n-            packed_aux_data_ptrs = b\"\".join(\n-                struct.pack(\"Q\", ptr) for ptr in self.kv_mgr.kv_args.aux_data_ptrs\n-            )\n \n-            sock, lock = self._connect(\"tcp://\" + self.prefill_server_url)\n+            sock, lock = self._connect(f\"tcp://{self.prefill_server_url}\")\n             with lock:\n                 sock.send_multipart(\n                     [\n-                        \"None\".encode(\"ascii\"),\n-                        get_local_ip_by_remote().encode(\"ascii\"),\n-                        str(self.kv_mgr.rank_port).encode(\"ascii\"),\n-                        self.session_id.encode(\"ascii\"),\n+                        none_encoded,\n+                        local_ip_encoded,\n+                        rank_port_encoded,\n+                        session_id_encoded,\n                         packed_kv_data_ptrs,\n                         packed_aux_data_ptrs,\n                     ]\n@@ -942,23 +957,32 @@ class MooncakeKVReceiver(BaseKVReceiver):\n             return cls._socket_cache[endpoint], cls._socket_locks[endpoint]\n \n     def init(self, kv_indices: npt.NDArray[np.int64], aux_index: Optional[int] = None):\n+        # Cache encoded strings outside loop\n+        bootstrap_room_encoded = str(self.bootstrap_room).encode(\"ascii\")\n+        local_ip_encoded = get_local_ip_by_remote().encode(\"ascii\")\n+        rank_port_encoded = str(self.kv_mgr.rank_port).encode(\"ascii\")\n+        session_id_encoded = self.session_id.encode(\"ascii\")\n+        required_dst_info_num_encoded = str(self.required_dst_info_num).encode(\"ascii\")\n+        kv_indices_bytes = kv_indices.tobytes()\n+        aux_index_encoded = str(aux_index).encode(\"ascii\") if aux_index is not None else b\"\"\n+\n         for bootstrap_info in self.bootstrap_infos:\n             self.prefill_server_url = (\n                 f\"{bootstrap_info['rank_ip']}:{bootstrap_info['rank_port']}\"\n             )\n             is_dummy = bootstrap_info[\"is_dummy\"]\n \n-            sock, lock = self._connect(\"tcp://\" + self.prefill_server_url)\n+            sock, lock = self._connect(f\"tcp://{self.prefill_server_url}\")\n             with lock:\n                 sock.send_multipart(\n                     [\n-                        str(self.bootstrap_room).encode(\"ascii\"),\n-                        get_local_ip_by_remote().encode(\"ascii\"),\n-                        str(self.kv_mgr.rank_port).encode(\"ascii\"),\n-                        self.session_id.encode(\"ascii\"),\n-                        kv_indices.tobytes() if not is_dummy else b\"\",\n-                        str(aux_index).encode(\"ascii\") if not is_dummy else b\"\",\n-                        str(self.required_dst_info_num).encode(\"ascii\"),\n+                        bootstrap_room_encoded,\n+                        local_ip_encoded,\n+                        rank_port_encoded,\n+                        session_id_encoded,\n+                        b\"\" if is_dummy else kv_indices_bytes,\n+                        b\"\" if is_dummy else aux_index_encoded,\n+                        required_dst_info_num_encoded,\n                     ]\n                 )\n \ndiff --git a/python/sglang/srt/disaggregation/utils.py b/python/sglang/srt/disaggregation/utils.py\nindex 8841d5f..112f5cf 100644\n--- a/python/sglang/srt/disaggregation/utils.py\n+++ b/python/sglang/srt/disaggregation/utils.py\n@@ -207,17 +207,17 @@ class MetadataBuffers:\n \n         # We transfer the metadata of first output token to decode\n         # The minimal size for RDMA is 64Bytes, so we pad it to > 64Bytes\n-        self.output_ids = torch.zeros((size, 16), dtype=torch.int32, device=\"cpu\")\n-        self.output_token_logprobs_val = torch.zeros(\n+        self.output_ids = torch.empty((size, 16), dtype=torch.int32, device=\"cpu\")\n+        self.output_token_logprobs_val = torch.empty(\n             (size, 16), dtype=torch.float32, device=\"cpu\"\n         )\n-        self.output_token_logprobs_idx = torch.zeros(\n+        self.output_token_logprobs_idx = torch.empty(\n             (size, 16), dtype=torch.int32, device=\"cpu\"\n         )\n-        self.output_top_logprobs_val = torch.zeros(\n+        self.output_top_logprobs_val = torch.empty(\n             (size, max_top_logprobs_num), dtype=torch.float32, device=\"cpu\"\n         )\n-        self.output_top_logprobs_idx = torch.zeros(\n+        self.output_top_logprobs_idx = torch.empty(\n             (size, max_top_logprobs_num), dtype=torch.int32, device=\"cpu\"\n         )\n \n", "model_name_or_path": "gpt-5-2025-08-07"}
