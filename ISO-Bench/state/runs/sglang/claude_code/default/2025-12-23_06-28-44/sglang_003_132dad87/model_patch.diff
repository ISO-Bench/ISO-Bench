diff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py
index 824f76709..19e1aefc2 100644
--- a/python/sglang/srt/disaggregation/mooncake/conn.py
+++ b/python/sglang/srt/disaggregation/mooncake/conn.py
@@ -81,7 +81,8 @@ class TransferInfo:
     def from_zmq(cls, msg: List[bytes]):
         if msg[4] == b"" and msg[5] == b"":
             is_dummy = True
-            dst_kv_indices = np.array([], dtype=np.int64)
+            # Optimized: Use np.empty instead of np.array for uninitialized allocation
+            dst_kv_indices = np.empty(0, dtype=np.int64)
             dst_aux_index = None
         else:
             dst_kv_indices = np.frombuffer(msg[4], dtype=np.int64)
@@ -111,13 +112,14 @@ class KVArgsRegisterInfo:
 
     @classmethod
     def from_zmq(cls, msg: List[bytes]):
+        # Optimized: Use tuple directly instead of converting to list
         return cls(
             room=str(msg[0].decode("ascii")),
             endpoint=msg[1].decode("ascii"),
             dst_port=int(msg[2].decode("ascii")),
             mooncake_session_id=msg[3].decode("ascii"),
-            dst_kv_ptrs=list(struct.unpack(f"{len(msg[4])//8}Q", msg[4])),
-            dst_aux_ptrs=list(struct.unpack(f"{len(msg[5])//8}Q", msg[5])),
+            dst_kv_ptrs=struct.unpack(f"{len(msg[4])//8}Q", msg[4]),
+            dst_aux_ptrs=struct.unpack(f"{len(msg[5])//8}Q", msg[5]),
         )
 
 
@@ -149,7 +151,9 @@ class MooncakeKVManager(BaseKVManager):
             )
         self.request_status: Dict[int, KVPoll] = {}
         self.rank_port = None
-        self.server_socket = zmq.Context().socket(zmq.PULL)
+        # Optimized: Reuse zmq.Context instance across sockets
+        self._zmq_context = zmq.Context()
+        self.server_socket = self._zmq_context.socket(zmq.PULL)
         self.register_buffer_to_engine()
         if self.disaggregation_mode == DisaggregationMode.PREFILL:
             self.transfer_infos: Dict[int, Dict[str, TransferInfo]] = {}
@@ -226,7 +230,8 @@ class MooncakeKVManager(BaseKVManager):
 
     @cache
     def _connect(self, endpoint: str):
-        socket = zmq.Context().socket(zmq.PUSH)
+        # Optimized: Reuse existing zmq.Context instead of creating new one
+        socket = self._zmq_context.socket(zmq.PUSH)
         socket.connect(endpoint)
         return socket
 
@@ -243,15 +248,12 @@ class MooncakeKVManager(BaseKVManager):
             prefill_kv_indices, dst_kv_indices
         )
 
-        num_layers = len(self.kv_args.kv_data_ptrs)
-        layers_params = [
-            (
-                self.kv_args.kv_data_ptrs[layer_id],
-                dst_kv_ptrs[layer_id],
-                self.kv_args.kv_item_lens[layer_id],
-            )
-            for layer_id in range(num_layers)
-        ]
+        # Optimized: Use zip instead of range and indexing
+        layers_params = list(zip(
+            self.kv_args.kv_data_ptrs,
+            dst_kv_ptrs,
+            self.kv_args.kv_item_lens,
+        ))
 
         # Worker function for processing a single layer
         def process_layer(src_ptr: int, dst_ptr: int, item_len: int) -> int:
@@ -306,9 +308,11 @@ class MooncakeKVManager(BaseKVManager):
     def sync_status_to_decode_endpoint(
         self, remote: str, dst_port: int, room: int, status: int
     ):
+        # Optimized: Use f-string and limit split to 1 part
         if ":" in remote:
-            remote = remote.split(":")[0]
-        self._connect("tcp://" + remote + ":" + str(dst_port)).send_multipart(
+            remote = remote.split(":", 1)[0]
+        # Optimized: Use f-string for concatenation
+        self._connect(f"tcp://{remote}:{dst_port}").send_multipart(
             [
                 str(room).encode("ascii"),
                 str(status).encode("ascii"),
@@ -565,8 +569,9 @@ class MooncakeKVManager(BaseKVManager):
         # NOTE(shangming): sharding according to the dst_infos to make sure
         # requests with the same dst_sessions will be added into the same
         # queue, which enables early abort with failed sessions.
+        # Optimized: Cache split results and use simpler hash
         dst_infos = self.transfer_infos[bootstrap_room].keys()
-        session_port_sum = sum(int(session.split(":")[1]) for session in dst_infos)
+        session_port_sum = sum(int(session.split(":", 1)[1]) for session in dst_infos)
         shard_idx = session_port_sum % len(self.transfer_queues)
 
         self.transfer_queues[shard_idx].put(
@@ -925,12 +930,11 @@ class MooncakeKVReceiver(BaseKVReceiver):
             self.prefill_server_url = (
                 f"{bootstrap_info['rank_ip']}:{bootstrap_info['rank_port']}"
             )
-            packed_kv_data_ptrs = b"".join(
-                struct.pack("Q", ptr) for ptr in self.kv_mgr.kv_args.kv_data_ptrs
-            )
-            packed_aux_data_ptrs = b"".join(
-                struct.pack("Q", ptr) for ptr in self.kv_mgr.kv_args.aux_data_ptrs
-            )
+            # Optimized: Use single struct.pack instead of join with generator
+            kv_ptrs = self.kv_mgr.kv_args.kv_data_ptrs
+            packed_kv_data_ptrs = struct.pack(f"{len(kv_ptrs)}Q", *kv_ptrs)
+            aux_ptrs = self.kv_mgr.kv_args.aux_data_ptrs
+            packed_aux_data_ptrs = struct.pack(f"{len(aux_ptrs)}Q", *aux_ptrs)
 
             sock, lock = self._connect("tcp://" + self.prefill_server_url)
             with lock:
