{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-60fdad7", "model_patch": "diff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py\nindex 824f76709..19e1aefc2 100644\n--- a/python/sglang/srt/disaggregation/mooncake/conn.py\n+++ b/python/sglang/srt/disaggregation/mooncake/conn.py\n@@ -81,7 +81,8 @@ class TransferInfo:\n     def from_zmq(cls, msg: List[bytes]):\n         if msg[4] == b\"\" and msg[5] == b\"\":\n             is_dummy = True\n-            dst_kv_indices = np.array([], dtype=np.int64)\n+            # Optimized: Use np.empty instead of np.array for uninitialized allocation\n+            dst_kv_indices = np.empty(0, dtype=np.int64)\n             dst_aux_index = None\n         else:\n             dst_kv_indices = np.frombuffer(msg[4], dtype=np.int64)\n@@ -111,13 +112,14 @@ class KVArgsRegisterInfo:\n \n     @classmethod\n     def from_zmq(cls, msg: List[bytes]):\n+        # Optimized: Use tuple directly instead of converting to list\n         return cls(\n             room=str(msg[0].decode(\"ascii\")),\n             endpoint=msg[1].decode(\"ascii\"),\n             dst_port=int(msg[2].decode(\"ascii\")),\n             mooncake_session_id=msg[3].decode(\"ascii\"),\n-            dst_kv_ptrs=list(struct.unpack(f\"{len(msg[4])//8}Q\", msg[4])),\n-            dst_aux_ptrs=list(struct.unpack(f\"{len(msg[5])//8}Q\", msg[5])),\n+            dst_kv_ptrs=struct.unpack(f\"{len(msg[4])//8}Q\", msg[4]),\n+            dst_aux_ptrs=struct.unpack(f\"{len(msg[5])//8}Q\", msg[5]),\n         )\n \n \n@@ -149,7 +151,9 @@ class MooncakeKVManager(BaseKVManager):\n             )\n         self.request_status: Dict[int, KVPoll] = {}\n         self.rank_port = None\n-        self.server_socket = zmq.Context().socket(zmq.PULL)\n+        # Optimized: Reuse zmq.Context instance across sockets\n+        self._zmq_context = zmq.Context()\n+        self.server_socket = self._zmq_context.socket(zmq.PULL)\n         self.register_buffer_to_engine()\n         if self.disaggregation_mode == DisaggregationMode.PREFILL:\n             self.transfer_infos: Dict[int, Dict[str, TransferInfo]] = {}\n@@ -226,7 +230,8 @@ class MooncakeKVManager(BaseKVManager):\n \n     @cache\n     def _connect(self, endpoint: str):\n-        socket = zmq.Context().socket(zmq.PUSH)\n+        # Optimized: Reuse existing zmq.Context instead of creating new one\n+        socket = self._zmq_context.socket(zmq.PUSH)\n         socket.connect(endpoint)\n         return socket\n \n@@ -243,15 +248,12 @@ class MooncakeKVManager(BaseKVManager):\n             prefill_kv_indices, dst_kv_indices\n         )\n \n-        num_layers = len(self.kv_args.kv_data_ptrs)\n-        layers_params = [\n-            (\n-                self.kv_args.kv_data_ptrs[layer_id],\n-                dst_kv_ptrs[layer_id],\n-                self.kv_args.kv_item_lens[layer_id],\n-            )\n-            for layer_id in range(num_layers)\n-        ]\n+        # Optimized: Use zip instead of range and indexing\n+        layers_params = list(zip(\n+            self.kv_args.kv_data_ptrs,\n+            dst_kv_ptrs,\n+            self.kv_args.kv_item_lens,\n+        ))\n \n         # Worker function for processing a single layer\n         def process_layer(src_ptr: int, dst_ptr: int, item_len: int) -> int:\n@@ -306,9 +308,11 @@ class MooncakeKVManager(BaseKVManager):\n     def sync_status_to_decode_endpoint(\n         self, remote: str, dst_port: int, room: int, status: int\n     ):\n+        # Optimized: Use f-string and limit split to 1 part\n         if \":\" in remote:\n-            remote = remote.split(\":\")[0]\n-        self._connect(\"tcp://\" + remote + \":\" + str(dst_port)).send_multipart(\n+            remote = remote.split(\":\", 1)[0]\n+        # Optimized: Use f-string for concatenation\n+        self._connect(f\"tcp://{remote}:{dst_port}\").send_multipart(\n             [\n                 str(room).encode(\"ascii\"),\n                 str(status).encode(\"ascii\"),\n@@ -565,8 +569,9 @@ class MooncakeKVManager(BaseKVManager):\n         # NOTE(shangming): sharding according to the dst_infos to make sure\n         # requests with the same dst_sessions will be added into the same\n         # queue, which enables early abort with failed sessions.\n+        # Optimized: Cache split results and use simpler hash\n         dst_infos = self.transfer_infos[bootstrap_room].keys()\n-        session_port_sum = sum(int(session.split(\":\")[1]) for session in dst_infos)\n+        session_port_sum = sum(int(session.split(\":\", 1)[1]) for session in dst_infos)\n         shard_idx = session_port_sum % len(self.transfer_queues)\n \n         self.transfer_queues[shard_idx].put(\n@@ -925,12 +930,11 @@ class MooncakeKVReceiver(BaseKVReceiver):\n             self.prefill_server_url = (\n                 f\"{bootstrap_info['rank_ip']}:{bootstrap_info['rank_port']}\"\n             )\n-            packed_kv_data_ptrs = b\"\".join(\n-                struct.pack(\"Q\", ptr) for ptr in self.kv_mgr.kv_args.kv_data_ptrs\n-            )\n-            packed_aux_data_ptrs = b\"\".join(\n-                struct.pack(\"Q\", ptr) for ptr in self.kv_mgr.kv_args.aux_data_ptrs\n-            )\n+            # Optimized: Use single struct.pack instead of join with generator\n+            kv_ptrs = self.kv_mgr.kv_args.kv_data_ptrs\n+            packed_kv_data_ptrs = struct.pack(f\"{len(kv_ptrs)}Q\", *kv_ptrs)\n+            aux_ptrs = self.kv_mgr.kv_args.aux_data_ptrs\n+            packed_aux_data_ptrs = struct.pack(f\"{len(aux_ptrs)}Q\", *aux_ptrs)\n \n             sock, lock = self._connect(\"tcp://\" + self.prefill_server_url)\n             with lock:\n", "model_name_or_path": "gpt-5-2025-08-07"}
