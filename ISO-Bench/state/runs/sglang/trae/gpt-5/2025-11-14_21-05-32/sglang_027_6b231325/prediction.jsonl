{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-b1c8d4e", "model_patch": "diff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py\nindex 8ab5066ec..747bf7958 100644\n--- a/python/sglang/srt/disaggregation/mooncake/conn.py\n+++ b/python/sglang/srt/disaggregation/mooncake/conn.py\n@@ -31,6 +31,7 @@ from sglang.srt.disaggregation.base.conn import (\n from sglang.srt.disaggregation.mooncake.transfer_engine import MooncakeTransferEngine\n from sglang.srt.disaggregation.utils import (\n     DisaggregationMode,\n+    FastQueue,\n     group_concurrent_contiguous,\n )\n from sglang.srt.server_args import ServerArgs\n@@ -148,10 +149,10 @@ class MooncakeKVManager(BaseKVManager):\n             )\n         self.request_status: Dict[int, KVPoll] = {}\n         self.rank_port = None\n-        self.server_socket = zmq.Context().socket(zmq.PULL)\n+        self.server_socket = zmq.Context.instance().socket(zmq.PULL)\n         self.register_buffer_to_engine()\n         if self.disaggregation_mode == DisaggregationMode.PREFILL:\n-            self.transfer_queue = queue.Queue()\n+            self.transfer_queue = FastQueue()\n             self.transfer_infos: Dict[int, Dict[str, TransferInfo]] = {}\n             self.decode_kv_args_table: Dict[str, KVArgsRegisterInfo] = {}\n             self.start_prefill_thread()\n@@ -210,7 +211,7 @@ class MooncakeKVManager(BaseKVManager):\n \n     @cache\n     def _connect(self, endpoint: str):\n-        socket = zmq.Context().socket(zmq.PUSH)\n+        socket = zmq.Context.instance().socket(zmq.PUSH)\n         socket.connect(endpoint)\n         return socket\n \n@@ -734,7 +735,8 @@ class MooncakeKVSender(BaseKVSender):\n \n \n class MooncakeKVReceiver(BaseKVReceiver):\n-    _ctx = zmq.Context()\n+    _ctx = zmq.Context.instance()\n+    _requests_session = requests.Session()\n     _socket_cache = {}\n     _socket_locks = {}\n     _global_lock = threading.Lock()\n@@ -874,7 +876,7 @@ class MooncakeKVReceiver(BaseKVReceiver):\n         \"\"\"Fetch the bootstrap info from the bootstrap server.\"\"\"\n         try:\n             url = f\"http://{self.bootstrap_addr}/route?engine_rank={engine_rank}&target_dp_group={target_dp_group}\"\n-            response = requests.get(url, timeout=5)\n+            response = self._requests_session.get(url, timeout=5)\n             if response.status_code == 200:\n                 bootstrap_info = response.json()\n                 return bootstrap_info\n@@ -891,7 +893,7 @@ class MooncakeKVReceiver(BaseKVReceiver):\n         \"\"\"Fetch the prefill parallel info from the bootstrap server.\"\"\"\n         try:\n             url = f\"http://{self.bootstrap_addr}/route?engine_rank={-1}&target_dp_group={-1}\"\n-            response = requests.get(url)\n+            response = self._requests_session.get(url)\n             if response.status_code == 200:\n                 prefill_parallel_info = response.json()\n                 return int(prefill_parallel_info[\"prefill_tp_size\"]), int(\ndiff --git a/python/sglang/srt/disaggregation/utils.py b/python/sglang/srt/disaggregation/utils.py\nindex 8841d5f1a..c3af43fcc 100644\n--- a/python/sglang/srt/disaggregation/utils.py\n+++ b/python/sglang/srt/disaggregation/utils.py\n@@ -1,12 +1,16 @@\n from __future__ import annotations\n \n+import queue\n import dataclasses\n import os\n import random\n import warnings\n+import numpy.typing as npt\n+import threading\n+import time\n from collections import deque\n from enum import Enum\n-from typing import TYPE_CHECKING, List, Optional\n+from typing import TYPE_CHECKING, List, Optional, Tuple\n \n import numpy as np\n import requests\n@@ -69,6 +73,54 @@ class ReqToMetadataIdxAllocator:\n         self.free_slots.append(free_index)\n \n \n+class FastQueue:\n+    \"\"\"A lightweight thread-safe FIFO queue optimized for low-overhead put/get.\n+    Provides a subset of queue.Queue API used in this codebase.\n+    \"\"\"\n+\n+    def __init__(self):\n+        self._dq = deque()\n+        self._cv = threading.Condition()\n+\n+    def qsize(self) -> int:\n+        with self._cv:\n+            return len(self._dq)\n+\n+    def empty(self) -> bool:\n+        with self._cv:\n+            return not self._dq\n+\n+    def put(self, item) -> None:\n+        with self._cv:\n+            self._dq.append(item)\n+            self._cv.notify()\n+\n+    def put_nowait(self, item) -> None:\n+        self.put(item)\n+\n+    def get(self, block: bool = True, timeout: Optional[float] = None):\n+        with self._cv:\n+            if not block:\n+                if not self._dq:\n+                    raise queue.Empty\n+                return self._dq.popleft()\n+\n+            if timeout is None:\n+                while not self._dq:\n+                    self._cv.wait()\n+            else:\n+                end = time.monotonic() + timeout\n+                while not self._dq:\n+                    remaining = end - time.monotonic()\n+                    if remaining <= 0:\n+                        raise queue.Empty\n+                    self._cv.wait(remaining)\n+            return self._dq.popleft()\n+\n+    def get_nowait(self):\n+        return self.get(block=False)\n+\n+\n class TransferBackend(Enum):\n     MOONCAKE = \"mooncake\"\n     NIXL = \"nixl\"\n", "model_name_or_path": "gpt-5-2025-08-07"}
