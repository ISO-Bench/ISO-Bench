{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-62cac2c", "model_patch": "diff --git a/docs/backend/pd_disaggregation.md b/docs/backend/pd_disaggregation.md\nindex e77164372..ba39c0b8c 100644\n--- a/docs/backend/pd_disaggregation.md\n+++ b/docs/backend/pd_disaggregation.md\n@@ -48,6 +48,24 @@ $ python -m sglang.launch_server --model-path deepseek-ai/DeepSeek-V3-0324 --dis\n $ python -m sglang.launch_server --model-path deepseek-ai/DeepSeek-V3-0324 --disaggregation-ib-device ${device_name} --disaggregation-mode decode --host ${local_ip} --port 30001 --trust-remote-code --dist-init-addr ${decode_master_ip}:5000 --nnodes 2 --node-rank 1 --tp-size 16 --dp-size 8 --enable-dp-attention --enable-deepep-moe --deepep-mode low_latency --mem-fraction-static 0.8 --max-running-requests 128\n ```\n \n+### Advanced Configuration\n+\n+PD Disaggregation with Mooncake supports the following environment variables for fine-grained control over system behavior.\n+\n+#### Prefill Server Configuration\n+| Variable | Description | Default |\n+|:--------:|:-----------:|:--------:|\n+| **`SGLANG_DISAGGREGATION_THREAD_POOL_SIZE`** | Controls the total number of worker threads for KV transfer operations per TP rank | A dynamic value calculated by `int(0.75 * os.cpu_count()) // 8)`, which is limited to be larger than 4 and less than 12 to ensure efficiency and prevent thread race conditions |\n+| **`SGLANG_DISAGGREGATION_QUEUE_SIZE`** | Sets the maximum pending tasks in the parallel transfer queue | `4` |\n+| **`SGLANG_DISAGGREGATION_BOOTSTRAP_TIMEOUT`** | Timeout (seconds) for receiving destination KV indices during request initialization | `30` |\n+\n+#### Decode Server Configuration\n+| Variable | Description | Default |\n+|:--------:|:-----------:|:--------:|\n+| **`SGLANG_DISAGGREGATION_HEARTBEAT_INTERVAL`** | Interval (seconds) between health checks to prefill bootstrap servers | `5.0` |\n+| **`SGLANG_DISAGGREGATION_HEARTBEAT_MAX_FAILURE`** | Consecutive heartbeat failures before marking prefill server offline | `2` |\n+\n+\n ## NIXL\n ### Requirements\n \ndiff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py\nindex 4c3faeeb6..0841b4e35 100644\n--- a/python/sglang/srt/disaggregation/mooncake/conn.py\n+++ b/python/sglang/srt/disaggregation/mooncake/conn.py\n@@ -187,6 +187,8 @@ class MooncakeKVManager(BaseKVManager):\n             self.bootstrap_time_out = get_int_env_var(\n                 \"SGLANG_DISAGGREGATION_BOOTSTRAP_TIMEOUT\", 30\n             )\n+            # Cache computed shard index per bootstrap room to avoid repeated string parsing\n+            self._shard_cache: Dict[int, int] = {}\n         elif self.disaggregation_mode == DisaggregationMode.DECODE:\n             self.heartbeat_failures = {}\n             self.session_pool = defaultdict(requests.Session)\n@@ -467,7 +469,7 @@ class MooncakeKVManager(BaseKVManager):\n                     if len(self.transfer_infos[room]) == required_dst_info_num:\n                         self.update_status(room, KVPoll.WaitingForInput)\n \n-        threading.Thread(target=bootstrap_thread).start()\n+        threading.Thread(target=bootstrap_thread, daemon=True).start()\n \n     def start_decode_thread(self):\n         self.rank_port = get_free_port()\n@@ -504,14 +506,9 @@ class MooncakeKVManager(BaseKVManager):\n                         if response.status_code == 200:\n                             self.heartbeat_failures[bootstrap_addr] = 0\n \n-                            for bootstrap_room in self.addr_to_rooms_tracker[\n-                                bootstrap_addr\n-                            ]:\n-                                # Remove KVPoll.Success requests from the map\n-                                if bootstrap_room not in self.request_status:\n-                                    self.addr_to_rooms_tracker[bootstrap_addr].remove(\n-                                        bootstrap_room\n-                                    )\n+                            rooms = self.addr_to_rooms_tracker[bootstrap_addr]\n+                            # Remove finished rooms efficiently\n+                            self.addr_to_rooms_tracker[bootstrap_addr] = [r for r in rooms if r in self.request_status]\n                         else:\n                             logger.info(\n                                 f\"Attempting to reconnect to {bootstrap_addr}...\"\n@@ -537,8 +534,8 @@ class MooncakeKVManager(BaseKVManager):\n                             if bootstrap_addr in self.session_pool:\n                                 del self.session_pool[bootstrap_addr]\n \n-        threading.Thread(target=decode_thread).start()\n-        threading.Thread(target=heartbeat_checker).start()\n+        threading.Thread(target=decode_thread, daemon=True).start()\n+        threading.Thread(target=heartbeat_checker, daemon=True).start()\n \n     def add_transfer_request(\n         self,\n@@ -564,8 +561,13 @@ class MooncakeKVManager(BaseKVManager):\n         # requests with the same dst_sessions will be added into the same\n         # queue, which enables early abort with failed sessions.\n         dst_infos = self.transfer_infos[bootstrap_room].keys()\n-        session_port_sum = sum(int(session.split(\":\")[1]) for session in dst_infos)\n-        shard_idx = session_port_sum % len(self.transfer_queues)\n+        shard_idx = self._shard_cache.get(bootstrap_room)\n+        if shard_idx is None:\n+            session_port_sum = 0\n+            for session in dst_infos:\n+                session_port_sum += int(session.split(\":\")[1])\n+            shard_idx = session_port_sum % len(self.transfer_queues)\n+            self._shard_cache[bootstrap_room] = shard_idx\n \n         self.transfer_queues[shard_idx].put(\n             TransferKVChunk(\n@@ -903,7 +905,7 @@ class MooncakeKVReceiver(BaseKVReceiver):\n         \"\"\"Fetch the prefill parallel info from the bootstrap server.\"\"\"\n         try:\n             url = f\"http://{self.bootstrap_addr}/route?engine_rank={-1}&target_dp_group={-1}\"\n-            response = requests.get(url)\n+            response = requests.get(url, timeout=5)\n             if response.status_code == 200:\n                 prefill_parallel_info = response.json()\n                 return int(prefill_parallel_info[\"prefill_tp_size\"]), int(\n", "model_name_or_path": "gpt-5-2025-08-07"}
