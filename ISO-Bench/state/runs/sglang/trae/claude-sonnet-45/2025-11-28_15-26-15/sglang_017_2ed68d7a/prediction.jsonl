{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-e984d50", "model_patch": "diff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py\nindex 29e861e9f..2e2b1a5f1 100644\n--- a/python/sglang/srt/disaggregation/mooncake/conn.py\n+++ b/python/sglang/srt/disaggregation/mooncake/conn.py\n@@ -251,17 +251,17 @@ class MooncakeKVManager(BaseKVManager):\n \n         # Worker function for processing a single layer\n         def process_layer(src_ptr: int, dst_ptr: int, item_len: int) -> int:\n-            for prefill_index, decode_index in zip(prefill_kv_blocks, dst_kv_blocks):\n-                src_addr = src_ptr + int(prefill_index[0]) * item_len\n-                dst_addr = dst_ptr + int(decode_index[0]) * item_len\n-                length = item_len * len(prefill_index)\n-\n-                status = self.engine.transfer_sync(\n-                    mooncake_session_id, src_addr, dst_addr, length\n-                )\n-                if status != 0:\n-                    return status\n-            return 0\n+            # Aggregate transfers to reduce per-call overhead\n+            src_addr_list = [\n+                src_ptr + int(prefill_index[0]) * item_len for prefill_index in prefill_kv_blocks\n+            ]\n+            dst_addr_list = [\n+                dst_ptr + int(decode_index[0]) * item_len for decode_index in dst_kv_blocks\n+            ]\n+            length_list = [item_len * len(prefill_index) for prefill_index in prefill_kv_blocks]\n+            return self.engine.batch_transfer_sync(\n+                mooncake_session_id, src_addr_list, dst_addr_list, length_list\n+            )\n \n         futures = [\n             executor.submit(\ndiff --git a/python/sglang/srt/disaggregation/mooncake/transfer_engine.py b/python/sglang/srt/disaggregation/mooncake/transfer_engine.py\nindex 5643af70b..3988a531a 100644\n--- a/python/sglang/srt/disaggregation/mooncake/transfer_engine.py\n+++ b/python/sglang/srt/disaggregation/mooncake/transfer_engine.py\n@@ -70,11 +70,11 @@ class MooncakeTransferEngine:\n     ) -> int:\n         \"\"\"Synchronously transfer data to the specified address.\"\"\"\n         try:\n+            # Cache bound method locally to reduce attribute lookup overhead\n+            transfer = self.engine.transfer_sync_write\n             # the first time: based on session_id (which contains remote_ip) to construct a queue pair, and cache the queue pair\n             # later: based on the cached queue pair to send data\n-            ret = self.engine.transfer_sync_write(\n-                session_id, buffer, peer_buffer_address, length\n-            )\n+            ret = transfer(session_id, buffer, peer_buffer_address, length)\n         except Exception:\n             # Mark transfer request as failed\n             ret = -1\n@@ -90,5 +90,42 @@ class MooncakeTransferEngine:\n \n         return ret\n \n+    def batch_transfer_sync(\n+        self,\n+        session_id: str,\n+        buffer_list: list[int],\n+        peer_buffer_address_list: list[int],\n+        length_list: list[int],\n+    ) -> int:\n+        \"\"\"Synchronously transfer a batch of data segments.\n+\n+        Tries to use the underlying engine's batch API if available; otherwise\n+        falls back to a simple loop of transfer_sync_write calls.\n+        \"\"\"\n+        try:\n+            eng = self.engine\n+            if hasattr(eng, \"batch_transfer_sync_write\"):\n+                ret = eng.batch_transfer_sync_write(\n+                    session_id, buffer_list, peer_buffer_address_list, length_list\n+                )\n+            elif hasattr(eng, \"batch_transfer_sync\"):\n+                ret = eng.batch_transfer_sync(\n+                    session_id, buffer_list, peer_buffer_address_list, length_list\n+                )\n+            else:\n+                ret = 0\n+                transfer = eng.transfer_sync_write\n+                for buf, dst, l in zip(buffer_list, peer_buffer_address_list, length_list):\n+                    r = transfer(session_id, buf, dst, l)\n+                    if r < 0:\n+                        return r\n+        except Exception:\n+            # Mark transfer request as failed\n+            ret = -1\n+\n+        if ret < 0:\n+            logger.debug(\"Failed to batch transfer data to %s.\", session_id)\n+        return ret\n+\n     def get_session_id(self):\n         return self.session_id\n", "model_name_or_path": "gpt-5-2025-08-07"}
