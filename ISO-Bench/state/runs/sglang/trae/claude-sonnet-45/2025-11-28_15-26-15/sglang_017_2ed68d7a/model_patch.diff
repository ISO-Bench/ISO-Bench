diff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py
index 29e861e9f..2e2b1a5f1 100644
--- a/python/sglang/srt/disaggregation/mooncake/conn.py
+++ b/python/sglang/srt/disaggregation/mooncake/conn.py
@@ -251,17 +251,17 @@ class MooncakeKVManager(BaseKVManager):
 
         # Worker function for processing a single layer
         def process_layer(src_ptr: int, dst_ptr: int, item_len: int) -> int:
-            for prefill_index, decode_index in zip(prefill_kv_blocks, dst_kv_blocks):
-                src_addr = src_ptr + int(prefill_index[0]) * item_len
-                dst_addr = dst_ptr + int(decode_index[0]) * item_len
-                length = item_len * len(prefill_index)
-
-                status = self.engine.transfer_sync(
-                    mooncake_session_id, src_addr, dst_addr, length
-                )
-                if status != 0:
-                    return status
-            return 0
+            # Aggregate transfers to reduce per-call overhead
+            src_addr_list = [
+                src_ptr + int(prefill_index[0]) * item_len for prefill_index in prefill_kv_blocks
+            ]
+            dst_addr_list = [
+                dst_ptr + int(decode_index[0]) * item_len for decode_index in dst_kv_blocks
+            ]
+            length_list = [item_len * len(prefill_index) for prefill_index in prefill_kv_blocks]
+            return self.engine.batch_transfer_sync(
+                mooncake_session_id, src_addr_list, dst_addr_list, length_list
+            )
 
         futures = [
             executor.submit(
diff --git a/python/sglang/srt/disaggregation/mooncake/transfer_engine.py b/python/sglang/srt/disaggregation/mooncake/transfer_engine.py
index 5643af70b..3988a531a 100644
--- a/python/sglang/srt/disaggregation/mooncake/transfer_engine.py
+++ b/python/sglang/srt/disaggregation/mooncake/transfer_engine.py
@@ -70,11 +70,11 @@ class MooncakeTransferEngine:
     ) -> int:
         """Synchronously transfer data to the specified address."""
         try:
+            # Cache bound method locally to reduce attribute lookup overhead
+            transfer = self.engine.transfer_sync_write
             # the first time: based on session_id (which contains remote_ip) to construct a queue pair, and cache the queue pair
             # later: based on the cached queue pair to send data
-            ret = self.engine.transfer_sync_write(
-                session_id, buffer, peer_buffer_address, length
-            )
+            ret = transfer(session_id, buffer, peer_buffer_address, length)
         except Exception:
             # Mark transfer request as failed
             ret = -1
@@ -90,5 +90,42 @@ class MooncakeTransferEngine:
 
         return ret
 
+    def batch_transfer_sync(
+        self,
+        session_id: str,
+        buffer_list: list[int],
+        peer_buffer_address_list: list[int],
+        length_list: list[int],
+    ) -> int:
+        """Synchronously transfer a batch of data segments.
+
+        Tries to use the underlying engine's batch API if available; otherwise
+        falls back to a simple loop of transfer_sync_write calls.
+        """
+        try:
+            eng = self.engine
+            if hasattr(eng, "batch_transfer_sync_write"):
+                ret = eng.batch_transfer_sync_write(
+                    session_id, buffer_list, peer_buffer_address_list, length_list
+                )
+            elif hasattr(eng, "batch_transfer_sync"):
+                ret = eng.batch_transfer_sync(
+                    session_id, buffer_list, peer_buffer_address_list, length_list
+                )
+            else:
+                ret = 0
+                transfer = eng.transfer_sync_write
+                for buf, dst, l in zip(buffer_list, peer_buffer_address_list, length_list):
+                    r = transfer(session_id, buf, dst, l)
+                    if r < 0:
+                        return r
+        except Exception:
+            # Mark transfer request as failed
+            ret = -1
+
+        if ret < 0:
+            logger.debug("Failed to batch transfer data to %s.", session_id)
+        return ret
+
     def get_session_id(self):
         return self.session_id
