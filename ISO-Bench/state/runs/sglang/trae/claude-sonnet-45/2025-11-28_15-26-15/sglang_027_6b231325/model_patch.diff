diff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py
index 8ab5066ec..747bf7958 100644
--- a/python/sglang/srt/disaggregation/mooncake/conn.py
+++ b/python/sglang/srt/disaggregation/mooncake/conn.py
@@ -31,6 +31,7 @@ from sglang.srt.disaggregation.base.conn import (
 from sglang.srt.disaggregation.mooncake.transfer_engine import MooncakeTransferEngine
 from sglang.srt.disaggregation.utils import (
     DisaggregationMode,
+    FastQueue,
     group_concurrent_contiguous,
 )
 from sglang.srt.server_args import ServerArgs
@@ -148,10 +149,10 @@ class MooncakeKVManager(BaseKVManager):
             )
         self.request_status: Dict[int, KVPoll] = {}
         self.rank_port = None
-        self.server_socket = zmq.Context().socket(zmq.PULL)
+        self.server_socket = zmq.Context.instance().socket(zmq.PULL)
         self.register_buffer_to_engine()
         if self.disaggregation_mode == DisaggregationMode.PREFILL:
-            self.transfer_queue = queue.Queue()
+            self.transfer_queue = FastQueue()
             self.transfer_infos: Dict[int, Dict[str, TransferInfo]] = {}
             self.decode_kv_args_table: Dict[str, KVArgsRegisterInfo] = {}
             self.start_prefill_thread()
@@ -210,7 +211,7 @@ class MooncakeKVManager(BaseKVManager):
 
     @cache
     def _connect(self, endpoint: str):
-        socket = zmq.Context().socket(zmq.PUSH)
+        socket = zmq.Context.instance().socket(zmq.PUSH)
         socket.connect(endpoint)
         return socket
 
@@ -734,7 +735,8 @@ class MooncakeKVSender(BaseKVSender):
 
 
 class MooncakeKVReceiver(BaseKVReceiver):
-    _ctx = zmq.Context()
+    _ctx = zmq.Context.instance()
+    _requests_session = requests.Session()
     _socket_cache = {}
     _socket_locks = {}
     _global_lock = threading.Lock()
@@ -874,7 +876,7 @@ class MooncakeKVReceiver(BaseKVReceiver):
         """Fetch the bootstrap info from the bootstrap server."""
         try:
             url = f"http://{self.bootstrap_addr}/route?engine_rank={engine_rank}&target_dp_group={target_dp_group}"
-            response = requests.get(url, timeout=5)
+            response = self._requests_session.get(url, timeout=5)
             if response.status_code == 200:
                 bootstrap_info = response.json()
                 return bootstrap_info
@@ -891,7 +893,7 @@ class MooncakeKVReceiver(BaseKVReceiver):
         """Fetch the prefill parallel info from the bootstrap server."""
         try:
             url = f"http://{self.bootstrap_addr}/route?engine_rank={-1}&target_dp_group={-1}"
-            response = requests.get(url)
+            response = self._requests_session.get(url)
             if response.status_code == 200:
                 prefill_parallel_info = response.json()
                 return int(prefill_parallel_info["prefill_tp_size"]), int(
diff --git a/python/sglang/srt/disaggregation/utils.py b/python/sglang/srt/disaggregation/utils.py
index 8841d5f1a..c3af43fcc 100644
--- a/python/sglang/srt/disaggregation/utils.py
+++ b/python/sglang/srt/disaggregation/utils.py
@@ -1,12 +1,16 @@
 from __future__ import annotations
 
+import queue
 import dataclasses
 import os
 import random
 import warnings
+import numpy.typing as npt
+import threading
+import time
 from collections import deque
 from enum import Enum
-from typing import TYPE_CHECKING, List, Optional
+from typing import TYPE_CHECKING, List, Optional, Tuple
 
 import numpy as np
 import requests
@@ -69,6 +73,54 @@ class ReqToMetadataIdxAllocator:
         self.free_slots.append(free_index)
 
 
+class FastQueue:
+    """A lightweight thread-safe FIFO queue optimized for low-overhead put/get.
+    Provides a subset of queue.Queue API used in this codebase.
+    """
+
+    def __init__(self):
+        self._dq = deque()
+        self._cv = threading.Condition()
+
+    def qsize(self) -> int:
+        with self._cv:
+            return len(self._dq)
+
+    def empty(self) -> bool:
+        with self._cv:
+            return not self._dq
+
+    def put(self, item) -> None:
+        with self._cv:
+            self._dq.append(item)
+            self._cv.notify()
+
+    def put_nowait(self, item) -> None:
+        self.put(item)
+
+    def get(self, block: bool = True, timeout: Optional[float] = None):
+        with self._cv:
+            if not block:
+                if not self._dq:
+                    raise queue.Empty
+                return self._dq.popleft()
+
+            if timeout is None:
+                while not self._dq:
+                    self._cv.wait()
+            else:
+                end = time.monotonic() + timeout
+                while not self._dq:
+                    remaining = end - time.monotonic()
+                    if remaining <= 0:
+                        raise queue.Empty
+                    self._cv.wait(remaining)
+            return self._dq.popleft()
+
+    def get_nowait(self):
+        return self.get(block=False)
+
+
 class TransferBackend(Enum):
     MOONCAKE = "mooncake"
     NIXL = "nixl"
