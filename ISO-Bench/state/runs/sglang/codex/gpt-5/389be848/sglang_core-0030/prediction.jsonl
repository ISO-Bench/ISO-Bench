{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-62cac2c", "model_patch": "diff --git a/docs/backend/pd_disaggregation.md b/docs/backend/pd_disaggregation.md\nindex e77164372..308afed45 100644\n--- a/docs/backend/pd_disaggregation.md\n+++ b/docs/backend/pd_disaggregation.md\n@@ -48,6 +48,23 @@ $ python -m sglang.launch_server --model-path deepseek-ai/DeepSeek-V3-0324 --dis\n $ python -m sglang.launch_server --model-path deepseek-ai/DeepSeek-V3-0324 --disaggregation-ib-device ${device_name} --disaggregation-mode decode --host ${local_ip} --port 30001 --trust-remote-code --dist-init-addr ${decode_master_ip}:5000 --nnodes 2 --node-rank 1 --tp-size 16 --dp-size 8 --enable-dp-attention --enable-deepep-moe --deepep-mode low_latency --mem-fraction-static 0.8 --max-running-requests 128\n ```\n \n+### Advanced Configuration\n+\n+PD Disaggregation with Mooncake supports the following environment variables for fine\u2011grained control over system behavior.\n+\n+#### Prefill Server Configuration\n+| Variable | Description | Default |\n+|:--------:|:-----------:|:--------:|\n+| `SGLANG_DISAGGREGATION_THREAD_POOL_SIZE` | Worker threads for KV transfer operations per TP rank | `int(0.75 * os.cpu_count()) // 8`, clamped to [4, 12] |\n+| `SGLANG_DISAGGREGATION_QUEUE_SIZE` | Maximum pending tasks per parallel transfer queue | `4` |\n+| `SGLANG_DISAGGREGATION_BOOTSTRAP_TIMEOUT` | Timeout (seconds) when waiting for destination KV indices during request initialization | `30` |\n+\n+#### Decode Server Configuration\n+| Variable | Description | Default |\n+|:--------:|:-----------:|:--------:|\n+| `SGLANG_DISAGGREGATION_HEARTBEAT_INTERVAL` | Interval (seconds) between health checks to prefill bootstrap servers | `5.0` (minimum 2.0) |\n+| `SGLANG_DISAGGREGATION_HEARTBEAT_MAX_FAILURE` | Consecutive heartbeat failures before marking prefill server offline | `2` (minimum 1) |\n+\n ## NIXL\n ### Requirements\n \ndiff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py\nindex 4c3faeeb6..f3aa0185b 100644\n--- a/python/sglang/srt/disaggregation/mooncake/conn.py\n+++ b/python/sglang/srt/disaggregation/mooncake/conn.py\n@@ -160,10 +160,13 @@ class MooncakeKVManager(BaseKVManager):\n             self.failed_sessions = set()\n             self.session_lock = threading.Lock()\n             # Determine the number of threads to use for kv sender\n-            cpu_count = os.cpu_count()\n+            cpu_count = os.cpu_count() or 8\n+            default_workers = int(0.75 * cpu_count) // 8\n+            if default_workers < 1:\n+                default_workers = 1\n             transfer_thread_pool_size = get_int_env_var(\n                 \"SGLANG_DISAGGREGATION_THREAD_POOL_SIZE\",\n-                min(max(4, int(0.75 * cpu_count) // 8), 12),\n+                min(max(4, default_workers), 12),\n             )\n             transfer_queue_size = get_int_env_var(\"SGLANG_DISAGGREGATION_QUEUE_SIZE\", 4)\n             self.transfer_queues: List[FastQueue] = [\n@@ -255,14 +258,16 @@ class MooncakeKVManager(BaseKVManager):\n \n         # Worker function for processing a single layer\n         def process_layer(src_ptr: int, dst_ptr: int, item_len: int) -> int:\n+            transfer_sync = self.engine.transfer_sync\n             for prefill_index, decode_index in zip(prefill_kv_blocks, dst_kv_blocks):\n-                src_addr = src_ptr + int(prefill_index[0]) * item_len\n-                dst_addr = dst_ptr + int(decode_index[0]) * item_len\n-                length = item_len * len(prefill_index)\n+                base_src = int(prefill_index[0])\n+                base_dst = int(decode_index[0])\n+                block_len = item_len * len(prefill_index)\n \n-                status = self.engine.transfer_sync(\n-                    mooncake_session_id, src_addr, dst_addr, length\n-                )\n+                src_addr = src_ptr + base_src * item_len\n+                dst_addr = dst_ptr + base_dst * item_len\n+\n+                status = transfer_sync(mooncake_session_id, src_addr, dst_addr, block_len)\n                 if status != 0:\n                     return status\n             return 0\n@@ -308,7 +313,8 @@ class MooncakeKVManager(BaseKVManager):\n     ):\n         if \":\" in remote:\n             remote = remote.split(\":\")[0]\n-        self._connect(\"tcp://\" + remote + \":\" + str(dst_port)).send_multipart(\n+        endpoint = f\"tcp://{remote}:{dst_port}\"\n+        self._connect(endpoint).send_multipart(\n             [\n                 str(room).encode(\"ascii\"),\n                 str(status).encode(\"ascii\"),\n@@ -350,15 +356,14 @@ class MooncakeKVManager(BaseKVManager):\n \n                         # NOTE: This is temporarily a workaround to deal with the case where the prefill_kv_indices\n                         # is mismatched with the dst_kv_indices when page size > 1, this should never happen.\n-                        if len(chunked_dst_kv_indice) < len(\n-                            kv_chunk.prefill_kv_indices\n-                        ):\n-                            kv_chunk.prefill_kv_indices = kv_chunk.prefill_kv_indices[\n-                                : len(chunked_dst_kv_indice)\n-                            ]\n-                            logger.warning(\n-                                f\"len(chunked_dst_kv_indice) = {len(chunked_dst_kv_indice)}, len(kv_chunk.prefill_kv_indices) = {len(kv_chunk.prefill_kv_indices)}\"\n-                            )\n+                        if len(chunked_dst_kv_indice) < len(kv_chunk.prefill_kv_indices):\n+                            kv_chunk.prefill_kv_indices = kv_chunk.prefill_kv_indices[: len(chunked_dst_kv_indice)]\n+                            if logger.isEnabledFor(logging.WARNING):\n+                                logger.warning(\n+                                    \"len(chunked_dst_kv_indice) = %d, len(kv_chunk.prefill_kv_indices) = %d\",\n+                                    len(chunked_dst_kv_indice),\n+                                    len(kv_chunk.prefill_kv_indices),\n+                                )\n \n                         ret = self.send_kvcache(\n                             req.mooncake_session_id,\n@@ -467,7 +472,7 @@ class MooncakeKVManager(BaseKVManager):\n                     if len(self.transfer_infos[room]) == required_dst_info_num:\n                         self.update_status(room, KVPoll.WaitingForInput)\n \n-        threading.Thread(target=bootstrap_thread).start()\n+        threading.Thread(target=bootstrap_thread, daemon=True).start()\n \n     def start_decode_thread(self):\n         self.rank_port = get_free_port()\n@@ -486,8 +491,19 @@ class MooncakeKVManager(BaseKVManager):\n                 self.update_status(bootstrap_room, status)\n \n         def heartbeat_checker():\n+            # Use monotonic clock to keep a stable heartbeat cadence\n+            try:\n+                next_ts = time.monotonic() + self.heartbeat_interval\n+                use_monotonic = True\n+            except Exception:\n+                next_ts = time.time() + self.heartbeat_interval\n+                use_monotonic = False\n             while True:\n-                time.sleep(self.heartbeat_interval)\n+                now = time.monotonic() if use_monotonic else time.time()\n+                sleep_dur = next_ts - now\n+                if sleep_dur > 0:\n+                    time.sleep(sleep_dur)\n+                next_ts += self.heartbeat_interval\n                 with self.connection_lock:\n                     addresses = list(self.prefill_dp_size_table.keys())\n \n@@ -504,14 +520,13 @@ class MooncakeKVManager(BaseKVManager):\n                         if response.status_code == 200:\n                             self.heartbeat_failures[bootstrap_addr] = 0\n \n-                            for bootstrap_room in self.addr_to_rooms_tracker[\n-                                bootstrap_addr\n-                            ]:\n-                                # Remove KVPoll.Success requests from the map\n-                                if bootstrap_room not in self.request_status:\n-                                    self.addr_to_rooms_tracker[bootstrap_addr].remove(\n-                                        bootstrap_room\n-                                    )\n+                            # Remove completed rooms in a single pass to avoid\n+                            # repeated list removals (O(n^2))\n+                            rooms = self.addr_to_rooms_tracker.get(bootstrap_addr, [])\n+                            if rooms:\n+                                self.addr_to_rooms_tracker[bootstrap_addr] = [\n+                                    r for r in rooms if r in self.request_status\n+                                ]\n                         else:\n                             logger.info(\n                                 f\"Attempting to reconnect to {bootstrap_addr}...\"\n@@ -537,8 +552,8 @@ class MooncakeKVManager(BaseKVManager):\n                             if bootstrap_addr in self.session_pool:\n                                 del self.session_pool[bootstrap_addr]\n \n-        threading.Thread(target=decode_thread).start()\n-        threading.Thread(target=heartbeat_checker).start()\n+        threading.Thread(target=decode_thread, daemon=True).start()\n+        threading.Thread(target=heartbeat_checker, daemon=True).start()\n \n     def add_transfer_request(\n         self,\n@@ -681,6 +696,13 @@ class MooncakeKVSender(BaseKVSender):\n         self.conclude_state = None\n         # inner state\n         self.curr_idx = 0\n+        # Precompute a monotonic deadline for bootstrapping timeout to avoid\n+        # repeated arithmetic and wall-clock adjustments during poll()\n+        try:\n+            _now = time.monotonic()\n+        except Exception:\n+            _now = self.init_time\n+        self._bootstrap_deadline = _now + getattr(self.kv_mgr, \"bootstrap_time_out\", 30)\n \n     def init(self, num_kv_indices: int, aux_index: Optional[int] = None):\n         self.num_kv_indices = num_kv_indices\n@@ -713,12 +735,14 @@ class MooncakeKVSender(BaseKVSender):\n             if status in (KVPoll.Success, KVPoll.Failed):\n                 self.conclude_state = status\n             elif status == KVPoll.Bootstrapping:\n-                now = time.time()\n-                elapsed = now - self.init_time\n-                if elapsed >= self.kv_mgr.bootstrap_time_out:\n+                try:\n+                    now = time.monotonic()\n+                except Exception:\n+                    now = time.time()\n+                if now >= self._bootstrap_deadline:\n                     self.kv_mgr.record_failure(\n                         self.bootstrap_room,\n-                        f\"Request {self.bootstrap_room} timed out after {elapsed:.1f}s in KVPoll.Bootstrapping\",\n+                        f\"Request {self.bootstrap_room} timed out after {self.kv_mgr.bootstrap_time_out:.1f}s in KVPoll.Bootstrapping\",\n                     )\n                     self.conclude_state = KVPoll.Failed\n                     return KVPoll.Failed\n", "model_name_or_path": "gpt-5-2025-08-07"}
