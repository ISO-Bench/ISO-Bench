diff --git a/python/sglang/srt/mem_cache/radix_cache.py b/python/sglang/srt/mem_cache/radix_cache.py
index 68bcb5b0b..005a1d665 100644
--- a/python/sglang/srt/mem_cache/radix_cache.py
+++ b/python/sglang/srt/mem_cache/radix_cache.py
@@ -189,7 +189,7 @@ class RadixCache(BasePrefixCache):
             num_evicted += len(x.value)
             self._delete_leaf(x)
 
-            if len(x.parent.children) == 0:
+            if not x.parent.children:
                 heapq.heappush(leaves, x.parent)
 
     def inc_lock_ref(self, node: TreeNode):
@@ -227,11 +227,11 @@ class RadixCache(BasePrefixCache):
         self, node: TreeNode, key: List, value, last_node: TreeNode
     ):
         node.last_access_time = time.time()
-        if len(key) == 0:
+        if not key:
             return
 
-        if key[0] in node.children.keys():
-            child = node.children[key[0]]
+        child = node.children.get(key[0])
+        if child is not None:
             prefix_len = _key_match(child.key, key)
             if prefix_len < len(child.key):
                 new_node = self._split_node(child.key, child, prefix_len)
@@ -245,7 +245,8 @@ class RadixCache(BasePrefixCache):
     def _split_node(self, key, child: TreeNode, split_len: int):
         # new_node -> child
         new_node = TreeNode()
-        new_node.children = {key[split_len:][0]: child}
+        # Avoid creating intermediate slices when indexing
+        new_node.children = {key[split_len]: child}
         new_node.parent = child.parent
         new_node.lock_ref = child.lock_ref
         new_node.key = child.key[:split_len]
@@ -253,16 +254,16 @@ class RadixCache(BasePrefixCache):
         child.parent = new_node
         child.key = child.key[split_len:]
         child.value = child.value[split_len:]
-        new_node.parent.children[key[:split_len][0]] = new_node
+        new_node.parent.children[key[0]] = new_node
         return new_node
 
     def _insert_helper(self, node: TreeNode, key: List, value):
         node.last_access_time = time.time()
-        if len(key) == 0:
+        if not key:
             return 0
 
-        if key[0] in node.children.keys():
-            child = node.children[key[0]]
+        child = node.children.get(key[0])
+        if child is not None:
             prefix_len = _key_match(child.key, key)
 
             if prefix_len == len(child.key):
@@ -293,10 +294,8 @@ class RadixCache(BasePrefixCache):
             self._print_helper(child, indent=indent + 2)
 
     def _delete_leaf(self, node):
-        for k, v in node.parent.children.items():
-            if v == node:
-                break
-        del node.parent.children[k]
+        # Directly delete by the first token of the node's key
+        del node.parent.children[node.key[0]]
         self.evictable_size_ -= len(node.key)
 
     def _total_size_helper(self, node: TreeNode):
@@ -311,11 +310,11 @@ class RadixCache(BasePrefixCache):
 
         while stack:
             cur_node = stack.pop()
-            if len(cur_node.children) == 0:
+            if not cur_node.children:
                 ret_list.append(cur_node)
             else:
                 stack.extend(cur_node.children.values())
-
+        
         return ret_list
 
 
