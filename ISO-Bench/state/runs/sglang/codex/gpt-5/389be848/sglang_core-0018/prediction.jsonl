{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-e984d50", "model_patch": "diff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py\nindex 29e861e9f..cd634c08b 100644\n--- a/python/sglang/srt/disaggregation/mooncake/conn.py\n+++ b/python/sglang/srt/disaggregation/mooncake/conn.py\n@@ -239,6 +239,11 @@ class MooncakeKVManager(BaseKVManager):\n             prefill_kv_indices, dst_kv_indices\n         )\n \n+        # Precompute block starts and lengths (avoid repeated int/len in inner loop)\n+        src_block_starts = [int(block[0]) for block in prefill_kv_blocks]\n+        dst_block_starts = [int(block[0]) for block in dst_kv_blocks]\n+        block_unit_lengths = [len(block) for block in prefill_kv_blocks]\n+\n         num_layers = len(self.kv_args.kv_data_ptrs)\n         layers_params = [\n             (\n@@ -251,17 +256,16 @@ class MooncakeKVManager(BaseKVManager):\n \n         # Worker function for processing a single layer\n         def process_layer(src_ptr: int, dst_ptr: int, item_len: int) -> int:\n-            for prefill_index, decode_index in zip(prefill_kv_blocks, dst_kv_blocks):\n-                src_addr = src_ptr + int(prefill_index[0]) * item_len\n-                dst_addr = dst_ptr + int(decode_index[0]) * item_len\n-                length = item_len * len(prefill_index)\n-\n-                status = self.engine.transfer_sync(\n-                    mooncake_session_id, src_addr, dst_addr, length\n-                )\n-                if status != 0:\n-                    return status\n-            return 0\n+            # Compute address lists for this layer\n+            src_addr_list = [src_ptr + start * item_len for start in src_block_starts]\n+            dst_addr_list = [dst_ptr + start * item_len for start in dst_block_starts]\n+            length_list = [item_len * n for n in block_unit_lengths]\n+\n+            # Use batched transfer to reduce per-call overhead\n+            status = self.engine.batch_transfer_sync(\n+                mooncake_session_id, src_addr_list, dst_addr_list, length_list\n+            )\n+            return status\n \n         futures = [\n             executor.submit(\ndiff --git a/python/sglang/srt/disaggregation/mooncake/transfer_engine.py b/python/sglang/srt/disaggregation/mooncake/transfer_engine.py\nindex 5643af70b..4ce1408f6 100644\n--- a/python/sglang/srt/disaggregation/mooncake/transfer_engine.py\n+++ b/python/sglang/srt/disaggregation/mooncake/transfer_engine.py\n@@ -90,5 +90,55 @@ class MooncakeTransferEngine:\n \n         return ret\n \n+    def batch_transfer_sync(\n+        self,\n+        session_id: str,\n+        buffers: list[int],\n+        peer_buffer_addresses: list[int],\n+        lengths: list[int],\n+    ) -> int:\n+        \"\"\"Synchronously transfer a batch of segments.\n+\n+        Attempts to use the underlying engine's batched API if available,\n+        otherwise falls back to sequential synchronous transfers.\n+        \"\"\"\n+        try:\n+            # Basic sanity check\n+            if not (\n+                len(buffers) == len(peer_buffer_addresses) == len(lengths)\n+            ):\n+                return -1\n+\n+            # Prefer native batch API when available\n+            if hasattr(self.engine, \"batch_transfer_sync_write\"):\n+                ret = self.engine.batch_transfer_sync_write(\n+                    session_id, buffers, peer_buffer_addresses, lengths\n+                )\n+            elif hasattr(self.engine, \"batch_transfer_sync\"):\n+                ret = self.engine.batch_transfer_sync(\n+                    session_id, buffers, peer_buffer_addresses, lengths\n+                )\n+            else:\n+                # Fallback: sequential transfers\n+                ret = 0\n+                for src, dst, ln in zip(buffers, peer_buffer_addresses, lengths):\n+                    r = self.engine.transfer_sync_write(session_id, src, dst, ln)\n+                    if r != 0:\n+                        ret = r\n+                        break\n+        except Exception:\n+            ret = -1\n+\n+        # Normalize possible list return from engine batch calls\n+        if isinstance(ret, (list, tuple)):\n+            ok = all((x == 0 for x in ret))\n+            ret = 0 if ok else -1\n+\n+        if ret != 0:\n+            logger.debug(\n+                \"Failed batched transfer to %s with %d segments.\", session_id, len(buffers)\n+            )\n+        return ret\n+\n     def get_session_id(self):\n         return self.session_id\n", "model_name_or_path": "gpt-5-2025-08-07"}
