diff --git a/python/sglang/srt/disaggregation/mooncake/conn.py b/python/sglang/srt/disaggregation/mooncake/conn.py
index 29e861e9f..cd634c08b 100644
--- a/python/sglang/srt/disaggregation/mooncake/conn.py
+++ b/python/sglang/srt/disaggregation/mooncake/conn.py
@@ -239,6 +239,11 @@ class MooncakeKVManager(BaseKVManager):
             prefill_kv_indices, dst_kv_indices
         )
 
+        # Precompute block starts and lengths (avoid repeated int/len in inner loop)
+        src_block_starts = [int(block[0]) for block in prefill_kv_blocks]
+        dst_block_starts = [int(block[0]) for block in dst_kv_blocks]
+        block_unit_lengths = [len(block) for block in prefill_kv_blocks]
+
         num_layers = len(self.kv_args.kv_data_ptrs)
         layers_params = [
             (
@@ -251,17 +256,16 @@ class MooncakeKVManager(BaseKVManager):
 
         # Worker function for processing a single layer
         def process_layer(src_ptr: int, dst_ptr: int, item_len: int) -> int:
-            for prefill_index, decode_index in zip(prefill_kv_blocks, dst_kv_blocks):
-                src_addr = src_ptr + int(prefill_index[0]) * item_len
-                dst_addr = dst_ptr + int(decode_index[0]) * item_len
-                length = item_len * len(prefill_index)
-
-                status = self.engine.transfer_sync(
-                    mooncake_session_id, src_addr, dst_addr, length
-                )
-                if status != 0:
-                    return status
-            return 0
+            # Compute address lists for this layer
+            src_addr_list = [src_ptr + start * item_len for start in src_block_starts]
+            dst_addr_list = [dst_ptr + start * item_len for start in dst_block_starts]
+            length_list = [item_len * n for n in block_unit_lengths]
+
+            # Use batched transfer to reduce per-call overhead
+            status = self.engine.batch_transfer_sync(
+                mooncake_session_id, src_addr_list, dst_addr_list, length_list
+            )
+            return status
 
         futures = [
             executor.submit(
diff --git a/python/sglang/srt/disaggregation/mooncake/transfer_engine.py b/python/sglang/srt/disaggregation/mooncake/transfer_engine.py
index 5643af70b..4ce1408f6 100644
--- a/python/sglang/srt/disaggregation/mooncake/transfer_engine.py
+++ b/python/sglang/srt/disaggregation/mooncake/transfer_engine.py
@@ -90,5 +90,55 @@ class MooncakeTransferEngine:
 
         return ret
 
+    def batch_transfer_sync(
+        self,
+        session_id: str,
+        buffers: list[int],
+        peer_buffer_addresses: list[int],
+        lengths: list[int],
+    ) -> int:
+        """Synchronously transfer a batch of segments.
+
+        Attempts to use the underlying engine's batched API if available,
+        otherwise falls back to sequential synchronous transfers.
+        """
+        try:
+            # Basic sanity check
+            if not (
+                len(buffers) == len(peer_buffer_addresses) == len(lengths)
+            ):
+                return -1
+
+            # Prefer native batch API when available
+            if hasattr(self.engine, "batch_transfer_sync_write"):
+                ret = self.engine.batch_transfer_sync_write(
+                    session_id, buffers, peer_buffer_addresses, lengths
+                )
+            elif hasattr(self.engine, "batch_transfer_sync"):
+                ret = self.engine.batch_transfer_sync(
+                    session_id, buffers, peer_buffer_addresses, lengths
+                )
+            else:
+                # Fallback: sequential transfers
+                ret = 0
+                for src, dst, ln in zip(buffers, peer_buffer_addresses, lengths):
+                    r = self.engine.transfer_sync_write(session_id, src, dst, ln)
+                    if r != 0:
+                        ret = r
+                        break
+        except Exception:
+            ret = -1
+
+        # Normalize possible list return from engine batch calls
+        if isinstance(ret, (list, tuple)):
+            ok = all((x == 0 for x in ret))
+            ret = 0 if ok else -1
+
+        if ret != 0:
+            logger.debug(
+                "Failed batched transfer to %s with %d segments.", session_id, len(buffers)
+            )
+        return ret
+
     def get_session_id(self):
         return self.session_id
