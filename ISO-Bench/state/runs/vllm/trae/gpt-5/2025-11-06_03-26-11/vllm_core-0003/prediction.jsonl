{"instance_id": "vllm-project__vllm-2b04c20", "model_patch": "diff --git a/vllm/model_executor/layers/fused_moe/fused_moe.py b/vllm/model_executor/layers/fused_moe/fused_moe.py\nindex 00260313e..1d83fb7f0 100644\n--- a/vllm/model_executor/layers/fused_moe/fused_moe.py\n+++ b/vllm/model_executor/layers/fused_moe/fused_moe.py\n@@ -537,7 +537,7 @@ def moe_align_block_size_triton(\n     tokens_cnts = torch.zeros((num_experts + 1, num_experts),\n                               dtype=torch.int32,\n                               device=topk_ids.device)\n-    cumsum = torch.zeros((num_experts + 1, ),\n+    cumsum = torch.zeros((num_experts + 1,),\n                          dtype=torch.int32,\n                          device=topk_ids.device)\n     tokens_per_thread = ceil_div(numel, num_experts)\n@@ -628,7 +628,7 @@ def moe_align_block_size(\n     max_num_m_blocks = triton.cdiv(max_num_tokens_padded, block_size)\n     # Expert ids must be zeroed out to prevent index out of bounds error while\n     # mapping global expert ids to local expert ids in expert parallelism.\n-    expert_ids = torch.zeros((max_num_m_blocks, ),\n+    expert_ids = torch.zeros((max_num_m_blocks,),\n                              dtype=torch.int32,\n                              device=topk_ids.device)\n     num_tokens_post_pad = torch.empty((1),\n@@ -994,7 +994,8 @@ def grouped_topk(hidden_states: torch.Tensor,\n                                    -1).max(dim=-1).values  # [n, n_group]\n     group_idx = torch.topk(group_scores, k=topk_group, dim=-1,\n                            sorted=False)[1]  # [n, top_k_group]\n-    group_mask = torch.zeros_like(group_scores)  # [n, n_group]\n+    group_mask = torch.empty_like(group_scores)\n+\n     group_mask.scatter_(1, group_idx, 1)  # [n, n_group]\n     score_mask = group_mask.unsqueeze(-1).expand(\n         num_token, num_expert_group,\n@@ -1240,15 +1241,19 @@ def fused_experts_impl(hidden_states: torch.Tensor,\n \n     config = get_config_func(M)\n \n-    intermediate_cache1 = torch.empty((M, top_k_num, N),\n-                                      device=hidden_states.device,\n-                                      dtype=hidden_states.dtype)\n+    # We can reuse the memory between these because by the time we need\n+    # cache3, we're done with cache1\n+    cache13 = torch.empty(M * top_k_num * max(N, w2.shape[1]),\n+                          device=hidden_states.device,\n+                          dtype=hidden_states.dtype)\n+    intermediate_cache1 = cache13[:M * top_k_num * N].view(\n+        (M, topk_ids.shape[1], N))\n+    # This needs separate memory since it's used concurrently with cache1\n     intermediate_cache2 = torch.empty((M * top_k_num, N // 2),\n                                       device=hidden_states.device,\n                                       dtype=hidden_states.dtype)\n-    intermediate_cache3 = torch.empty((M, top_k_num, w2.shape[1]),\n-                                      device=hidden_states.device,\n-                                      dtype=hidden_states.dtype)\n+    intermediate_cache3 = cache13[:M * top_k_num * w2.shape[1]].view(\n+        (M, topk_ids.shape[1], w2.shape[1]))\n \n     if hidden_states.dtype == torch.bfloat16:\n         compute_type = tl.bfloat16\n", "model_name_or_path": "gpt-5-2025-08-07"}
