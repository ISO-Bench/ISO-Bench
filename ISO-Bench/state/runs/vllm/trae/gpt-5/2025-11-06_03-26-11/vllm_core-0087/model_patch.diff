diff --git a/tests/v1/core/test_kv_cache_utils.py b/tests/v1/core/test_kv_cache_utils.py
index 68b060156..f4bda3dbb 100644
--- a/tests/v1/core/test_kv_cache_utils.py
+++ b/tests/v1/core/test_kv_cache_utils.py
@@ -184,6 +184,80 @@ def test_free_kv_cache_block_queue_operations():
     assert str(e.value) == "No free blocks available"
 
 
+
+
+def test_free_kv_cache_block_queue_append_n():
+    # Create an empty FreeKVCacheBlockQueue
+    queue = FreeKVCacheBlockQueue([])
+    blocks = [KVCacheBlock(block_id=i) for i in range(6)]
+
+    # Append 0 blocks: still empty
+    queue.append_n([])
+    assert queue.num_free_blocks == 0
+    assert (queue.fake_free_list_head.next_free_block
+            is queue.fake_free_list_tail)
+    assert (queue.fake_free_list_tail.prev_free_block
+            is queue.fake_free_list_head)
+
+    # Append 1 block
+    queue.append_n(blocks[0:1])
+    assert queue.num_free_blocks == 1
+    assert queue.fake_free_list_head.next_free_block is blocks[0]
+    assert blocks[0].prev_free_block is queue.fake_free_list_head
+    assert blocks[0].next_free_block is queue.fake_free_list_tail
+    assert queue.fake_free_list_tail.prev_free_block is blocks[0]
+
+    # Append 2 more blocks
+    queue.append_n(blocks[1:3])
+    assert queue.num_free_blocks == 3
+    assert queue.fake_free_list_head.next_free_block is blocks[0]
+    assert blocks[0].next_free_block is blocks[1]
+    assert blocks[1].prev_free_block is blocks[0]
+    assert blocks[1].next_free_block is blocks[2]
+    assert blocks[2].prev_free_block is blocks[1]
+    assert blocks[2].next_free_block is queue.fake_free_list_tail
+    assert queue.fake_free_list_tail.prev_free_block is blocks[2]
+
+    # Append a single block again
+    queue.append(blocks[3])
+    assert queue.num_free_blocks == 4
+    assert queue.fake_free_list_tail.prev_free_block is blocks[3]
+    assert blocks[3].prev_free_block is blocks[2]
+    assert blocks[3].next_free_block is queue.fake_free_list_tail
+
+
+def test_free_kv_cache_block_queue_popleft_n():
+    # Initialize 6 blocks in queue
+    blocks = [KVCacheBlock(block_id=i) for i in range(6)]
+    queue = FreeKVCacheBlockQueue(blocks)
+
+    # Pop zero returns empty
+    popped0 = queue.popleft_n(0)
+    assert popped0 == []
+    assert queue.num_free_blocks == 6
+
+    # Pop two
+    popped = queue.popleft_n(2)
+    assert [b.block_id for b in popped] == [0, 1]
+    assert queue.num_free_blocks == 4
+    assert queue.fake_free_list_head.next_free_block is blocks[2]
+    # Ensure popped blocks are detached
+    assert all(b.prev_free_block is None and b.next_free_block is None
+               for b in popped)
+
+    # Pop the rest
+    popped_rest = queue.popleft_n(10)
+    assert [b.block_id for b in popped_rest] == [2, 3, 4, 5]
+    assert queue.num_free_blocks == 0
+    assert (queue.fake_free_list_head.next_free_block
+            is queue.fake_free_list_tail)
+    assert (queue.fake_free_list_tail.prev_free_block
+            is queue.fake_free_list_head)
+
+    # Now any popleft should error
+    with pytest.raises(ValueError):
+        queue.popleft()
+
 def test_free_kv_cache_block_queue_get_all_free_blocks():
     # Create a list of KVCacheBlock objects
     blocks = [KVCacheBlock(block_id=i) for i in range(5)]
diff --git a/vllm/v1/core/block_pool.py b/vllm/v1/core/block_pool.py
index cbb6bb268..4d339d4c0 100644
--- a/vllm/v1/core/block_pool.py
+++ b/vllm/v1/core/block_pool.py
@@ -215,20 +215,15 @@ class BlockPool:
                 f"Cannot get {num_blocks} free blocks from the pool")
 
         ret: list[KVCacheBlock] = []
-        idx = 0
-        while idx < num_blocks:
-            # First allocate blocks.
-            curr_block = self.free_block_queue.popleft()
+        # Batch-pop from the free list to reduce Python overhead.
+        popped_blocks = self.free_block_queue.popleft_n(num_blocks)
+        for curr_block in popped_blocks:
             assert curr_block.ref_cnt == 0
-
             # If the block is cached, evict it.
             if self.enable_caching:
                 self._maybe_evict_cached_block(curr_block)
-
             curr_block.incr_ref()
             ret.append(curr_block)
-            idx += 1
-
         return ret
 
     def _maybe_evict_cached_block(self, block: KVCacheBlock) -> bool:
@@ -289,11 +284,14 @@ class BlockPool:
             ordered_blocks: A list of blocks to free ordered by their eviction
                 priority.
         """
+        append_list: list[KVCacheBlock] = []
         for block in ordered_blocks:
             block.decr_ref()
             # null_block should not be added to the free list.
             if block.ref_cnt == 0 and not block.is_null:
-                self.free_block_queue.append(block)
+                append_list.append(block)
+        if append_list:
+            self.free_block_queue.append_n(append_list)
 
     def reset_prefix_cache(self) -> bool:
         """Reset prefix cache. This function may be used in RLHF
diff --git a/vllm/v1/core/kv_cache_utils.py b/vllm/v1/core/kv_cache_utils.py
index 457d95cc7..4ad783109 100644
--- a/vllm/v1/core/kv_cache_utils.py
+++ b/vllm/v1/core/kv_cache_utils.py
@@ -293,27 +293,93 @@ class FreeKVCacheBlockQueue:
         block.prev_free_block = block.next_free_block = None
         self.num_free_blocks -= 1
 
-    def append(self, block: KVCacheBlock) -> None:
-        """Put a block back into the free list and increase
-        num_free_blocks by 1.
+    def popleft_n(self, n: int) -> list[KVCacheBlock]:
+        """Pop up to n free blocks from the head in a single splice.
+
+        Args:
+            n: Maximum number of blocks to pop.
+
+        Returns:
+            A list of popped blocks in order from head to tail.
+        """
+        if n <= 0:
+            return []
+        if (self.fake_free_list_head.next_free_block is self.fake_free_list_tail
+                or self.fake_free_list_head.next_free_block is None):
+            assert self.num_free_blocks == 0, (
+                f"num_free_blocks ({self.num_free_blocks}) is out of sync "
+                "with the free list.")
+            raise ValueError("No free blocks available")
+
+        # Determine the actual number of blocks to pop and the tail of the slice.
+        first_block: KVCacheBlock = self.fake_free_list_head.next_free_block  # type: ignore[assignment]
+        count = 1
+        tail_block = first_block
+        while count < n and tail_block.next_free_block is not None \
+                and tail_block.next_free_block is not self.fake_free_list_tail:
+            tail_block = tail_block.next_free_block
+            count += 1
+
+        # Detach [first_block, ..., tail_block] from the free list by splicing.
+        next_after_tail = tail_block.next_free_block  # could be fake tail
+        assert next_after_tail is not None
+        self.fake_free_list_head.next_free_block = next_after_tail
+        next_after_tail.prev_free_block = self.fake_free_list_head
+
+        # Collect popped blocks and clear their free-list links.
+        popped: list[KVCacheBlock] = []
+        curr = first_block
+        while True:
+            next_curr = curr.next_free_block
+            curr.prev_free_block = None
+            curr.next_free_block = None
+            popped.append(curr)
+            if curr is tail_block:
+                break
+            assert next_curr is not None
+            curr = next_curr
+
+        self.num_free_blocks -= count
+        return popped
+
+    def append_n(self, blocks: list[KVCacheBlock]) -> None:
+        """Append a list of blocks to the tail in a single splice.
 
         Args:
-            block: The block to append.
+            blocks: The blocks to append in order.
         """
+        if not blocks:
+            return
         if self.fake_free_list_tail.prev_free_block is None:
             raise RuntimeError(
                 "prev_free_block of fake_free_list_tail should always exist")
         last_block: KVCacheBlock = self.fake_free_list_tail.prev_free_block
 
-        # Connect the new block after the last block.
-        last_block.next_free_block = block
-        block.prev_free_block = last_block
+        # Link the first new block after the current last block.
+        first_new = blocks[0]
+        last_block.next_free_block = first_new
+        first_new.prev_free_block = last_block
 
-        # Connect the fake tail after the new block.
-        block.next_free_block = self.fake_free_list_tail
-        self.fake_free_list_tail.prev_free_block = block
+        # Chain the internal blocks.
+        for i in range(len(blocks) - 1):
+            a = blocks[i]
+            b = blocks[i + 1]
+            a.next_free_block = b
+            b.prev_free_block = a
+
+        # Link the last new block to the fake tail.
+        last_new = blocks[-1]
+        last_new.next_free_block = self.fake_free_list_tail
+        self.fake_free_list_tail.prev_free_block = last_new
+
+        self.num_free_blocks += len(blocks)
+
+    def append(self, block: KVCacheBlock) -> None:
+        """Append a single block to the tail.
+        This is a compatibility wrapper around append_n.
+        """
+        self.append_n([block])
 
-        self.num_free_blocks += 1
 
     def get_all_free_blocks(self) -> list[KVCacheBlock]:
         """Get all free blocks in the free list. Mainly used for testing.
