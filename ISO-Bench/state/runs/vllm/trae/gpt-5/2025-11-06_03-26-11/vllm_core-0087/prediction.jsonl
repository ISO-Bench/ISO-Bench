{"instance_id": "vllm-project__vllm-10904e6", "model_patch": "diff --git a/tests/v1/core/test_kv_cache_utils.py b/tests/v1/core/test_kv_cache_utils.py\nindex 68b060156..f4bda3dbb 100644\n--- a/tests/v1/core/test_kv_cache_utils.py\n+++ b/tests/v1/core/test_kv_cache_utils.py\n@@ -184,6 +184,80 @@ def test_free_kv_cache_block_queue_operations():\n     assert str(e.value) == \"No free blocks available\"\n \n \n+\n+\n+def test_free_kv_cache_block_queue_append_n():\n+    # Create an empty FreeKVCacheBlockQueue\n+    queue = FreeKVCacheBlockQueue([])\n+    blocks = [KVCacheBlock(block_id=i) for i in range(6)]\n+\n+    # Append 0 blocks: still empty\n+    queue.append_n([])\n+    assert queue.num_free_blocks == 0\n+    assert (queue.fake_free_list_head.next_free_block\n+            is queue.fake_free_list_tail)\n+    assert (queue.fake_free_list_tail.prev_free_block\n+            is queue.fake_free_list_head)\n+\n+    # Append 1 block\n+    queue.append_n(blocks[0:1])\n+    assert queue.num_free_blocks == 1\n+    assert queue.fake_free_list_head.next_free_block is blocks[0]\n+    assert blocks[0].prev_free_block is queue.fake_free_list_head\n+    assert blocks[0].next_free_block is queue.fake_free_list_tail\n+    assert queue.fake_free_list_tail.prev_free_block is blocks[0]\n+\n+    # Append 2 more blocks\n+    queue.append_n(blocks[1:3])\n+    assert queue.num_free_blocks == 3\n+    assert queue.fake_free_list_head.next_free_block is blocks[0]\n+    assert blocks[0].next_free_block is blocks[1]\n+    assert blocks[1].prev_free_block is blocks[0]\n+    assert blocks[1].next_free_block is blocks[2]\n+    assert blocks[2].prev_free_block is blocks[1]\n+    assert blocks[2].next_free_block is queue.fake_free_list_tail\n+    assert queue.fake_free_list_tail.prev_free_block is blocks[2]\n+\n+    # Append a single block again\n+    queue.append(blocks[3])\n+    assert queue.num_free_blocks == 4\n+    assert queue.fake_free_list_tail.prev_free_block is blocks[3]\n+    assert blocks[3].prev_free_block is blocks[2]\n+    assert blocks[3].next_free_block is queue.fake_free_list_tail\n+\n+\n+def test_free_kv_cache_block_queue_popleft_n():\n+    # Initialize 6 blocks in queue\n+    blocks = [KVCacheBlock(block_id=i) for i in range(6)]\n+    queue = FreeKVCacheBlockQueue(blocks)\n+\n+    # Pop zero returns empty\n+    popped0 = queue.popleft_n(0)\n+    assert popped0 == []\n+    assert queue.num_free_blocks == 6\n+\n+    # Pop two\n+    popped = queue.popleft_n(2)\n+    assert [b.block_id for b in popped] == [0, 1]\n+    assert queue.num_free_blocks == 4\n+    assert queue.fake_free_list_head.next_free_block is blocks[2]\n+    # Ensure popped blocks are detached\n+    assert all(b.prev_free_block is None and b.next_free_block is None\n+               for b in popped)\n+\n+    # Pop the rest\n+    popped_rest = queue.popleft_n(10)\n+    assert [b.block_id for b in popped_rest] == [2, 3, 4, 5]\n+    assert queue.num_free_blocks == 0\n+    assert (queue.fake_free_list_head.next_free_block\n+            is queue.fake_free_list_tail)\n+    assert (queue.fake_free_list_tail.prev_free_block\n+            is queue.fake_free_list_head)\n+\n+    # Now any popleft should error\n+    with pytest.raises(ValueError):\n+        queue.popleft()\n+\n def test_free_kv_cache_block_queue_get_all_free_blocks():\n     # Create a list of KVCacheBlock objects\n     blocks = [KVCacheBlock(block_id=i) for i in range(5)]\ndiff --git a/vllm/v1/core/block_pool.py b/vllm/v1/core/block_pool.py\nindex cbb6bb268..4d339d4c0 100644\n--- a/vllm/v1/core/block_pool.py\n+++ b/vllm/v1/core/block_pool.py\n@@ -215,20 +215,15 @@ class BlockPool:\n                 f\"Cannot get {num_blocks} free blocks from the pool\")\n \n         ret: list[KVCacheBlock] = []\n-        idx = 0\n-        while idx < num_blocks:\n-            # First allocate blocks.\n-            curr_block = self.free_block_queue.popleft()\n+        # Batch-pop from the free list to reduce Python overhead.\n+        popped_blocks = self.free_block_queue.popleft_n(num_blocks)\n+        for curr_block in popped_blocks:\n             assert curr_block.ref_cnt == 0\n-\n             # If the block is cached, evict it.\n             if self.enable_caching:\n                 self._maybe_evict_cached_block(curr_block)\n-\n             curr_block.incr_ref()\n             ret.append(curr_block)\n-            idx += 1\n-\n         return ret\n \n     def _maybe_evict_cached_block(self, block: KVCacheBlock) -> bool:\n@@ -289,11 +284,14 @@ class BlockPool:\n             ordered_blocks: A list of blocks to free ordered by their eviction\n                 priority.\n         \"\"\"\n+        append_list: list[KVCacheBlock] = []\n         for block in ordered_blocks:\n             block.decr_ref()\n             # null_block should not be added to the free list.\n             if block.ref_cnt == 0 and not block.is_null:\n-                self.free_block_queue.append(block)\n+                append_list.append(block)\n+        if append_list:\n+            self.free_block_queue.append_n(append_list)\n \n     def reset_prefix_cache(self) -> bool:\n         \"\"\"Reset prefix cache. This function may be used in RLHF\ndiff --git a/vllm/v1/core/kv_cache_utils.py b/vllm/v1/core/kv_cache_utils.py\nindex 457d95cc7..4ad783109 100644\n--- a/vllm/v1/core/kv_cache_utils.py\n+++ b/vllm/v1/core/kv_cache_utils.py\n@@ -293,27 +293,93 @@ class FreeKVCacheBlockQueue:\n         block.prev_free_block = block.next_free_block = None\n         self.num_free_blocks -= 1\n \n-    def append(self, block: KVCacheBlock) -> None:\n-        \"\"\"Put a block back into the free list and increase\n-        num_free_blocks by 1.\n+    def popleft_n(self, n: int) -> list[KVCacheBlock]:\n+        \"\"\"Pop up to n free blocks from the head in a single splice.\n+\n+        Args:\n+            n: Maximum number of blocks to pop.\n+\n+        Returns:\n+            A list of popped blocks in order from head to tail.\n+        \"\"\"\n+        if n <= 0:\n+            return []\n+        if (self.fake_free_list_head.next_free_block is self.fake_free_list_tail\n+                or self.fake_free_list_head.next_free_block is None):\n+            assert self.num_free_blocks == 0, (\n+                f\"num_free_blocks ({self.num_free_blocks}) is out of sync \"\n+                \"with the free list.\")\n+            raise ValueError(\"No free blocks available\")\n+\n+        # Determine the actual number of blocks to pop and the tail of the slice.\n+        first_block: KVCacheBlock = self.fake_free_list_head.next_free_block  # type: ignore[assignment]\n+        count = 1\n+        tail_block = first_block\n+        while count < n and tail_block.next_free_block is not None \\\n+                and tail_block.next_free_block is not self.fake_free_list_tail:\n+            tail_block = tail_block.next_free_block\n+            count += 1\n+\n+        # Detach [first_block, ..., tail_block] from the free list by splicing.\n+        next_after_tail = tail_block.next_free_block  # could be fake tail\n+        assert next_after_tail is not None\n+        self.fake_free_list_head.next_free_block = next_after_tail\n+        next_after_tail.prev_free_block = self.fake_free_list_head\n+\n+        # Collect popped blocks and clear their free-list links.\n+        popped: list[KVCacheBlock] = []\n+        curr = first_block\n+        while True:\n+            next_curr = curr.next_free_block\n+            curr.prev_free_block = None\n+            curr.next_free_block = None\n+            popped.append(curr)\n+            if curr is tail_block:\n+                break\n+            assert next_curr is not None\n+            curr = next_curr\n+\n+        self.num_free_blocks -= count\n+        return popped\n+\n+    def append_n(self, blocks: list[KVCacheBlock]) -> None:\n+        \"\"\"Append a list of blocks to the tail in a single splice.\n \n         Args:\n-            block: The block to append.\n+            blocks: The blocks to append in order.\n         \"\"\"\n+        if not blocks:\n+            return\n         if self.fake_free_list_tail.prev_free_block is None:\n             raise RuntimeError(\n                 \"prev_free_block of fake_free_list_tail should always exist\")\n         last_block: KVCacheBlock = self.fake_free_list_tail.prev_free_block\n \n-        # Connect the new block after the last block.\n-        last_block.next_free_block = block\n-        block.prev_free_block = last_block\n+        # Link the first new block after the current last block.\n+        first_new = blocks[0]\n+        last_block.next_free_block = first_new\n+        first_new.prev_free_block = last_block\n \n-        # Connect the fake tail after the new block.\n-        block.next_free_block = self.fake_free_list_tail\n-        self.fake_free_list_tail.prev_free_block = block\n+        # Chain the internal blocks.\n+        for i in range(len(blocks) - 1):\n+            a = blocks[i]\n+            b = blocks[i + 1]\n+            a.next_free_block = b\n+            b.prev_free_block = a\n+\n+        # Link the last new block to the fake tail.\n+        last_new = blocks[-1]\n+        last_new.next_free_block = self.fake_free_list_tail\n+        self.fake_free_list_tail.prev_free_block = last_new\n+\n+        self.num_free_blocks += len(blocks)\n+\n+    def append(self, block: KVCacheBlock) -> None:\n+        \"\"\"Append a single block to the tail.\n+        This is a compatibility wrapper around append_n.\n+        \"\"\"\n+        self.append_n([block])\n \n-        self.num_free_blocks += 1\n \n     def get_all_free_blocks(self) -> list[KVCacheBlock]:\n         \"\"\"Get all free blocks in the free list. Mainly used for testing.\n", "model_name_or_path": "gpt-5-2025-08-07"}
