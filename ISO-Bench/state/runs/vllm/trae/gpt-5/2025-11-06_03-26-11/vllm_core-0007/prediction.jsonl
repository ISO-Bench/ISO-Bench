{"instance_id": "vllm-project__vllm-d263bd9", "model_patch": "diff --git a/model_patch.diff b/model_patch.diff\nnew file mode 100644\nindex 000000000..e69de29bb\ndiff --git a/vllm/v1/worker/gpu_model_runner.py b/vllm/v1/worker/gpu_model_runner.py\nindex abcd4b007..bc03c495b 100644\n--- a/vllm/v1/worker/gpu_model_runner.py\n+++ b/vllm/v1/worker/gpu_model_runner.py\n@@ -118,32 +118,42 @@ class GPUModelRunner:\n             dtype=self.dtype,\n             device=self.device)\n \n-        self.input_ids_cpu = torch.zeros(self.max_num_tokens,\n+        self.input_ids_cpu = torch.empty(self.max_num_tokens,\n                                          dtype=torch.int32,\n                                          device=\"cpu\",\n                                          pin_memory=self.pin_memory)\n         self.input_ids_np = self.input_ids_cpu.numpy()\n-        self.positions_cpu = torch.zeros(self.max_num_tokens,\n+        self.positions_cpu = torch.empty(self.max_num_tokens,\n                                          dtype=torch.int64,\n                                          device=\"cpu\",\n                                          pin_memory=self.pin_memory)\n         self.positions_np = self.positions_cpu.numpy()\n-        self.slot_mapping_cpu = torch.zeros(self.max_num_tokens,\n+        self.slot_mapping_cpu = torch.empty(self.max_num_tokens,\n                                             dtype=torch.int32,\n                                             device=\"cpu\",\n                                             pin_memory=self.pin_memory)\n         self.slot_mapping_np = self.slot_mapping_cpu.numpy()\n-        self.query_start_loc_cpu = torch.zeros(self.max_num_reqs + 1,\n+        self.query_start_loc_cpu = torch.empty(self.max_num_reqs + 1,\n                                                dtype=torch.int32,\n                                                device=\"cpu\",\n                                                pin_memory=self.pin_memory)\n         self.query_start_loc_np = self.query_start_loc_cpu.numpy()\n-        self.seq_start_loc_cpu = torch.zeros(self.max_num_reqs + 1,\n+        self.seq_start_loc_cpu = torch.empty(self.max_num_reqs + 1,\n                                              dtype=torch.int32,\n                                              device=\"cpu\",\n                                              pin_memory=self.pin_memory)\n         self.seq_start_loc_np = self.seq_start_loc_cpu.numpy()\n \n+        # OPTIMIZATION: Cache common arange to reduce per-step allocations\n+        self.arange_np = np.arange(max(self.max_num_reqs, self.max_model_len),\n+                                   dtype=np.int32)\n+        # OPTIMIZATION: Preallocate token_indices buffer to avoid from_numpy overhead\n+        self.token_indices_cpu = torch.empty(self.max_num_tokens,\n+                                             dtype=torch.int64,\n+                                             device=\"cpu\",\n+                                             pin_memory=self.pin_memory)\n+        self.token_indices_np = self.token_indices_cpu.numpy()\n+\n     def _update_states(self, scheduler_output: \"SchedulerOutput\") -> None:\n         # Remove stopped requests from the cached states.\n         # Keep the states of the pre-empted requests.\n@@ -269,11 +279,13 @@ class GPUModelRunner:\n \n         # Get request indices.\n         # E.g., [2, 5, 3] -> [0, 0, 1, 1, 1, 1, 1, 2, 2, 2]\n-        req_indices = np.repeat(np.arange(num_reqs), num_scheduled_tokens)\n+        req_indices = np.repeat(self.arange_np[:num_reqs],\n+                                num_scheduled_tokens)\n \n         # Get batched arange.\n         # E.g., [2, 5, 3] -> [0, 1, 0, 1, 2, 3, 4, 0, 1, 2]\n-        arange = np.concatenate([np.arange(n) for n in num_scheduled_tokens])\n+        arange = np.concatenate([self.arange_np[:n]\n+                                 for n in num_scheduled_tokens])\n \n         # Get positions.\n         positions_np = self.positions_np[:total_num_scheduled_tokens]\n@@ -285,14 +297,16 @@ class GPUModelRunner:\n         # E.g., [0, 1, 0, 1, 2, 3, 4, 0, 1, 2]\n         # -> [0, 1, M, M + 1, M + 2, M + 3, M + 4, 2 * M, 2 * M + 1, 2 * M + 2]\n         # where M is the max_model_len.\n-        token_indices = (positions_np +\n-                         req_indices * self.input_batch.token_ids_cpu.shape[1])\n+        token_indices_np = self.token_indices_np[:total_num_scheduled_tokens]\n+        stride = self.input_batch.token_ids_cpu.shape[1]\n+        np.multiply(req_indices, stride, out=token_indices_np)\n+        np.add(positions_np, token_indices_np, out=token_indices_np)\n         # NOTE(woosuk): We use torch.index_select instead of np.take here\n         # because torch.index_select is much faster than np.take for large\n         # tensors.\n         torch.index_select(self.input_batch.token_ids_cpu_tensor.flatten(),\n                            0,\n-                           torch.from_numpy(token_indices),\n+                           self.token_indices_cpu[:total_num_scheduled_tokens],\n                            out=self.input_ids_cpu[:total_num_scheduled_tokens])\n \n         # Calculate the slot mapping.\n@@ -648,6 +662,6 @@ class GPUModelRunner:\n             num_blocks, self.block_size, self.num_kv_heads, self.head_size)\n         for _ in range(self.num_attn_layers):\n             self.kv_caches.append(\n-                torch.zeros(kv_cache_shape,\n+                torch.empty(kv_cache_shape,\n                             dtype=self.kv_cache_dtype,\n                             device=self.device))\n", "model_name_or_path": "gpt-5-2025-08-07"}
