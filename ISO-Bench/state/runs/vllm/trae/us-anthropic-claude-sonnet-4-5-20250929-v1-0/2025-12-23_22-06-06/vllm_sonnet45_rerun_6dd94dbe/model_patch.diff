diff --git a/vllm/worker/model_runner.py b/vllm/worker/model_runner.py
index cf2f1c6..b3e75c1 100644
--- a/vllm/worker/model_runner.py
+++ b/vllm/worker/model_runner.py
@@ -1322,7 +1322,7 @@ class GPUModelRunnerBase(ModelRunnerBase[TModelInputForGPU]):
             # multiplying the list, to avoid Dynamo from treating them as
             # tensor aliasing.
             kv_caches = [
-                torch.tensor([], dtype=torch.float32, device=self.device)
+                torch.empty(0, dtype=torch.float32, device=self.device)
                 for _ in range(num_layers)
             ]
             finished_requests_ids = [seq.request_id for seq in seqs]
@@ -1437,10 +1437,10 @@ class GPUModelRunnerBase(ModelRunnerBase[TModelInputForGPU]):
 
         # Prepare dummy inputs. These will be reused for all batch sizes.
         max_batch_size = self.max_batchsize_to_capture
-        input_tokens = torch.zeros(max_batch_size,
+        input_tokens = torch.empty(max_batch_size,
                                    dtype=torch.long,
                                    device=self.device)
-        input_positions = torch.zeros(max_batch_size,
+        input_positions = torch.empty(max_batch_size,
                                       dtype=torch.long,
                                       device=self.device)
         if self.model_config.uses_mrope:
@@ -1568,12 +1568,12 @@ class GPUModelRunnerBase(ModelRunnerBase[TModelInputForGPU]):
         """
         # During the decode phase encoder_input_ids and encoder_positions are
         # unset. Do the same thing for graph capture.
-        capture_inputs["encoder_input_ids"] = torch.tensor([],
-                                                           dtype=torch.long,
-                                                           device=self.device)
-        capture_inputs["encoder_positions"] = torch.tensor([],
-                                                           dtype=torch.long,
-                                                           device=self.device)
+        capture_inputs["encoder_input_ids"] = torch.empty(0,
+                                                          dtype=torch.long,
+                                                          device=self.device)
+        capture_inputs["encoder_positions"] = torch.empty(0,
+                                                          dtype=torch.long,
+                                                          device=self.device)
 
     @property
     def vocab_size(self) -> int:
@@ -1750,8 +1750,10 @@ class ModelRunner(GPUModelRunnerBase[ModelInputForGPUWithSamplingMetadata]):
                     model_forward_end)
                 orig_model_forward_time = 0.0
                 if intermediate_tensors is not None:
-                    orig_model_forward_time = intermediate_tensors.tensors.get(
-                        "model_forward_time", torch.tensor(0.0)).item()
+                    model_forward_time_tensor = intermediate_tensors.tensors.get(
+                        "model_forward_time", None)
+                    if model_forward_time_tensor is not None:
+                        orig_model_forward_time = model_forward_time_tensor.item()
                 hidden_or_intermediate_states.tensors["model_forward_time"] = (
                     torch.tensor(model_forward_time + orig_model_forward_time))
             return hidden_or_intermediate_states
@@ -1778,8 +1780,10 @@ class ModelRunner(GPUModelRunnerBase[ModelInputForGPUWithSamplingMetadata]):
                 model_forward_end)
             orig_model_forward_time = 0.0
             if intermediate_tensors is not None:
-                orig_model_forward_time = intermediate_tensors.tensors.get(
-                    "model_forward_time", torch.tensor(0.0)).item()
+                model_forward_time_tensor = intermediate_tensors.tensors.get(
+                    "model_forward_time", None)
+                if model_forward_time_tensor is not None:
+                    orig_model_forward_time = model_forward_time_tensor.item()
             # If there are multiple workers, we are still tracking the latency
             # from the start time of the driver worker to the end time of the
             # driver worker. The model forward time will then end up covering
