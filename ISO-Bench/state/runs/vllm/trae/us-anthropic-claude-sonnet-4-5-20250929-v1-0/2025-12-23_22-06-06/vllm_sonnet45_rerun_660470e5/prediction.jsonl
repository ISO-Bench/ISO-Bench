{"instance_id": "/home/ubuntu/OmniPerf-Bench/vllm__repo-8d59dbb", "model_patch": "diff --git a/vllm/core/evictor_v2.py b/vllm/core/evictor_v2.py\nindex 3dd12e2..58086d7 100644\n--- a/vllm/core/evictor_v2.py\n+++ b/vllm/core/evictor_v2.py\n@@ -1,6 +1,7 @@\n import enum\n+import heapq\n from abc import ABC, abstractmethod\n-from typing import OrderedDict, Tuple\n+from typing import Dict, List, Tuple\n \n \n class EvictionPolicy(enum.Enum):\n@@ -76,7 +77,11 @@ class LRUEvictor(Evictor):\n     \"\"\"\n \n     def __init__(self):\n-        self.free_table: OrderedDict[int, BlockMetaData] = OrderedDict()\n+        # Use regular dict for O(1) lookups instead of OrderedDict\n+        self.free_table: Dict[int, BlockMetaData] = {}\n+        # Min-heap for O(log n) eviction: (last_accessed, -num_hashed_tokens, block_id)\n+        # Negative num_hashed_tokens to get max num_hashed_tokens with min-heap\n+        self.heap: List[Tuple[float, int, int]] = []\n \n     def __contains__(self, block_id: int) -> bool:\n         return block_id in self.free_table\n@@ -85,36 +90,51 @@ class LRUEvictor(Evictor):\n         if len(self.free_table) == 0:\n             raise ValueError(\"No usable cache memory left\")\n \n-        evicted_block = next(iter(self.free_table.values()))\n-        evicted_block_id = next(iter(self.free_table.keys()))\n-        # The blocks with the lowest timestamps should be placed consecutively\n-        # at the start of OrderedDict. Loop through all these blocks to\n-        # find the one with maximum number of hashed tokens.\n-        for _id, block in self.free_table.items():\n-            if evicted_block.last_accessed > block.last_accessed or (\n-                    evicted_block.last_accessed == block.last_accessed and\n-                    evicted_block.num_hashed_tokens < block.num_hashed_tokens):\n-                evicted_block = block\n-                evicted_block_id = _id\n+        # Pop from heap until we find a valid entry (lazy deletion)\n+        while self.heap:\n+            last_accessed, neg_num_hashed_tokens, block_id = heapq.heappop(\n+                self.heap)\n \n-        self.free_table.pop(evicted_block_id)\n+            # Check if this block is still in the free_table\n+            if block_id not in self.free_table:\n+                # This entry was removed or updated, skip it\n+                continue\n \n-        return evicted_block_id, evicted_block.content_hash\n+            metadata = self.free_table[block_id]\n+            # Verify this heap entry matches current metadata (not stale from update)\n+            if (metadata.last_accessed == last_accessed\n+                    and metadata.num_hashed_tokens == -neg_num_hashed_tokens):\n+                # Valid entry found, evict it\n+                content_hash = metadata.content_hash\n+                del self.free_table[block_id]\n+                return block_id, content_hash\n+\n+        # Should not reach here if free_table is not empty\n+        raise ValueError(\"No usable cache memory left\")\n \n     def add(self, block_id: int, content_hash: int, num_hashed_tokens: int,\n             last_accessed: float):\n         self.free_table[block_id] = BlockMetaData(content_hash,\n                                                   num_hashed_tokens,\n                                                   last_accessed)\n+        # Push to heap with negative num_hashed_tokens for max-heap behavior\n+        heapq.heappush(self.heap,\n+                       (last_accessed, -num_hashed_tokens, block_id))\n \n     def update(self, block_id: int, last_accessed: float):\n-        self.free_table[block_id].last_accessed = last_accessed\n+        # Update metadata in free_table\n+        metadata = self.free_table[block_id]\n+        metadata.last_accessed = last_accessed\n+        # Push new entry to heap (old entry will be filtered out during evict)\n+        heapq.heappush(self.heap,\n+                       (last_accessed, -metadata.num_hashed_tokens, block_id))\n \n     def remove(self, block_id: int):\n         if block_id not in self.free_table:\n             raise ValueError(\n                 \"Attempting to remove block that's not in the evictor\")\n-        self.free_table.pop(block_id)\n+        # Remove from free_table; stale heap entries will be filtered during evict\n+        del self.free_table[block_id]\n \n     @property\n     def num_blocks(self) -> int:\n", "model_name_or_path": "gpt-5-2025-08-07"}
