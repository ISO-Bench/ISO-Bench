diff --git a/tests/v1/attention/test_attention_backends.py b/tests/v1/attention/test_attention_backends.py
index b4e0101..243e859 100644
--- a/tests/v1/attention/test_attention_backends.py
+++ b/tests/v1/attention/test_attention_backends.py
@@ -155,7 +155,8 @@ def create_and_prepopulate_kv_cache(
         perm = torch.arange(
             1, blocks_end)  # Sequential order starting from block 1
 
-    inv_perm = torch.zeros(blocks_end, dtype=torch.long, device=device)
+    inv_perm = torch.empty(blocks_end, dtype=torch.long, device=device)
+    inv_perm[0] = 0
     inv_perm[1:] = torch.argsort(
         perm) + 1  # Add 1 to account for starting from block 1
     kv_cache[:, 1:blocks_end, ...] = kv_cache[:, perm, ...]
@@ -172,14 +173,15 @@ def create_and_prepopulate_kv_cache(
 
         # Create a realistic slot mapping that corresponds to the block table
     for i in range(batch_size):
-        token_offsets = torch.arange(int(query_lens[i])) + int(context_lens[i])
+        # Optimize: Create tensor directly on target device
+        token_offsets = torch.arange(int(query_lens[i]), device=device) + int(context_lens[i])
         block_indices = token_offsets // block_size
         token_inter_block_offsets = token_offsets % block_size
         start = common_attn_metadata.query_start_loc_cpu[i]
         end = common_attn_metadata.query_start_loc_cpu[i + 1]
         slot_mapping[start:end] = block_table[
             i,
-            block_indices] * block_size + token_inter_block_offsets.to(device)
+            block_indices] * block_size + token_inter_block_offsets
 
     return kv_cache
 
@@ -359,10 +361,11 @@ def test_backend_correctness(batch_spec_name: str, model: str):
         #  (context_len + i)
         kv_len = s_len
         offset = context_len
-        attn_mask = torch.full((q_len, kv_len),
-                               float('-inf'),
+        # Optimize: Use empty + fill_ instead of torch.full
+        attn_mask = torch.empty((q_len, kv_len),
                                device=device,
                                dtype=dtype)
+        attn_mask.fill_(float('-inf'))
         for i in range(q_len):
             attn_mask[i, :offset + i + 1] = 0.0
 
diff --git a/tests/v1/attention/utils.py b/tests/v1/attention/utils.py
index 30cfbdd..2d944a6 100644
--- a/tests/v1/attention/utils.py
+++ b/tests/v1/attention/utils.py
@@ -43,9 +43,10 @@ def create_common_attn_metadata(
         max_block_idx: int = 1000) -> CommonAttentionMetadata:
     """Create CommonAttentionMetadata from a BatchSpec and ModelParams."""
     # Create query start locations
-    query_start_loc = torch.zeros(batch_spec.batch_size + 1,
+    query_start_loc = torch.empty(batch_spec.batch_size + 1,
                                   dtype=torch.int32,
                                   device=device)
+    query_start_loc[0] = 0
     query_start_loc[1:] = torch.tensor(batch_spec.query_lens,
                                        dtype=torch.int32,
                                        device=device).cumsum(0)
diff --git a/vllm/v1/attention/backends/flashinfer.py b/vllm/v1/attention/backends/flashinfer.py
index 953ef26..d1d6f3d 100755
--- a/vllm/v1/attention/backends/flashinfer.py
+++ b/vllm/v1/attention/backends/flashinfer.py
@@ -422,12 +422,14 @@ class FlashInferMetadataBuilder(AttentionMetadataBuilder[FlashInferMetadata]):
                 < block_table_bounds.unsqueeze(1))
         paged_kv_indices = block_table_tensor[mask]
 
-        paged_kv_indptr = torch.cat([
-            torch.zeros(1,
-                        dtype=block_table_bounds.dtype,
-                        device=block_table_bounds.device),
-            block_table_bounds.cumsum(dim=0, dtype=torch.int32)
-        ])
+        # Optimize: Use empty tensor with explicit zero assignment instead of zeros
+        cumsum_result = block_table_bounds.cumsum(dim=0, dtype=torch.int32)
+        paged_kv_indptr = torch.empty(
+            cumsum_result.shape[0] + 1,
+            dtype=block_table_bounds.dtype,
+            device=block_table_bounds.device)
+        paged_kv_indptr[0] = 0
+        paged_kv_indptr[1:] = cumsum_result
 
         paged_kv_last_page_len = seq_lens % page_size
         paged_kv_last_page_len = torch.where(paged_kv_last_page_len == 0,
