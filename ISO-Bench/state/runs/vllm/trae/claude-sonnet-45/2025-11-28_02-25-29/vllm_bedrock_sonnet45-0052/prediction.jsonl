{"instance_id": "/home/ubuntu/OmniPerf-Bench/vllm__repo-20478c4", "model_patch": "diff --git a/tests/core/test_block_manager.py b/tests/core/test_block_manager.py\nindex 44ac05a14..9473a33f0 100644\n--- a/tests/core/test_block_manager.py\n+++ b/tests/core/test_block_manager.py\n@@ -4,7 +4,7 @@ from typing import List\n \n from vllm import SamplingParams\n from vllm.block import PhysicalTokenBlock\n-from vllm.core.block_manager import (BlockAllocator, BlockSpaceManager,\n+from vllm.core.block_manager import (UncachedBlockAllocator, BlockSpaceManager,\n                                      AllocStatus)\n from vllm.utils import Device\n from vllm.sequence import Sequence, SequenceGroup, SequenceStatus, Logprob\n@@ -15,7 +15,8 @@ from .utils import create_dummy_prompt\n def test_block_allocator_allocate():\n     block_size = 4\n     num_cpu_blocks = 4\n-    cpu_allocator = BlockAllocator(Device.CPU, block_size, num_cpu_blocks)\n+    cpu_allocator = UncachedBlockAllocator(Device.CPU, block_size,\n+                                           num_cpu_blocks)\n \n     # Allocate all available cpu blocks.\n     num_free = num_cpu_blocks\n@@ -24,7 +25,7 @@ def test_block_allocator_allocate():\n         block = cpu_allocator.allocate()\n         num_free -= 1\n \n-        assert block.block_hash not in cpu_allocator.evictor\n+        assert block not in cpu_allocator.free_blocks\n         assert cpu_allocator.get_num_free_blocks() == num_free\n \n     with pytest.raises(ValueError):\n@@ -34,14 +35,15 @@ def test_block_allocator_allocate():\n def test_block_allocator_free():\n     block_size = 4\n     num_cpu_blocks = 4\n-    cpu_allocator = BlockAllocator(Device.CPU, block_size, num_cpu_blocks)\n+    cpu_allocator = UncachedBlockAllocator(Device.CPU, block_size,\n+                                           num_cpu_blocks)\n \n     # Allocate all available cpu blocks.\n     blocks: List[PhysicalTokenBlock] = []\n     for _ in range(num_cpu_blocks):\n         block = cpu_allocator.allocate()\n         blocks.append(block)\n-        assert block.block_hash not in cpu_allocator.evictor\n+        assert block not in cpu_allocator.free_blocks\n \n     # Free all allocated cpu blocks.\n     num_free = 0\n@@ -49,7 +51,7 @@ def test_block_allocator_free():\n     for block in blocks:\n         cpu_allocator.free(block)\n         num_free += 1\n-        assert block.block_hash in cpu_allocator.evictor\n+        assert block in cpu_allocator.free_blocks\n         assert cpu_allocator.get_num_free_blocks() == num_free\n \n         with pytest.raises(ValueError):\ndiff --git a/vllm/core/block_manager.py b/vllm/core/block_manager.py\nindex 8b089a565..e5191c29a 100644\n--- a/vllm/core/block_manager.py\n+++ b/vllm/core/block_manager.py\n@@ -10,8 +10,63 @@ from vllm.utils import Device\n from vllm.core.evictor import Evictor, EvictionPolicy, make_evictor\n \n \n-class BlockAllocator:\n-    \"\"\"Manages free physical token blocks for a device.\n+class UncachedBlockAllocator:\n+    \"\"\"Manages free physical token blocks for a device without caching.\n+    \n+    This allocator is optimized for scenarios where prefix caching is disabled.\n+    It uses a simple list of free blocks instead of an evictor.\n+    \"\"\"\n+\n+    def __init__(self,\n+                 device: Device,\n+                 block_size: int,\n+                 num_blocks: int) -> None:\n+        self.device = device\n+        self.block_size = block_size\n+        self.num_blocks = num_blocks\n+\n+        self.current_num_blocks = 0\n+        self.free_blocks: List[PhysicalTokenBlock] = []\n+\n+    def allocate(self,\n+                 block_hash: Optional[int] = None,\n+                 num_hashed_tokens: int = 0) -> PhysicalTokenBlock:\n+        if self.free_blocks:\n+            block = self.free_blocks.pop()\n+            block.ref_count = 1\n+            return block\n+        if self.current_num_blocks < self.num_blocks:\n+            block = PhysicalTokenBlock(device=self.device,\n+                                       block_number=self.current_num_blocks,\n+                                       block_size=self.block_size,\n+                                       block_hash=-1,\n+                                       num_hashed_tokens=0)\n+            self.current_num_blocks += 1\n+            block.ref_count = 1\n+            return block\n+        raise ValueError(\"No free blocks available\")\n+\n+    def free(self, block: PhysicalTokenBlock) -> None:\n+        if block.ref_count == 0:\n+            raise ValueError(f\"Double free! {block} is already freed.\")\n+        block.ref_count -= 1\n+        if block.ref_count == 0:\n+            self.free_blocks.append(block)\n+\n+    def get_num_free_blocks(self) -> int:\n+        return self.num_blocks - self.current_num_blocks + len(self.free_blocks)\n+\n+    def contains_block(self, block_hash: int) -> bool:\n+        # Without caching, we never have cached blocks\n+        return False\n+\n+    def update_hash(self, block_hash: int, block: PhysicalTokenBlock):\n+        # Without caching, we don't need to update hashes\n+        pass\n+\n+\n+class PrefixCachingBlockAllocator:\n+    \"\"\"Manages free physical token blocks for a device with prefix caching.\n \n     The allocator maintains a list of free blocks and allocates a block when\n     requested. When a block is freed, its reference count is decremented. If\n@@ -22,19 +77,14 @@ class BlockAllocator:\n                  device: Device,\n                  block_size: int,\n                  num_blocks: int,\n-                 eviction_policy: EvictionPolicy = EvictionPolicy.LRU,\n-                 enable_caching: bool = False) -> None:\n+                 eviction_policy: EvictionPolicy = EvictionPolicy.LRU) -> None:\n         self.device = device\n         self.block_size = block_size\n         self.num_blocks = num_blocks\n-        self.enable_caching = enable_caching\n \n         self.current_num_blocks = 0\n         self.cached_blocks: Dict[int, PhysicalTokenBlock] = {}\n \n-        # Switch over to FIFO eviction when caching is disabled\n-        if not self.enable_caching:\n-            eviction_policy = EvictionPolicy.FIFO\n         self.evictor: Evictor = make_evictor(eviction_policy)\n \n         self.default_hash_ctr = count()\n@@ -57,13 +107,6 @@ class BlockAllocator:\n     def allocate(self,\n                  block_hash: Optional[int] = None,\n                  num_hashed_tokens: int = 0) -> PhysicalTokenBlock:\n-        # If caching is disabled, just allocate a new block and return it\n-        if not self.enable_caching:\n-            block = self.allocate_block(next(self.default_hash_ctr),\n-                                        num_hashed_tokens)\n-            block.ref_count += 1\n-            return block\n-\n         if block_hash is None:\n             block_hash = next(self.default_hash_ctr)\n         if block_hash in self.evictor:\n@@ -89,10 +132,7 @@ class BlockAllocator:\n         if block.ref_count == 0:\n             assert block.block_hash not in self.evictor\n             self.evictor.add(block)\n-\n-            # If caching is enabled, remove the block from the cached_blocks\n-            if self.enable_caching:\n-                del self.cached_blocks[block.block_hash]\n+            del self.cached_blocks[block.block_hash]\n \n     def get_num_free_blocks(self) -> int:\n         return (self.num_blocks - self.current_num_blocks +\n@@ -102,14 +142,28 @@ class BlockAllocator:\n         return block_hash in self.cached_blocks or block_hash in self.evictor\n \n     def update_hash(self, block_hash: int, block: PhysicalTokenBlock):\n-        # If caching is enabled, update the hash of block and the\n-        # cached_blocks dictionary.\n-        if self.enable_caching:\n-            assert not self.contains_block(block_hash)\n-            old_hash = block.block_hash\n-            block.block_hash = block_hash\n-            del self.cached_blocks[old_hash]\n-            self.cached_blocks[block_hash] = block\n+        # Update the hash of block and the cached_blocks dictionary.\n+        assert not self.contains_block(block_hash)\n+        old_hash = block.block_hash\n+        block.block_hash = block_hash\n+        del self.cached_blocks[old_hash]\n+        self.cached_blocks[block_hash] = block\n+\n+\n+def BlockAllocator(device: Device,\n+                   block_size: int,\n+                   num_blocks: int,\n+                   eviction_policy: EvictionPolicy = EvictionPolicy.LRU,\n+                   enable_caching: bool = False):\n+    \"\"\"Factory function to create the appropriate block allocator.\n+    \n+    Returns UncachedBlockAllocator when caching is disabled for better performance,\n+    or PrefixCachingBlockAllocator when caching is enabled.\n+    \"\"\"\n+    if enable_caching:\n+        return PrefixCachingBlockAllocator(device, block_size, num_blocks, eviction_policy)\n+    else:\n+        return UncachedBlockAllocator(device, block_size, num_blocks)\n \n \n class AllocStatus(enum.Enum):\ndiff --git a/vllm/core/evictor.py b/vllm/core/evictor.py\nindex 1d81f5a97..16ca8aff1 100644\n--- a/vllm/core/evictor.py\n+++ b/vllm/core/evictor.py\n@@ -64,40 +64,22 @@ class LRUEvictor(Evictor):\n     def __contains__(self, block_hash: int) -> bool:\n         return block_hash in self.free_table\n \n-    # TODO: The performance of this evict function can be optimized further.\n     def evict(self) -> PhysicalTokenBlock:\n-        free_blocks: List[PhysicalTokenBlock] = list(self.free_table.values())\n-        if len(free_blocks) == 0:\n+        if len(self.free_table) == 0:\n             raise ValueError(\"No usable cache memory left\")\n \n-        # Find lowest timestamp\n-        lowest_timestamp = free_blocks[0].last_accessed\n-        for block in free_blocks:\n-            if block.last_accessed < lowest_timestamp:\n-                lowest_timestamp = block.last_accessed\n-\n-        # Find all blocks with the lowest timestamp\n-        least_recent: List[PhysicalTokenBlock] = []\n-        for block in free_blocks:\n-            if block.last_accessed == lowest_timestamp:\n-                least_recent.append(block)\n-\n-        # Find highest prefix count per block\n-        highest_num_hashed_tokens = 0\n-        for block in least_recent:\n-            if block.num_hashed_tokens > highest_num_hashed_tokens:\n-                highest_num_hashed_tokens = block.num_hashed_tokens\n-\n+        # Find the block with lowest timestamp and highest num_hashed_tokens in a single pass\n         evicted_block: Optional[PhysicalTokenBlock] = None\n-\n-        # Find the first block with the lowest timestamp\n-        for block in least_recent:\n-            if block.num_hashed_tokens == highest_num_hashed_tokens:\n+        for block in self.free_table.values():\n+            if evicted_block is None:\n+                evicted_block = block\n+            elif block.last_accessed < evicted_block.last_accessed:\n+                evicted_block = block\n+            elif (block.last_accessed == evicted_block.last_accessed and\n+                  block.num_hashed_tokens > evicted_block.num_hashed_tokens):\n                 evicted_block = block\n-                break\n \n         assert evicted_block is not None\n-\n         del self.free_table[evicted_block.block_hash]\n \n         evicted_block.computed = False\n", "model_name_or_path": "gpt-5-2025-08-07"}
