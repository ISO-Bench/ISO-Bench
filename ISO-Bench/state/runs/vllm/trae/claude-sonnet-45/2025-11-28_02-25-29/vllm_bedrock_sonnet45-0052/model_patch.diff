diff --git a/tests/core/test_block_manager.py b/tests/core/test_block_manager.py
index 44ac05a14..9473a33f0 100644
--- a/tests/core/test_block_manager.py
+++ b/tests/core/test_block_manager.py
@@ -4,7 +4,7 @@ from typing import List
 
 from vllm import SamplingParams
 from vllm.block import PhysicalTokenBlock
-from vllm.core.block_manager import (BlockAllocator, BlockSpaceManager,
+from vllm.core.block_manager import (UncachedBlockAllocator, BlockSpaceManager,
                                      AllocStatus)
 from vllm.utils import Device
 from vllm.sequence import Sequence, SequenceGroup, SequenceStatus, Logprob
@@ -15,7 +15,8 @@ from .utils import create_dummy_prompt
 def test_block_allocator_allocate():
     block_size = 4
     num_cpu_blocks = 4
-    cpu_allocator = BlockAllocator(Device.CPU, block_size, num_cpu_blocks)
+    cpu_allocator = UncachedBlockAllocator(Device.CPU, block_size,
+                                           num_cpu_blocks)
 
     # Allocate all available cpu blocks.
     num_free = num_cpu_blocks
@@ -24,7 +25,7 @@ def test_block_allocator_allocate():
         block = cpu_allocator.allocate()
         num_free -= 1
 
-        assert block.block_hash not in cpu_allocator.evictor
+        assert block not in cpu_allocator.free_blocks
         assert cpu_allocator.get_num_free_blocks() == num_free
 
     with pytest.raises(ValueError):
@@ -34,14 +35,15 @@ def test_block_allocator_allocate():
 def test_block_allocator_free():
     block_size = 4
     num_cpu_blocks = 4
-    cpu_allocator = BlockAllocator(Device.CPU, block_size, num_cpu_blocks)
+    cpu_allocator = UncachedBlockAllocator(Device.CPU, block_size,
+                                           num_cpu_blocks)
 
     # Allocate all available cpu blocks.
     blocks: List[PhysicalTokenBlock] = []
     for _ in range(num_cpu_blocks):
         block = cpu_allocator.allocate()
         blocks.append(block)
-        assert block.block_hash not in cpu_allocator.evictor
+        assert block not in cpu_allocator.free_blocks
 
     # Free all allocated cpu blocks.
     num_free = 0
@@ -49,7 +51,7 @@ def test_block_allocator_free():
     for block in blocks:
         cpu_allocator.free(block)
         num_free += 1
-        assert block.block_hash in cpu_allocator.evictor
+        assert block in cpu_allocator.free_blocks
         assert cpu_allocator.get_num_free_blocks() == num_free
 
         with pytest.raises(ValueError):
diff --git a/vllm/core/block_manager.py b/vllm/core/block_manager.py
index 8b089a565..e5191c29a 100644
--- a/vllm/core/block_manager.py
+++ b/vllm/core/block_manager.py
@@ -10,8 +10,63 @@ from vllm.utils import Device
 from vllm.core.evictor import Evictor, EvictionPolicy, make_evictor
 
 
-class BlockAllocator:
-    """Manages free physical token blocks for a device.
+class UncachedBlockAllocator:
+    """Manages free physical token blocks for a device without caching.
+    
+    This allocator is optimized for scenarios where prefix caching is disabled.
+    It uses a simple list of free blocks instead of an evictor.
+    """
+
+    def __init__(self,
+                 device: Device,
+                 block_size: int,
+                 num_blocks: int) -> None:
+        self.device = device
+        self.block_size = block_size
+        self.num_blocks = num_blocks
+
+        self.current_num_blocks = 0
+        self.free_blocks: List[PhysicalTokenBlock] = []
+
+    def allocate(self,
+                 block_hash: Optional[int] = None,
+                 num_hashed_tokens: int = 0) -> PhysicalTokenBlock:
+        if self.free_blocks:
+            block = self.free_blocks.pop()
+            block.ref_count = 1
+            return block
+        if self.current_num_blocks < self.num_blocks:
+            block = PhysicalTokenBlock(device=self.device,
+                                       block_number=self.current_num_blocks,
+                                       block_size=self.block_size,
+                                       block_hash=-1,
+                                       num_hashed_tokens=0)
+            self.current_num_blocks += 1
+            block.ref_count = 1
+            return block
+        raise ValueError("No free blocks available")
+
+    def free(self, block: PhysicalTokenBlock) -> None:
+        if block.ref_count == 0:
+            raise ValueError(f"Double free! {block} is already freed.")
+        block.ref_count -= 1
+        if block.ref_count == 0:
+            self.free_blocks.append(block)
+
+    def get_num_free_blocks(self) -> int:
+        return self.num_blocks - self.current_num_blocks + len(self.free_blocks)
+
+    def contains_block(self, block_hash: int) -> bool:
+        # Without caching, we never have cached blocks
+        return False
+
+    def update_hash(self, block_hash: int, block: PhysicalTokenBlock):
+        # Without caching, we don't need to update hashes
+        pass
+
+
+class PrefixCachingBlockAllocator:
+    """Manages free physical token blocks for a device with prefix caching.
 
     The allocator maintains a list of free blocks and allocates a block when
     requested. When a block is freed, its reference count is decremented. If
@@ -22,19 +77,14 @@ class BlockAllocator:
                  device: Device,
                  block_size: int,
                  num_blocks: int,
-                 eviction_policy: EvictionPolicy = EvictionPolicy.LRU,
-                 enable_caching: bool = False) -> None:
+                 eviction_policy: EvictionPolicy = EvictionPolicy.LRU) -> None:
         self.device = device
         self.block_size = block_size
         self.num_blocks = num_blocks
-        self.enable_caching = enable_caching
 
         self.current_num_blocks = 0
         self.cached_blocks: Dict[int, PhysicalTokenBlock] = {}
 
-        # Switch over to FIFO eviction when caching is disabled
-        if not self.enable_caching:
-            eviction_policy = EvictionPolicy.FIFO
         self.evictor: Evictor = make_evictor(eviction_policy)
 
         self.default_hash_ctr = count()
@@ -57,13 +107,6 @@ class BlockAllocator:
     def allocate(self,
                  block_hash: Optional[int] = None,
                  num_hashed_tokens: int = 0) -> PhysicalTokenBlock:
-        # If caching is disabled, just allocate a new block and return it
-        if not self.enable_caching:
-            block = self.allocate_block(next(self.default_hash_ctr),
-                                        num_hashed_tokens)
-            block.ref_count += 1
-            return block
-
         if block_hash is None:
             block_hash = next(self.default_hash_ctr)
         if block_hash in self.evictor:
@@ -89,10 +132,7 @@ class BlockAllocator:
         if block.ref_count == 0:
             assert block.block_hash not in self.evictor
             self.evictor.add(block)
-
-            # If caching is enabled, remove the block from the cached_blocks
-            if self.enable_caching:
-                del self.cached_blocks[block.block_hash]
+            del self.cached_blocks[block.block_hash]
 
     def get_num_free_blocks(self) -> int:
         return (self.num_blocks - self.current_num_blocks +
@@ -102,14 +142,28 @@ class BlockAllocator:
         return block_hash in self.cached_blocks or block_hash in self.evictor
 
     def update_hash(self, block_hash: int, block: PhysicalTokenBlock):
-        # If caching is enabled, update the hash of block and the
-        # cached_blocks dictionary.
-        if self.enable_caching:
-            assert not self.contains_block(block_hash)
-            old_hash = block.block_hash
-            block.block_hash = block_hash
-            del self.cached_blocks[old_hash]
-            self.cached_blocks[block_hash] = block
+        # Update the hash of block and the cached_blocks dictionary.
+        assert not self.contains_block(block_hash)
+        old_hash = block.block_hash
+        block.block_hash = block_hash
+        del self.cached_blocks[old_hash]
+        self.cached_blocks[block_hash] = block
+
+
+def BlockAllocator(device: Device,
+                   block_size: int,
+                   num_blocks: int,
+                   eviction_policy: EvictionPolicy = EvictionPolicy.LRU,
+                   enable_caching: bool = False):
+    """Factory function to create the appropriate block allocator.
+    
+    Returns UncachedBlockAllocator when caching is disabled for better performance,
+    or PrefixCachingBlockAllocator when caching is enabled.
+    """
+    if enable_caching:
+        return PrefixCachingBlockAllocator(device, block_size, num_blocks, eviction_policy)
+    else:
+        return UncachedBlockAllocator(device, block_size, num_blocks)
 
 
 class AllocStatus(enum.Enum):
diff --git a/vllm/core/evictor.py b/vllm/core/evictor.py
index 1d81f5a97..16ca8aff1 100644
--- a/vllm/core/evictor.py
+++ b/vllm/core/evictor.py
@@ -64,40 +64,22 @@ class LRUEvictor(Evictor):
     def __contains__(self, block_hash: int) -> bool:
         return block_hash in self.free_table
 
-    # TODO: The performance of this evict function can be optimized further.
     def evict(self) -> PhysicalTokenBlock:
-        free_blocks: List[PhysicalTokenBlock] = list(self.free_table.values())
-        if len(free_blocks) == 0:
+        if len(self.free_table) == 0:
             raise ValueError("No usable cache memory left")
 
-        # Find lowest timestamp
-        lowest_timestamp = free_blocks[0].last_accessed
-        for block in free_blocks:
-            if block.last_accessed < lowest_timestamp:
-                lowest_timestamp = block.last_accessed
-
-        # Find all blocks with the lowest timestamp
-        least_recent: List[PhysicalTokenBlock] = []
-        for block in free_blocks:
-            if block.last_accessed == lowest_timestamp:
-                least_recent.append(block)
-
-        # Find highest prefix count per block
-        highest_num_hashed_tokens = 0
-        for block in least_recent:
-            if block.num_hashed_tokens > highest_num_hashed_tokens:
-                highest_num_hashed_tokens = block.num_hashed_tokens
-
+        # Find the block with lowest timestamp and highest num_hashed_tokens in a single pass
         evicted_block: Optional[PhysicalTokenBlock] = None
-
-        # Find the first block with the lowest timestamp
-        for block in least_recent:
-            if block.num_hashed_tokens == highest_num_hashed_tokens:
+        for block in self.free_table.values():
+            if evicted_block is None:
+                evicted_block = block
+            elif block.last_accessed < evicted_block.last_accessed:
+                evicted_block = block
+            elif (block.last_accessed == evicted_block.last_accessed and
+                  block.num_hashed_tokens > evicted_block.num_hashed_tokens):
                 evicted_block = block
-                break
 
         assert evicted_block is not None
-
         del self.free_table[evicted_block.block_hash]
 
         evicted_block.computed = False
