{"instance_id": "/home/ubuntu/OmniPerf-Bench/vllm__repo-76b4944", "model_patch": "diff --git a/docs/design/v1/p2p_nccl_connector.md b/docs/design/v1/p2p_nccl_connector.md\nindex b1df93cfc..d4774b30f 100644\n--- a/docs/design/v1/p2p_nccl_connector.md\n+++ b/docs/design/v1/p2p_nccl_connector.md\n@@ -31,7 +31,7 @@ Each P/D instance periodically sends a heartbeat packet to the Proxy/Router (cur\n \n ## KV Cache Transfer Methods\n \n-There are three methods for KVcache transfer: PUT, GET, and PUT_ASYNC. These methods can be specified using the `--kv-transfer-config` and `kv_connector_extra_config` parameters, specifically through the `send_type` field. Both PUT and PUT_ASYNC involve the P instance actively sending KVcache to the D instance. The difference is that PUT is a synchronous transfer method that blocks the main process, while PUT_ASYNC is an asynchronous transfer method. PUT_ASYNC uses a dedicated thread for sending KVcache, which means it does not block the main process. In contrast, the GET method involves the P instance saving the KVcache to the memory buffer after computing the prefill. The D instance then actively retrieves the computed KVcache from the P instance once it has allocated space for the KVcache.\n+There are three methods for KVCache transfer: PUT, GET, and PUT_ASYNC. These methods can be specified using the `--kv-transfer-config` and `kv_connector_extra_config` parameters, specifically through the `send_type` field. Both PUT and PUT_ASYNC involve the P instance actively sending KVCache to the D instance. The difference is that PUT is a synchronous transfer method that blocks the main process, while PUT_ASYNC is an asynchronous transfer method. PUT_ASYNC uses a dedicated thread for sending KVCache, which means it does not block the main process. In contrast, the GET method involves the P instance saving the KVCache to the memory buffer after computing the prefill. The D instance then actively retrieves the computed KVCache from the P instance once it has allocated space for the KVCache.\n \n Experimental results have shown that the performance of these methods, from highest to lowest, is as follows: PUT_ASYNC \u2192 GET \u2192 PUT.\n \n@@ -39,13 +39,13 @@ Experimental results have shown that the performance of these methods, from high\n \n As long as the address of the counterpart is known, point-to-point KV cache transfer (using NCCL) can be performed, without being constrained by rank and world size. To support dynamic scaling (expansion and contraction) of instances with PD disaggregation. This means that adding or removing P/D instances does not require a full system restart.\n \n-Each P/D instance only needs to create a single `P2pNcclEngine` instance. This instance maintains a ZMQ Server, which runs a dedicated thread to listen on the `zmq_addr` address and receive control flow requests from other instances. These requests include requests to establish an NCCL connection and requests to send KVcache metadata (such as tensor shapes and data types). However, it does not actually transmit the KVcache data itself.\n+Each P/D instance only needs to create a single `P2pNcclEngine` instance. This instance maintains a ZMQ Server, which runs a dedicated thread to listen on the `zmq_addr` address and receive control flow requests from other instances. These requests include requests to establish an NCCL connection and requests to send KVCache metadata (such as tensor shapes and data types). However, it does not actually transmit the KVCache data itself.\n \n-When a P instance and a D instance transmit KVcache for the first time, they need to establish a ZMQ connection and an NCCL group. For subsequent KVcache transmissions, this ZMQ connection and NCCL group are reused. The NCCL group consists of only two ranks, meaning the world size is equal to 2. This design is intended to support dynamic scaling, which means that adding or removing P/D instances does not require a full system restart. As long as the address of the counterpart is known, point-to-point KVcache transmission can be performed, without being restricted by rank or world size.\n+When a P instance and a D instance transmit KVCache for the first time, they need to establish a ZMQ connection and an NCCL group. For subsequent KVCache transmissions, this ZMQ connection and NCCL group are reused. The NCCL group consists of only two ranks, meaning the world size is equal to 2. This design is intended to support dynamic scaling, which means that adding or removing P/D instances does not require a full system restart. As long as the address of the counterpart is known, point-to-point KVCache transmission can be performed, without being restricted by rank or world size.\n \n ## NCCL Group Topology\n \n-Currently, only symmetric TP (Tensor Parallelism) methods are supported for KVcache transmission. Asymmetric TP and PP (Pipeline Parallelism) methods will be supported in the future. Figure 2 illustrates the 1P2D setup, where each instance has a TP (Tensor Parallelism) degree of 2. There are a total of 7 NCCL groups: three vLLM instances each have one NCCL group with TP=2. Additionally, the 0th GPU card of the P instance establishes an NCCL group with the 0th GPU card of each D instance. Similarly, the 1st GPU card of the P instance establishes an NCCL group with the 1st GPU card of each D instance.\n+Currently, only symmetric TP (Tensor Parallelism) methods are supported for KVCache transmission. Asymmetric TP and PP (Pipeline Parallelism) methods will be supported in the future. Figure 2 illustrates the 1P2D setup, where each instance has a TP (Tensor Parallelism) degree of 2. There are a total of 7 NCCL groups: three vLLM instances each have one NCCL group with TP=2. Additionally, the 0th GPU card of the P instance establishes an NCCL group with the 0th GPU card of each D instance. Similarly, the 1st GPU card of the P instance establishes an NCCL group with the 1st GPU card of each D instance.\n \n ![image2](https://github.com/user-attachments/assets/837e61d6-365e-4cbf-8640-6dd7ab295b36)\n \n@@ -53,11 +53,11 @@ Each NCCL group occupies a certain amount of GPU memory buffer for communication\n \n ## GPU Memory Buffer and Tensor Memory Pool\n \n-The trade-off in the size of the memory buffer is as follows: For P instances, the memory buffer is not required in PUT and PUT_ASYNC modes, but it is necessary in GET mode. For D instances, a memory buffer is needed in all three modes. The memory buffer for D instances should not be too large. Similarly, for P instances in GET mode, the memory buffer should also not be too large. The memory buffer of D instances is used to temporarily store KVcache sent by P instances. If it is too large, it will reduce the KVcache space available for normal inference by D instances, thereby decreasing the inference batch size and ultimately leading to a reduction in output throughput. The size of the memory buffer is configured by the parameter `kv_buffer_size`, measured in bytes, and is typically set to 5%\uff5e10% of the memory size.\n+The trade-off in the size of the memory buffer is as follows: For P instances, the memory buffer is not required in PUT and PUT_ASYNC modes, but it is necessary in GET mode. For D instances, a memory buffer is needed in all three modes. The memory buffer for D instances should not be too large. Similarly, for P instances in GET mode, the memory buffer should also not be too large. The memory buffer of D instances is used to temporarily store KVCache sent by P instances. If it is too large, it will reduce the KVCache space available for normal inference by D instances, thereby decreasing the inference batch size and ultimately leading to a reduction in output throughput. The size of the memory buffer is configured by the parameter `kv_buffer_size`, measured in bytes, and is typically set to 5%\uff5e10% of the memory size.\n \n-If the `--max-num-seqs` parameter for P instances is set to a large value, due to the large batch size, P instances will generate a large amount of KVcache simultaneously. This may exceed the capacity of the memory buffer of D instances, resulting in KVcache loss. Once KVcache is lost, D instances need to recompute Prefill, which is equivalent to performing Prefill twice. Consequently, the time-to-first-token (TTFT) will significantly increase, leading to degraded performance.\n+If the `--max-num-seqs` parameter for P instances is set to a large value, due to the large batch size, P instances will generate a large amount of KVCache simultaneously. This may exceed the capacity of the memory buffer of D instances, resulting in KVCache loss. Once KVCache is lost, D instances need to recompute Prefill, which is equivalent to performing Prefill twice. Consequently, the time-to-first-token (TTFT) will significantly increase, leading to degraded performance.\n \n-To address the above issues, I have designed and developed a local Tensor memory pool for storing KVcache, inspired by the buddy system used in Linux memory modules. Since the memory is sufficiently large, typically in the TB range on servers, there is no need to consider prefix caching or using block-based designs to reuse memory, thereby saving space. When the memory buffer is insufficient, KVcache can be directly stored in the Tensor memory pool, and D instances can subsequently retrieve KVcache from it. The read and write speed is that of PCIe, with PCIe 4.0 having a speed of approximately 21 GB/s, which is usually faster than the Prefill speed. Otherwise, solutions like Mooncake and lmcache would not be necessary. The Tensor memory pool acts as a flood diversion area, typically unused except during sudden traffic surges. In the worst-case scenario, my solution performs no worse than the normal situation with a Cache store.\n+To address the above issues, I have designed and developed a local Tensor memory pool for storing KVCache, inspired by the buddy system used in Linux memory modules. Since the memory is sufficiently large, typically in the TB range on servers, there is no need to consider prefix caching or using block-based designs to reuse memory, thereby saving space. When the memory buffer is insufficient, KVCache can be directly stored in the Tensor memory pool, and D instances can subsequently retrieve KVCache from it. The read and write speed is that of PCIe, with PCIe 4.0 having a speed of approximately 21 GB/s, which is usually faster than the Prefill speed. Otherwise, solutions like Mooncake and lmcache would not be necessary. The Tensor memory pool acts as a flood diversion area, typically unused except during sudden traffic surges. In the worst-case scenario, my solution performs no worse than the normal situation with a Cache store.\n \n # Install vLLM\n \n@@ -85,8 +85,8 @@ To address the above issues, I have designed and developed a local Tensor memory\n \n ## Instructions\n - The following examples are run on an A800 (80GB) device, using the Meta-Llama-3.1-8B-Instruct model.\n-- Pay attention to the setting of the `kv_buffer_size` (in bytes). The empirical value is 10% of the GPU memory size. This is related to the kvcache size. If it is too small, the GPU memory buffer for temporarily storing the received kvcache will overflow, causing the kvcache to be stored in the tensor memory pool, which increases latency. If it is too large, the kvcache available for inference will be reduced, leading to a smaller batch size and decreased throughput.\n-- For Prefill instances, when using non-GET mode, the `kv_buffer_size` can be set to 1, as Prefill currently does not need to receive kvcache. However, when using GET mode, a larger `kv_buffer_size` is required because it needs to store the kvcache sent to the D instance.\n+- Pay attention to the setting of the `kv_buffer_size` (in bytes). The empirical value is 10% of the GPU memory size. This is related to the KVCache size. If it is too small, the GPU memory buffer for temporarily storing the received KVCache will overflow, causing the KVCache to be stored in the tensor memory pool, which increases latency. If it is too large, the KVCache available for inference will be reduced, leading to a smaller batch size and decreased throughput.\n+- For Prefill instances, when using non-GET mode, the `kv_buffer_size` can be set to 1, as Prefill currently does not need to receive KVCache. However, when using GET mode, a larger `kv_buffer_size` is required because it needs to store the KVCache sent to the D instance.\n - You may need to modify the `kv_buffer_size` and `port` in the following commands (if there is a conflict).\n - `PUT_ASYNC` offers the best performance and should be prioritized.\n - The `--port` must be consistent with the `http_port` in the `--kv-transfer-config`.\ndiff --git a/examples/online_serving/disaggregated_serving_p2p_nccl_xpyd/disagg_proxy_p2p_nccl_xpyd.py b/examples/online_serving/disaggregated_serving_p2p_nccl_xpyd/disagg_proxy_p2p_nccl_xpyd.py\nindex 4e82424d6..2dd6baa28 100644\n--- a/examples/online_serving/disaggregated_serving_p2p_nccl_xpyd/disagg_proxy_p2p_nccl_xpyd.py\n+++ b/examples/online_serving/disaggregated_serving_p2p_nccl_xpyd/disagg_proxy_p2p_nccl_xpyd.py\n@@ -20,6 +20,8 @@ decode_cv = threading.Condition()\n \n \n def _listen_for_register(poller, router_socket):\n+    global prefill_instances, prefill_cv, decode_instances, decode_cv\n+    \n     while True:\n         socks = dict(poller.poll())\n         if router_socket in socks:\n@@ -27,14 +29,12 @@ def _listen_for_register(poller, router_socket):\n             # data: {\"type\": \"P\", \"http_address\": \"ip:port\",\n             #        \"zmq_address\": \"ip:port\"}\n             data = msgpack.loads(message)\n-            if data[\"type\"] == \"P\":\n-                global prefill_instances\n-                global prefill_cv\n+            instance_type = data.get(\"type\")\n+            \n+            if instance_type == \"P\":\n                 with prefill_cv:\n                     prefill_instances[data[\"http_address\"]] = data[\"zmq_address\"]\n-            elif data[\"type\"] == \"D\":\n-                global decode_instances\n-                global decode_cv\n+            elif instance_type == \"D\":\n                 with decode_cv:\n                     decode_instances[data[\"http_address\"]] = data[\"zmq_address\"]\n             else:\n@@ -92,6 +92,8 @@ async def forward_request(url, data, request_id):\n \n @app.route(\"/v1/completions\", methods=[\"POST\"])\n async def handle_request():\n+    global count, prefill_instances, prefill_cv, decode_instances, decode_cv\n+    \n     try:\n         original_request_data = await request.get_json()\n \n@@ -99,15 +101,10 @@ async def handle_request():\n         # change max_tokens = 1 to let it only do prefill\n         prefill_request[\"max_tokens\"] = 1\n \n-        global count\n-        global prefill_instances\n-        global prefill_cv\n         with prefill_cv:\n             prefill_list = list(prefill_instances.items())\n             prefill_addr, prefill_zmq_addr = prefill_list[count % len(prefill_list)]\n \n-        global decode_instances\n-        global decode_cv\n         with decode_cv:\n             decode_list = list(decode_instances.items())\n             decode_addr, decode_zmq_addr = decode_list[count % len(decode_list)]\ndiff --git a/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_connector.py b/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_connector.py\nindex 52f589a6d..436272ec5 100644\n--- a/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_connector.py\n+++ b/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_connector.py\n@@ -194,11 +194,11 @@ class P2pNcclConnector(KVConnectorBase_V1):\n         for request in metadata.requests:\n             for layer_name in forward_context.no_compile_layers:\n                 attn_layer = forward_context.no_compile_layers[layer_name]\n-                kv_cache_layer = attn_layer.kv_cache[ \\\n+                kv_cache_layer = attn_layer.kv_cache[\n                     forward_context.virtual_engine]\n \n-                kv_cache = self.p2p_nccl_engine.recv_tensor(\n-                    request.request_id + \"#\" + layer_name)\n+                tensor_id = f\"{request.request_id}#{layer_name}\"\n+                kv_cache = self.p2p_nccl_engine.recv_tensor(tensor_id)\n \n                 if kv_cache is None:\n                     logger.warning(\"\ud83d\udea7src_kv_cache is None, %s\",\n@@ -260,10 +260,11 @@ class P2pNcclConnector(KVConnectorBase_V1):\n         for request in connector_metadata.requests:\n             request_id = request.request_id\n             ip, port = self.parse_request_id(request_id, True)\n-            remote_address = ip + \":\" + str(port + self._rank)\n+            remote_address = f\"{ip}:{port + self._rank}\"\n             kv_cache = extract_kv_from_layer(kv_layer, request.slot_mapping)\n-            self.p2p_nccl_engine.send_tensor(request_id + \"#\" + layer_name,\n-                                             kv_cache, remote_address)\n+            tensor_id = f\"{request_id}#{layer_name}\"\n+            self.p2p_nccl_engine.send_tensor(tensor_id, kv_cache,\n+                                             remote_address)\n \n     def wait_for_save(self):\n         if self.is_producer:\ndiff --git a/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_engine.py b/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_engine.py\nindex 6c9ccb2e3..d12a08908 100644\n--- a/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_engine.py\n+++ b/vllm/distributed/kv_transfer/kv_connector/v1/p2p/p2p_nccl_engine.py\n@@ -93,10 +93,10 @@ class P2pNcclEngine:\n         # then the ping thread will not be enabled.\n         proxy_ip = self.config.get_from_extra_config(\"proxy_ip\", \"\")\n         proxy_port = self.config.get_from_extra_config(\"proxy_port\", \"\")\n-        if proxy_ip == \"\" or proxy_port == \"\":\n-            self.proxy_address = \"\"\n+        if proxy_ip and proxy_port:\n+            self.proxy_address = f\"{proxy_ip}:{proxy_port}\"\n         else:\n-            self.proxy_address = proxy_ip + \":\" + proxy_port\n+            self.proxy_address = \"\"\n \n         self.context = zmq.Context()\n         self.router_socket = self.context.socket(zmq.ROUTER)\n@@ -377,16 +377,14 @@ class P2pNcclEngine:\n                         remote_address, data)\n \n     def _have_sent_tensor_id(self, tensor_id: str):\n-        request_id = tensor_id.split('#')[0]\n-        if request_id not in self.send_request_id_to_tensor_ids:\n-            self.send_request_id_to_tensor_ids[request_id] = set()\n-        self.send_request_id_to_tensor_ids[request_id].add(tensor_id)\n+        request_id = tensor_id.split('#', 1)[0]\n+        self.send_request_id_to_tensor_ids.setdefault(request_id,\n+                                                       set()).add(tensor_id)\n \n     def _have_received_tensor_id(self, tensor_id: str):\n-        request_id = tensor_id.split('#')[0]\n-        if request_id not in self.recv_request_id_to_tensor_ids:\n-            self.recv_request_id_to_tensor_ids[request_id] = set()\n-        self.recv_request_id_to_tensor_ids[request_id].add(tensor_id)\n+        request_id = tensor_id.split('#', 1)[0]\n+        self.recv_request_id_to_tensor_ids.setdefault(request_id,\n+                                                       set()).add(tensor_id)\n \n     def _send_async(self):\n         while True:\n@@ -464,7 +462,7 @@ class P2pNcclEngine:\n         # Clear the buffer upon request completion.\n         for request_id in finished_req_ids:\n             for layer_name in forward_context.no_compile_layers:\n-                tensor_id = request_id + \"#\" + layer_name\n+                tensor_id = f\"{request_id}#{layer_name}\"\n                 if tensor_id in self.recv_store:\n                     with self.recv_store_cv:\n                         tensor = self.recv_store.pop(tensor_id, None)\n@@ -472,7 +470,6 @@ class P2pNcclEngine:\n                             request_id, None)\n                         self.recv_request_id_to_tensor_ids.pop(\n                             request_id, None)\n-                    addr = 0\n                     if isinstance(tensor, tuple):\n                         addr, _, _ = tensor\n                         self.pool.free(addr)\n", "model_name_or_path": "gpt-5-2025-08-07"}
