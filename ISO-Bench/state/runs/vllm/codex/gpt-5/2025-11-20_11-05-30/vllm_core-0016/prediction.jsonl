{"instance_id": "/home/ubuntu/OmniPerf-Bench/vllm__repo-a732900", "model_patch": "diff --git a/vllm/distributed/device_communicators/pynccl.py b/vllm/distributed/device_communicators/pynccl.py\nindex fda4d007c..71ecb8737 100644\n--- a/vllm/distributed/device_communicators/pynccl.py\n+++ b/vllm/distributed/device_communicators/pynccl.py\n@@ -10,6 +10,7 @@ from vllm.distributed.device_communicators.pynccl_wrapper import (\n     ncclRedOpTypeEnum, ncclUniqueId)\n from vllm.distributed.utils import StatelessProcessGroup\n from vllm.logger import init_logger\n+from vllm.utils import current_stream\n \n logger = init_logger(__name__)\n \n@@ -96,9 +97,9 @@ class PyNcclCommunicator:\n             self.comm: ncclComm_t = self.nccl.ncclCommInitRank(\n                 self.world_size, self.unique_id, self.rank)\n \n-            stream = torch.cuda.current_stream()\n+            stream = current_stream()\n             # A small all_reduce for warmup.\n-            data = torch.zeros(1, device=device)\n+            data = torch.empty(1, device=device)\n             self.all_reduce(data)\n             stream.synchronize()\n             del data\n@@ -119,7 +120,7 @@ class PyNcclCommunicator:\n         out_tensor = torch.empty_like(in_tensor)\n \n         if stream is None:\n-            stream = torch.cuda.current_stream()\n+            stream = current_stream()\n         self.nccl.ncclAllReduce(buffer_type(in_tensor.data_ptr()),\n                                 buffer_type(out_tensor.data_ptr()),\n                                 in_tensor.numel(),\n@@ -141,7 +142,7 @@ class PyNcclCommunicator:\n             f\"this nccl communicator is created to work on {self.device}, \"\n             f\"but the input tensor is on {input_tensor.device}\")\n         if stream is None:\n-            stream = torch.cuda.current_stream()\n+            stream = current_stream()\n         self.nccl.ncclAllGather(\n             buffer_type(input_tensor.data_ptr()),\n             buffer_type(output_tensor.data_ptr()), input_tensor.numel(),\n@@ -162,7 +163,7 @@ class PyNcclCommunicator:\n             f\"this nccl communicator is created to work on {self.device}, \"\n             f\"but the input tensor is on {input_tensor.device}\")\n         if stream is None:\n-            stream = torch.cuda.current_stream()\n+            stream = current_stream()\n         self.nccl.ncclReduceScatter(\n             buffer_type(input_tensor.data_ptr()),\n             buffer_type(output_tensor.data_ptr()), output_tensor.numel(),\n@@ -177,7 +178,7 @@ class PyNcclCommunicator:\n             f\"this nccl communicator is created to work on {self.device}, \"\n             f\"but the input tensor is on {tensor.device}\")\n         if stream is None:\n-            stream = torch.cuda.current_stream()\n+            stream = current_stream()\n         self.nccl.ncclSend(buffer_type(tensor.data_ptr()), tensor.numel(),\n                            ncclDataTypeEnum.from_torch(tensor.dtype), dst,\n                            self.comm, cudaStream_t(stream.cuda_stream))\n@@ -189,7 +190,7 @@ class PyNcclCommunicator:\n             f\"this nccl communicator is created to work on {self.device}, \"\n             f\"but the input tensor is on {tensor.device}\")\n         if stream is None:\n-            stream = torch.cuda.current_stream()\n+            stream = current_stream()\n         self.nccl.ncclRecv(buffer_type(tensor.data_ptr()), tensor.numel(),\n                            ncclDataTypeEnum.from_torch(tensor.dtype), src,\n                            self.comm, cudaStream_t(stream.cuda_stream))\ndiff --git a/vllm/distributed/parallel_state.py b/vllm/distributed/parallel_state.py\nindex a837c1dc5..9ac49ce97 100644\n--- a/vllm/distributed/parallel_state.py\n+++ b/vllm/distributed/parallel_state.py\n@@ -39,7 +39,8 @@ import vllm.distributed.kv_transfer.kv_transfer_agent as kv_transfer\n import vllm.envs as envs\n from vllm.distributed.utils import StatelessProcessGroup\n from vllm.logger import init_logger\n-from vllm.utils import direct_register_custom_op, supports_custom_op\n+from vllm.utils import (direct_register_custom_op, supports_custom_op,\n+                        current_stream)\n \n if TYPE_CHECKING:\n     from vllm.config import VllmConfig\n@@ -359,8 +360,7 @@ class GroupCoordinator:\n         assert pynccl_comm is not None\n         # TODO: pynccl should not use `stream=`\n         # it can just always use the current stream.\n-        out = pynccl_comm.all_reduce(input_,\n-                                     stream=torch.cuda.current_stream())\n+        out = pynccl_comm.all_reduce(input_, stream=current_stream())\n         if out is None:\n             # fall back to the default all-reduce using PyTorch.\n             # this usually happens during testing.\ndiff --git a/vllm/utils.py b/vllm/utils.py\nindex a92b77efd..f32742795 100644\n--- a/vllm/utils.py\n+++ b/vllm/utils.py\n@@ -1097,6 +1097,48 @@ def cuda_is_initialized() -> bool:\n     return torch.cuda.is_initialized()\n \n \n+def current_stream(device: Optional[torch.device] = None):\n+    \"\"\"Return the current device stream for the active platform.\n+\n+    - On CUDA/ROCm, returns ``torch.cuda.current_stream([device])``.\n+    - On XPU, returns ``torch.xpu.current_stream([device])`` if available.\n+    - On HPU, returns ``torch.hpu.current_stream()`` if available.\n+\n+    This utility centralizes stream selection and avoids hard-coding CUDA\n+    stream retrieval in distributed/device-level code paths.\n+    \"\"\"\n+    from vllm.platforms import current_platform\n+\n+    # CUDA-like backends (CUDA/ROCm)\n+    if current_platform.is_cuda_alike():\n+        return (torch.cuda.current_stream(device)\n+                if device is not None else torch.cuda.current_stream())\n+\n+    # Intel XPU backend\n+    if hasattr(torch, \"xpu\") and current_platform.is_xpu():\n+        try:\n+            return (torch.xpu.current_stream(device)  # type: ignore[attr-defined]\n+                    if device is not None else torch.xpu.current_stream())\n+        except Exception:\n+            # Fall through to a best-effort default\n+            pass\n+\n+    # Habana HPU backend\n+    if hasattr(torch, \"hpu\") and current_platform.is_hpu():\n+        try:\n+            return torch.hpu.current_stream()  # type: ignore[attr-defined]\n+        except Exception:\n+            pass\n+\n+    # Fallback: if CUDA is compiled, return its current stream. This should\n+    # not be hit for CPU-only paths that don't use streams.\n+    if torch.cuda._is_compiled():\n+        return torch.cuda.current_stream()\n+\n+    raise RuntimeError(\n+        \"current_stream() called but no supported device stream backend is available\")\n+\n+\n def weak_bind(bound_method: Callable[..., Any], ) -> Callable[..., None]:\n     \"\"\"Make an instance method that weakly references\n     its associated instance and no-ops once that\ndiff --git a/vllm/worker/multi_step_model_runner.py b/vllm/worker/multi_step_model_runner.py\nindex a2c2cebf8..45ede2341 100644\n--- a/vllm/worker/multi_step_model_runner.py\n+++ b/vllm/worker/multi_step_model_runner.py\n@@ -14,7 +14,7 @@ from vllm.model_executor.layers.sampler import (PromptLogprobs, SampleLogprobs,\n                                                 get_pythonized_sample_results)\n from vllm.sequence import (CompletionSequenceGroupOutput, IntermediateTensors,\n                            Logprob, SequenceGroupMetadata, SequenceOutput)\n-from vllm.utils import PyObjectCache, async_tensor_h2d\n+from vllm.utils import PyObjectCache, async_tensor_h2d, current_stream as _current_stream\n from vllm.worker.model_runner import (GPUModelRunnerBase,\n                                       ModelInputForGPUWithSamplingMetadata)\n from vllm.worker.model_runner_base import (\n@@ -480,7 +480,7 @@ class MultiStepModelRunner(GPUModelRunnerBase[StatefulModelInput]):\n         # if CPU is ahead.\n         if self.is_driver_worker and get_pp_group().is_last_rank:\n             if self.pinned_sampled_token_ids is None:\n-                self.pinned_sampled_token_ids = torch.zeros(\n+                self.pinned_sampled_token_ids = torch.empty(\n                     (self.scheduler_config.max_num_seqs, 1),\n                     dtype=torch.long,\n                     device=\"cpu\",\n@@ -498,7 +498,7 @@ class MultiStepModelRunner(GPUModelRunnerBase[StatefulModelInput]):\n         #   appended sampler output from last iteration\n         #   - also maybe pythonize if CPU is ahead of GPU\n \n-        current_stream = torch.cuda.current_stream()\n+        cur_stream = _current_stream()\n         if not model_input.is_first_multi_step:\n             # Explicitly block on the previous step's forward to make sure we\n             # don't clobber any GPU tensors still in use.\n@@ -541,7 +541,7 @@ class MultiStepModelRunner(GPUModelRunnerBase[StatefulModelInput]):\n                                                        num_steps=1)\n \n         # record the event for the current step so that the next step can sync\n-        model_input.record_step_event(current_stream)\n+        model_input.record_step_event(cur_stream)\n \n         if get_pp_group().is_last_rank and self.is_driver_worker:\n             assert isinstance(output, list)\n@@ -552,7 +552,7 @@ class MultiStepModelRunner(GPUModelRunnerBase[StatefulModelInput]):\n             # event for the pythonization so that we only pythonize if the\n             # tensors are ready. May be able to be combined with the step event\n             output_ready_event = torch.cuda.Event()\n-            output_ready_event.record(current_stream)\n+            output_ready_event.record(cur_stream)\n             if self.parallel_config.pipeline_parallel_size > 1:\n                 output[0].sampled_token_ids_cpu = output[\n                     0].sampled_token_ids.cpu()\n", "model_name_or_path": "gpt-5-2025-08-07"}
