{"instance_id": "/home/ubuntu/OmniPerf-Bench/vllm__repo-edc4fa3", "model_patch": "diff --git a/csrc/cache_kernels.cu b/csrc/cache_kernels.cu\nindex 1be806bbf..afea92940 100644\n--- a/csrc/cache_kernels.cu\n+++ b/csrc/cache_kernels.cu\n@@ -267,10 +267,14 @@ void reshape_and_cache(\n         key_cache,  // [num_blocks, num_heads, head_size/x, block_size, x]\n     torch::Tensor&\n         value_cache,  // [num_blocks, num_heads, head_size, block_size]\n-    torch::Tensor& slot_mapping,  // [num_tokens]\n+    torch::Tensor& slot_mapping,  // [num_tokens] or [num_actual_tokens]\n     const std::string& kv_cache_dtype, const double k_scale,\n     const double v_scale) {\n-  int num_tokens = key.size(0);\n+  // In vLLM V1, key.size(0) can differ from slot_mapping.size(0) due to\n+  // padding for CUDA graphs. The slot_mapping length represents the actual\n+  // number of tokens before padding. For compatibility with both padded and\n+  // non-padded cases, use slot_mapping.size(0) as the number of tokens.\n+  int num_tokens = slot_mapping.size(0);\n   int num_heads = key.size(1);\n   int head_size = key.size(2);\n   int block_size = key_cache.size(3);\n@@ -307,10 +311,20 @@ void reshape_and_cache_flash(\n     torch::Tensor& key_cache,  // [num_blocks, block_size, num_heads, head_size]\n     torch::Tensor&\n         value_cache,  // [num_blocks, block_size, num_heads, head_size]\n-    torch::Tensor& slot_mapping,  // [num_tokens]\n+    torch::Tensor& slot_mapping,  // [num_tokens] or [num_actual_tokens]\n     const std::string& kv_cache_dtype, const double k_scale,\n     const double v_scale) {\n-  int num_tokens = key.size(0);\n+  // NOTE(woosuk): In vLLM V1, key.size(0) can be different from\n+  // slot_mapping.size(0) because of padding for CUDA graphs.\n+  // In vLLM V0, key.size(0) is always equal to slot_mapping.size(0) because\n+  // both include padding.\n+  // In vLLM V1, however, key.size(0) can be larger than slot_mapping.size(0)\n+  // since key includes padding for CUDA graphs, while slot_mapping does not.\n+  // In this case, slot_mapping.size(0) represents the actual number of tokens\n+  // before padding.\n+  // For compatibility with both cases, we use slot_mapping.size(0) as the\n+  // number of tokens.\n+  int num_tokens = slot_mapping.size(0);\n   int num_heads = key.size(1);\n   int head_size = key.size(2);\n   int block_size = key_cache.size(1);\ndiff --git a/vllm/v1/attention/backends/flash_attn.py b/vllm/v1/attention/backends/flash_attn.py\nindex d37989055..40877e166 100644\n--- a/vllm/v1/attention/backends/flash_attn.py\n+++ b/vllm/v1/attention/backends/flash_attn.py\n@@ -141,11 +141,13 @@ class FlashAttentionImpl(AttentionImpl):\n         num_actual_tokens = attn_metadata.num_actual_tokens\n \n         # Reshape the input keys and values and store them in the cache.\n+        # Avoid slicing key/value on CPU; the kernel uses slot_mapping.size(0)\n+        # to determine the actual number of tokens to process.\n         key_cache = kv_cache[0]\n         value_cache = kv_cache[1]\n         torch.ops._C_cache_ops.reshape_and_cache_flash(\n-            key[:num_actual_tokens],\n-            value[:num_actual_tokens],\n+            key,\n+            value,\n             key_cache,\n             value_cache,\n             attn_metadata.slot_mapping,\n", "model_name_or_path": "gpt-5-2025-08-07"}
