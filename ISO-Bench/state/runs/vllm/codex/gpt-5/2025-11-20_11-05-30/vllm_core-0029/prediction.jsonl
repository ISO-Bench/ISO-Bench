{"instance_id": "/home/ubuntu/OmniPerf-Bench/vllm__repo-8d59dbb", "model_patch": "diff --git a/vllm/core/evictor_v2.py b/vllm/core/evictor_v2.py\nindex 3dd12e2e2..b76bed527 100644\n--- a/vllm/core/evictor_v2.py\n+++ b/vllm/core/evictor_v2.py\n@@ -60,6 +60,8 @@ class BlockMetaData():\n     blocks with the same content hash, but their physical id is unique.\n     \"\"\"\n \n+    __slots__ = (\"content_hash\", \"num_hashed_tokens\", \"last_accessed\")\n+\n     def __init__(self, content_hash: int, num_hashed_tokens: int,\n                  last_accessed: float):\n         self.content_hash = content_hash\n@@ -85,15 +87,21 @@ class LRUEvictor(Evictor):\n         if len(self.free_table) == 0:\n             raise ValueError(\"No usable cache memory left\")\n \n-        evicted_block = next(iter(self.free_table.values()))\n-        evicted_block_id = next(iter(self.free_table.keys()))\n+        # Start with the first (oldest) block. Items with the same\n+        # last_accessed are grouped at the front thanks to update()\n+        # moving recently used blocks to the end.\n+        evicted_block_id, evicted_block = next(iter(self.free_table.items()))\n         # The blocks with the lowest timestamps should be placed consecutively\n         # at the start of OrderedDict. Loop through all these blocks to\n         # find the one with maximum number of hashed tokens.\n+        min_last = evicted_block.last_accessed\n         for _id, block in self.free_table.items():\n-            if evicted_block.last_accessed > block.last_accessed or (\n-                    evicted_block.last_accessed == block.last_accessed and\n-                    evicted_block.num_hashed_tokens < block.num_hashed_tokens):\n+            # Stop once we reach blocks that are more recently accessed.\n+            if block.last_accessed > min_last:\n+                break\n+            # Among equally old blocks, pick the one with most hashed tokens.\n+            if (block.last_accessed == min_last\n+                    and evicted_block.num_hashed_tokens < block.num_hashed_tokens):\n                 evicted_block = block\n                 evicted_block_id = _id\n \n@@ -108,13 +116,19 @@ class LRUEvictor(Evictor):\n                                                   last_accessed)\n \n     def update(self, block_id: int, last_accessed: float):\n-        self.free_table[block_id].last_accessed = last_accessed\n+        block = self.free_table[block_id]\n+        # Only move if the block becomes more recent; this keeps the\n+        # OrderedDict grouped by ascending last_accessed and avoids\n+        # unnecessary churn.\n+        if last_accessed > block.last_accessed:\n+            block.last_accessed = last_accessed\n+            self.free_table.move_to_end(block_id)\n \n     def remove(self, block_id: int):\n         if block_id not in self.free_table:\n             raise ValueError(\n                 \"Attempting to remove block that's not in the evictor\")\n-        self.free_table.pop(block_id)\n+        del self.free_table[block_id]\n \n     @property\n     def num_blocks(self) -> int:\n", "model_name_or_path": "gpt-5-2025-08-07"}
