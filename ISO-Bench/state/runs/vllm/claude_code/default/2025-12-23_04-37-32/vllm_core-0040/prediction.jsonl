{"instance_id": "vllm-project__vllm-6d917d0", "model_patch": "diff --git a/vllm/core/evictor.py b/vllm/core/evictor.py\nindex ed7e06cab..27d0597ab 100644\n--- a/vllm/core/evictor.py\n+++ b/vllm/core/evictor.py\n@@ -59,6 +59,7 @@ class BlockMetaData:\n     Here we use physical block id as the dict key, as there maybe several\n     blocks with the same content hash, but their physical id is unique.\n     \"\"\"\n+    __slots__ = ('content_hash', 'num_hashed_tokens', 'last_accessed')\n \n     def __init__(self, content_hash: int, num_hashed_tokens: int,\n                  last_accessed: float):\n@@ -82,26 +83,37 @@ class LRUEvictor(Evictor):\n         return block_id in self.free_table\n \n     def evict(self) -> Tuple[int, int]:\n-        if len(self.free_table) == 0:\n+        if not self.free_table:\n             raise ValueError(\"No usable cache memory left\")\n \n-        evicted_block, evicted_block_id = None, None\n         # The blocks with the lowest timestamps should be placed consecutively\n         # at the start of OrderedDict. Loop through all these blocks to\n         # find the one with maximum number of hashed tokens.\n-        for _id, block in self.free_table.items():\n-            if evicted_block is None:\n-                evicted_block, evicted_block_id = block, _id\n-                continue\n-            if evicted_block.last_accessed < block.last_accessed:\n+        free_table_iter = iter(self.free_table.items())\n+        evicted_block_id, evicted_block = next(free_table_iter)\n+        min_last_accessed = evicted_block.last_accessed\n+        max_hashed_tokens = evicted_block.num_hashed_tokens\n+\n+        for _id, block in free_table_iter:\n+            block_last_accessed = block.last_accessed\n+            if block_last_accessed < min_last_accessed:\n+                # Found a block with earlier access time\n+                min_last_accessed = block_last_accessed\n+                max_hashed_tokens = block.num_hashed_tokens\n+                evicted_block_id = _id\n+                evicted_block = block\n+            elif block_last_accessed == min_last_accessed:\n+                # Same access time, check for more hashed tokens\n+                block_num_hashed = block.num_hashed_tokens\n+                if block_num_hashed > max_hashed_tokens:\n+                    max_hashed_tokens = block_num_hashed\n+                    evicted_block_id = _id\n+                    evicted_block = block\n+            else:\n+                # Access time is later, stop searching\n                 break\n-            if evicted_block.num_hashed_tokens < block.num_hashed_tokens:\n-                evicted_block, evicted_block_id = block, _id\n \n-        assert evicted_block is not None\n-        assert evicted_block_id is not None\n         self.free_table.pop(evicted_block_id)\n-\n         return evicted_block_id, evicted_block.content_hash\n \n     def add(self, block_id: int, content_hash: int, num_hashed_tokens: int,\n@@ -111,13 +123,15 @@ class LRUEvictor(Evictor):\n                                                   last_accessed)\n \n     def update(self, block_id: int, last_accessed: float):\n-        self.free_table[block_id].last_accessed = last_accessed\n+        block = self.free_table[block_id]\n+        block.last_accessed = last_accessed\n \n     def remove(self, block_id: int):\n-        if block_id not in self.free_table:\n+        try:\n+            self.free_table.pop(block_id)\n+        except KeyError:\n             raise ValueError(\n                 \"Attempting to remove block that's not in the evictor\")\n-        self.free_table.pop(block_id)\n \n     @property\n     def num_blocks(self) -> int:\n", "model_name_or_path": "gpt-5-2025-08-07"}
