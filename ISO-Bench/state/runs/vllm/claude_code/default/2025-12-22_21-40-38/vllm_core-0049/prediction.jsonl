{"instance_id": "vllm-project__vllm-20478c4", "model_patch": "diff --git a/vllm/core/block_manager.py b/vllm/core/block_manager.py\nindex 8b089a565..df771d22f 100644\n--- a/vllm/core/block_manager.py\n+++ b/vllm/core/block_manager.py\n@@ -66,19 +66,24 @@ class BlockAllocator:\n \n         if block_hash is None:\n             block_hash = next(self.default_hash_ctr)\n+\n+        # Check cached_blocks first (most common case)\n+        block = self.cached_blocks.get(block_hash)\n+        if block is not None:\n+            block.ref_count += 1\n+            return block\n+\n+        # Check evictor next\n         if block_hash in self.evictor:\n-            assert block_hash not in self.cached_blocks\n             block = self.evictor.remove(block_hash)\n             assert block.ref_count == 0\n             self.cached_blocks[block_hash] = block\n             block.ref_count += 1\n-            assert block.block_hash == block_hash\n             return block\n-        if block_hash not in self.cached_blocks:\n-            self.cached_blocks[block_hash] = self.allocate_block(\n-                block_hash, num_hashed_tokens)\n-        block = self.cached_blocks[block_hash]\n-        assert block.block_hash == block_hash\n+\n+        # Allocate new block\n+        block = self.allocate_block(block_hash, num_hashed_tokens)\n+        self.cached_blocks[block_hash] = block\n         block.ref_count += 1\n         return block\n \n@@ -315,21 +320,26 @@ class BlockSpaceManager:\n         # When using a sliding window, blocks will be eventually reused.\n         # In this case the block tables will contain repeated blocks.\n         # When forking, we must make sure that each block's `ref_count`\n-        # is only incremented by one, so we deduplicate them by wrapping\n-        # them in a set.\n-        for block in set(src_block_table):\n-            block.ref_count += 1\n+        # is only incremented by one, so we deduplicate them using a dict\n+        # for O(1) lookups instead of creating a set.\n+        seen_blocks = {}\n+        for block in src_block_table:\n+            if block.block_number not in seen_blocks:\n+                seen_blocks[block.block_number] = block\n+                block.ref_count += 1\n \n     def _get_physical_blocks(\n             self, seq_group: SequenceGroup) -> List[PhysicalTokenBlock]:\n         # NOTE: Here, we assume that the physical blocks are only shared by\n         # the sequences in the same group.\n-        blocks: Set[PhysicalTokenBlock] = set()\n+        # Use dict for O(1) deduplication instead of set\n+        blocks_dict: Dict[int, PhysicalTokenBlock] = {}\n         for seq in seq_group.get_seqs():\n             if seq.is_finished():\n                 continue\n-            blocks.update(self.block_tables[seq.seq_id])\n-        return list(blocks)\n+            for block in self.block_tables[seq.seq_id]:\n+                blocks_dict[block.block_number] = block\n+        return list(blocks_dict.values())\n \n     def can_swap_in(self, seq_group: SequenceGroup) -> bool:\n         blocks = self._get_physical_blocks(seq_group)\n@@ -406,11 +416,15 @@ class BlockSpaceManager:\n         blocks_to_free = (block_table[-self.block_sliding_window:]\n                           if self.block_sliding_window is not None else\n                           block_table)\n-        for block in set(blocks_to_free):\n-            if block.device == Device.GPU:\n-                self.gpu_allocator.free(block)\n-            else:\n-                self.cpu_allocator.free(block)\n+        # Use dict for deduplication to avoid set creation\n+        seen_blocks: Dict[int, PhysicalTokenBlock] = {}\n+        for block in blocks_to_free:\n+            if block.block_number not in seen_blocks:\n+                seen_blocks[block.block_number] = block\n+                if block.device == Device.GPU:\n+                    self.gpu_allocator.free(block)\n+                else:\n+                    self.cpu_allocator.free(block)\n \n     def free(self, seq: Sequence) -> None:\n         if seq.seq_id not in self.block_tables:\ndiff --git a/vllm/core/evictor.py b/vllm/core/evictor.py\nindex 1d81f5a97..5aaa1a0c4 100644\n--- a/vllm/core/evictor.py\n+++ b/vllm/core/evictor.py\n@@ -64,37 +64,27 @@ class LRUEvictor(Evictor):\n     def __contains__(self, block_hash: int) -> bool:\n         return block_hash in self.free_table\n \n-    # TODO: The performance of this evict function can be optimized further.\n     def evict(self) -> PhysicalTokenBlock:\n-        free_blocks: List[PhysicalTokenBlock] = list(self.free_table.values())\n-        if len(free_blocks) == 0:\n+        if len(self.free_table) == 0:\n             raise ValueError(\"No usable cache memory left\")\n \n-        # Find lowest timestamp\n-        lowest_timestamp = free_blocks[0].last_accessed\n-        for block in free_blocks:\n+        # Single pass optimization: find the block with lowest timestamp\n+        # and highest num_hashed_tokens in one iteration\n+        evicted_block: Optional[PhysicalTokenBlock] = None\n+        lowest_timestamp = float('inf')\n+        highest_num_hashed_tokens = -1\n+\n+        for block in self.free_table.values():\n+            # Prioritize by timestamp first (lower is better)\n             if block.last_accessed < lowest_timestamp:\n                 lowest_timestamp = block.last_accessed\n-\n-        # Find all blocks with the lowest timestamp\n-        least_recent: List[PhysicalTokenBlock] = []\n-        for block in free_blocks:\n-            if block.last_accessed == lowest_timestamp:\n-                least_recent.append(block)\n-\n-        # Find highest prefix count per block\n-        highest_num_hashed_tokens = 0\n-        for block in least_recent:\n-            if block.num_hashed_tokens > highest_num_hashed_tokens:\n                 highest_num_hashed_tokens = block.num_hashed_tokens\n-\n-        evicted_block: Optional[PhysicalTokenBlock] = None\n-\n-        # Find the first block with the lowest timestamp\n-        for block in least_recent:\n-            if block.num_hashed_tokens == highest_num_hashed_tokens:\n                 evicted_block = block\n-                break\n+            # If timestamps equal, prioritize by num_hashed_tokens (higher is better)\n+            elif block.last_accessed == lowest_timestamp:\n+                if block.num_hashed_tokens > highest_num_hashed_tokens:\n+                    highest_num_hashed_tokens = block.num_hashed_tokens\n+                    evicted_block = block\n \n         assert evicted_block is not None\n \n", "model_name_or_path": "gpt-5-2025-08-07"}
