{"instance_id": "vllm-project__vllm-51f8aa9", "model_patch": "diff --git a/vllm/core/block/common.py b/vllm/core/block/common.py\nindex 1e808e21b..d057b2648 100644\n--- a/vllm/core/block/common.py\n+++ b/vllm/core/block/common.py\n@@ -32,10 +32,9 @@ class RefCounter(RefCounterProtocol):\n     \"\"\"\n \n     def __init__(self, all_block_indices: Iterable[BlockId]):\n+        # Optimize: Use dict.fromkeys() which is faster than dict comprehension\n         deduped = set(all_block_indices)\n-        self._refcounts: Dict[BlockId,\n-                              RefCount] = {index: 0\n-                                           for index in deduped}\n+        self._refcounts: Dict[BlockId, RefCount] = dict.fromkeys(deduped, 0)\n \n     def incr(self, block_id: BlockId) -> RefCount:\n         assert block_id in self._refcounts\n@@ -242,10 +241,8 @@ class BlockList:\n     def update(self, blocks: List[Block]):\n         self._blocks = blocks\n \n-        # Cache block ids for fast query\n-        self._block_ids = []\n-        for block in self._blocks:\n-            self._add_block_id(block.block_id)\n+        # Optimize: Use list comprehension instead of loop with append\n+        self._block_ids = [block.block_id for block in self._blocks]\n \n     def append_token_ids(self, block_index: int, token_ids: List[int]) -> None:\n         block = self._blocks[block_index]\ndiff --git a/vllm/core/block/naive_block.py b/vllm/core/block/naive_block.py\nindex 0c1e88314..e6e29aa1d 100644\n--- a/vllm/core/block/naive_block.py\n+++ b/vllm/core/block/naive_block.py\n@@ -401,7 +401,8 @@ class NaiveBlock(Block):\n         Args:\n             token_ids (List[int]): The token IDs to be appended to the block.\n         \"\"\"\n-        if len(token_ids) == 0:\n+        # Optimize: Early return without len() call if token_ids is empty\n+        if not token_ids:\n             return\n \n         assert len(token_ids) <= self.num_empty_slots\ndiff --git a/vllm/core/block/prefix_caching_block.py b/vllm/core/block/prefix_caching_block.py\nindex f272e23ee..e16e46682 100644\n--- a/vllm/core/block/prefix_caching_block.py\n+++ b/vllm/core/block/prefix_caching_block.py\n@@ -25,12 +25,14 @@ class BlockTracker:\n     __slots__ = (\"active\", \"last_accessed\", \"computed\")\n \n     def reset(self):\n-        self.last_accessed: float = _DEFAULT_LAST_ACCESSED_TIME\n-        self.computed: bool = False\n+        self.last_accessed = _DEFAULT_LAST_ACCESSED_TIME\n+        self.computed = False\n \n     def __init__(self):\n-        self.active: bool = False\n-        self.reset()\n+        # Optimize: Initialize all attributes directly without calling reset()\n+        self.active = False\n+        self.last_accessed = _DEFAULT_LAST_ACCESSED_TIME\n+        self.computed = False\n \n     def enable(self):\n         assert not self.active\n@@ -146,19 +148,28 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n         assert device is None\n         assert_prefix_caching_block_or_none(prev_block)\n \n-        # First, try to create a block that points to cached data\n-        block = self._block_pool.init_block(prev_block=prev_block,\n-                                            token_ids=token_ids,\n-                                            block_size=self._block_size,\n-                                            physical_block_id=None)\n-        assert block.content_hash is not None\n-\n-        cached_block_id = self._cached_blocks.get(block.content_hash, None)\n-        if cached_block_id is not None:\n-            block.block_id = cached_block_id\n-            self._incr_refcount_cached_block(block)\n-            return block\n-        self._block_pool.free_block(block)\n+        # Optimize: Check if block size matches to compute hash directly\n+        if len(token_ids) == self._block_size:\n+            # Compute hash directly without creating a temporary block\n+            is_first_block = prev_block is None\n+            prev_block_hash = (None if is_first_block else\n+                             prev_block.content_hash)\n+\n+            # Only proceed if we can compute the hash (prev block must have hash if exists)\n+            if prev_block_hash is not None or is_first_block:\n+                content_hash = PrefixCachingBlock.hash_block_tokens(\n+                    is_first_block, prev_block_hash, token_ids)\n+\n+                cached_block_id = self._cached_blocks.get(content_hash, None)\n+                if cached_block_id is not None:\n+                    # Create block pointing to cached data\n+                    block = self._block_pool.init_block(prev_block=prev_block,\n+                                                        token_ids=token_ids,\n+                                                        block_size=self._block_size,\n+                                                        physical_block_id=None)\n+                    block.block_id = cached_block_id\n+                    self._incr_refcount_cached_block(block)\n+                    return block\n \n         # No cached block => Allocate a new block\n         block = self.allocate_mutable_block(prev_block)\n@@ -688,16 +699,11 @@ class PrefixCachingBlock(Block):\n         \"\"\"Incrementally computes the number of tokens that there is\n         till the current block (included)\n         \"\"\"\n-        res = 0\n-\n-        # Add all previous blocks\n-        if self._prev_block is not None:\n-            res += self._prev_block.num_tokens_total\n-\n-        # Add current block\n-        res += len(self.token_ids)\n-\n-        self._cached_num_tokens_total = res\n+        # Optimize: Calculate directly without intermediate variable\n+        self._cached_num_tokens_total = (\n+            (self._prev_block.num_tokens_total if self._prev_block is not None else 0) +\n+            len(self.token_ids)\n+        )\n \n     @property\n     def computed(self) -> bool:\n@@ -726,12 +732,10 @@ class PrefixCachingBlock(Block):\n         assert self.content_hash is None\n         assert not self.computed\n \n-        if len(token_ids) == 0:\n+        # Optimize: Early return without len() call if token_ids is empty\n+        if not token_ids:\n             return\n \n-        # Ensure there are input tokens\n-        assert token_ids, \"Got token_ids = {}\".format(token_ids)\n-\n         # Naive block handles CoW.\n         self._block.append_token_ids(token_ids)\n         self._update_num_tokens_total()\n@@ -828,7 +832,8 @@ class PrefixCachingBlock(Block):\n         - int: The computed hash value for the block.\n         \"\"\"\n         assert (prev_block_hash is None) == is_first_block\n-        return hash((is_first_block, prev_block_hash, *cur_block_token_ids))\n+        # Optimize: use tuple() instead of unpacking to avoid creating intermediate objects\n+        return hash((is_first_block, prev_block_hash, tuple(cur_block_token_ids)))\n \n \n class ComputedBlocksTracker:\n", "model_name_or_path": "gpt-5-2025-08-07"}
