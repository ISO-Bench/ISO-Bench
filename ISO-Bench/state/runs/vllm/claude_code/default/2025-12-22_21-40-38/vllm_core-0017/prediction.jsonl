{"instance_id": "vllm-project__vllm-5460070", "model_patch": "diff --git a/vllm/core/block/block_table.py b/vllm/core/block/block_table.py\nindex d705f3d91..aca6886ad 100644\n--- a/vllm/core/block/block_table.py\n+++ b/vllm/core/block/block_table.py\n@@ -208,7 +208,9 @@ class BlockTable:\n         occupied by each block. After freeing all the blocks, the `_blocks` list\n         is set to `None`.\n         \"\"\"\n-        assert self._is_allocated\n+        if not self._is_allocated:\n+            return\n+\n         for block in self._blocks:\n             self._allocator.free(block)\n         self._blocks = []\n@@ -269,11 +271,10 @@ class BlockTable:\n \n     def _get_all_token_ids(self) -> List[int]:\n         # NOTE: This function is O(seq_len); use sparingly.\n-        token_ids: List[int] = []\n-\n         if not self._is_allocated:\n-            return token_ids\n+            return []\n \n+        token_ids: List[int] = []\n         for block in self._blocks:\n             token_ids.extend(block.token_ids)\n \n@@ -322,6 +323,9 @@ class BlockTable:\n         than the block size, since the last allocated block may be partially\n         full.\n         \"\"\"\n+        if not token_ids:\n+            return []\n+\n         first_chunk_size = self._block_size - (self._num_full_slots %\n                                                self._block_size)\n         token_blocks = [token_ids[:first_chunk_size]] + chunk_list(\ndiff --git a/vllm/core/block/common.py b/vllm/core/block/common.py\nindex d2787d696..efb435d83 100644\n--- a/vllm/core/block/common.py\n+++ b/vllm/core/block/common.py\n@@ -37,28 +37,20 @@ class RefCounter(RefCounterProtocol):\n                                            for index in deduped}\n \n     def incr(self, block_id: BlockId) -> RefCount:\n-        assert block_id in self._refcounts\n-        pre_incr_refcount = self._refcounts[block_id]\n-\n-        assert pre_incr_refcount >= 0\n-\n-        post_incr_refcount = pre_incr_refcount + 1\n-        self._refcounts[block_id] = post_incr_refcount\n-        return post_incr_refcount\n+        refcount = self._refcounts[block_id]\n+        assert refcount >= 0\n+        refcount += 1\n+        self._refcounts[block_id] = refcount\n+        return refcount\n \n     def decr(self, block_id: BlockId) -> RefCount:\n-        assert block_id in self._refcounts\n         refcount = self._refcounts[block_id]\n-\n         assert refcount > 0\n         refcount -= 1\n-\n         self._refcounts[block_id] = refcount\n-\n         return refcount\n \n     def get(self, block_id: BlockId) -> RefCount:\n-        assert block_id in self._refcounts\n         return self._refcounts[block_id]\n \n     def as_readonly(self) -> \"ReadOnlyRefCounter\":\ndiff --git a/vllm/core/block/naive_block.py b/vllm/core/block/naive_block.py\nindex 50f27bab3..d8fd1ccbe 100644\n--- a/vllm/core/block/naive_block.py\n+++ b/vllm/core/block/naive_block.py\n@@ -142,9 +142,8 @@ class NaiveBlockAllocator(BlockAllocator):\n         if not self._free_block_indices:\n             raise BlockAllocator.NoFreeBlocksError()\n \n-        block_id = next(iter(self._free_block_indices))\n+        block_id = self._free_block_indices.pop()\n         self._refcounter.incr(block_id)\n-        self._free_block_indices.remove(block_id)\n         return block_id\n \n     def _free_block_id(self, block_id: BlockId) -> None:\n@@ -262,10 +261,16 @@ class NaiveBlockAllocator(BlockAllocator):\n         return num_touched_blocks\n \n     def swap_out(self, blocks: List[Block]) -> None:\n+        if not blocks:\n+            return\n+\n         for block in blocks:\n             self.free(block)\n \n     def swap_in(self, blocks: List[Block]) -> None:\n+        if not blocks:\n+            return\n+\n         for block in blocks:\n             if block.is_full:\n                 alloc = self.allocate_immutable(block.prev_block,\n@@ -321,6 +326,9 @@ class NaiveBlock(Block):\n         Args:\n             token_ids (List[int]): The token IDs to be appended to the block.\n         \"\"\"\n+        if not token_ids:\n+            return\n+\n         self._append_token_ids_no_cow(token_ids)\n \n         if self._block_id is not None:\ndiff --git a/vllm/core/block/prefix_caching_block.py b/vllm/core/block/prefix_caching_block.py\nindex 2df7d74e4..e0ac2b04f 100644\n--- a/vllm/core/block/prefix_caching_block.py\n+++ b/vllm/core/block/prefix_caching_block.py\n@@ -211,8 +211,9 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n         if refcount == 1:\n             # if block get referred, then it shall not be in evictor\n             # and put it into _blocks for tracking\n-            if block_id in self.evictor:\n-                self.evictor.remove(block_id)\n+            self.evictor.remove(block_id)\n+            self._blocks[block_id] = block\n+        elif block_id not in self._blocks:\n             self._blocks[block_id] = block\n \n     def free(self, block: Block) -> None:\n@@ -385,6 +386,9 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n         info in evictor's metadata.\n         \"\"\"\n \n+        if not block_ids:\n+            return\n+\n         for block_id in block_ids:\n             if block_id in self._blocks:\n                 self._blocks[block_id].last_accessed = now\n@@ -397,6 +401,9 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n     def mark_blocks_as_computed(self, block_ids: List[int]) -> None:\n         \"\"\"Mark blocks as computed, used in prefix caching.\"\"\"\n \n+        if not block_ids:\n+            return\n+\n         for block_id in block_ids:\n             if block_id in self._blocks:\n                 # only those full block is valid for prefix caching\n@@ -420,6 +427,9 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n         compyted would be taken consideration.\n         \"\"\"\n \n+        if not seq_block_ids:\n+            return []\n+\n         # NOTE We exclude the last block to avoid the case where the entire\n         # prompt is cached. This would cause erroneous behavior in model\n         # runner.\n@@ -432,7 +442,7 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n         # It returns a list of int although type annotation says list of string.\n         return commonprefix([\n             ids for ids in ids_list  # type: ignore\n-            if ids != []\n+            if ids\n         ])\n \n     def get_num_blocks_touched(self,\n@@ -444,13 +454,16 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n \n         Args:\n             blocks (List[Block]): The potential blocks to swap.\n-            num_lookahead_slots (int): number of lookahead slots (0 for \n+            num_lookahead_slots (int): number of lookahead slots (0 for\n                 swap out).\n-        \n+\n         Returns:\n             int: the number of blocks that will be touched by\n                 swapping in/out the given blocks and num_lookahead_slots.\n         \"\"\"\n+        if not blocks:\n+            return 0\n+\n         num_touched_blocks = 0\n         for block in blocks:\n             if not block.is_full:\n@@ -466,23 +479,29 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n         return num_touched_blocks\n \n     def swap_out(self, blocks: List[Block]) -> None:\n-        \"\"\"Execute the swap out actions. Basically just free the \n+        \"\"\"Execute the swap out actions. Basically just free the\n         given blocks.\n \n         Args:\n             blocks: List of blocks to be swapped out.\n         \"\"\"\n+        if not blocks:\n+            return\n+\n         for block in blocks:\n             self.free(block)\n \n     def swap_in(self, blocks: List[Block]) -> None:\n-        \"\"\"Execute the swap int actions. Change the block id from \n-        old allocator to current allocator for each block to finish \n-        the block table update. \n+        \"\"\"Execute the swap int actions. Change the block id from\n+        old allocator to current allocator for each block to finish\n+        the block table update.\n \n         Args:\n             blocks: List of blocks to be swapped in.\n         \"\"\"\n+        if not blocks:\n+            return\n+\n         for block in blocks:\n             if block.is_full:\n                 alloc = self.allocate_immutable(block.prev_block,\n@@ -569,7 +588,8 @@ class PrefixCachingBlock(Block):\n         Args:\n             token_ids (List[int]): The token IDs to be appended to the block.\n         \"\"\"\n-        assert token_ids\n+        if not token_ids:\n+            return\n \n         # naive block handles CoW.\n         self._block.append_token_ids(token_ids)\n@@ -685,7 +705,7 @@ class PrefixCachingBlock(Block):\n         - int: The computed hash value for the block.\n         \"\"\"\n         assert (prev_block_hash is None) == is_first_block\n-        return hash((is_first_block, prev_block_hash, *cur_block_token_ids))\n+        return hash((is_first_block, prev_block_hash, tuple(cur_block_token_ids)))\n \n \n def assert_prefix_caching_block_or_none(block: Optional[Block]):\n", "model_name_or_path": "gpt-5-2025-08-07"}
