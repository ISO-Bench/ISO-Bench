{"instance_id": "vllm-project__vllm-f508e03", "model_patch": "diff --git a/vllm/core/block/common.py b/vllm/core/block/common.py\nindex eb190adfb..52e73d5b5 100644\n--- a/vllm/core/block/common.py\n+++ b/vllm/core/block/common.py\n@@ -145,6 +145,8 @@ class CopyOnWriteTracker:\n                 block indices to destination block indices for the\n                 current copy-on-write operations.\n         \"\"\"\n+        if not self._copy_on_writes:\n+            return []\n         cows = self._copy_on_writes\n         self._copy_on_writes = []\n         return cows\n@@ -244,7 +246,7 @@ class BlockList:\n         self._blocks = blocks\n \n         # Cache block ids for fast query\n-        self._block_ids = []\n+        self._block_ids.clear()\n         for block in self._blocks:\n             self._add_block_id(block.block_id)\n \n@@ -273,8 +275,8 @@ class BlockList:\n         self._update_block_id(block_index, new_block.block_id)\n \n     def reset(self):\n-        self._blocks = []\n-        self._block_ids = []\n+        self._blocks.clear()\n+        self._block_ids.clear()\n \n     def list(self) -> List[Block]:\n         return self._blocks\ndiff --git a/vllm/core/block/prefix_caching_block.py b/vllm/core/block/prefix_caching_block.py\nindex a87e814cf..eba8c5eb2 100644\n--- a/vllm/core/block/prefix_caching_block.py\n+++ b/vllm/core/block/prefix_caching_block.py\n@@ -178,6 +178,8 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n             prev_block: Optional[Block],\n             block_token_ids: List[List[int]],\n             device: Optional[Device] = None) -> List[Block]:\n+        if not block_token_ids:\n+            return []\n         blocks = []\n         for token_ids in block_token_ids:\n             prev_block = self.allocate_immutable_block(prev_block=prev_block,\n@@ -366,18 +368,21 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n \n         forked_blocks: List[Block] = []\n         prev_block = None\n+        refcounter = self._refcounter\n+        block_pool = self._block_pool\n+        block_size = self._block_size\n         for block in source_blocks:\n             block_id = block.block_id\n             assert block_id is not None\n \n-            refcount = self._refcounter.incr(block_id)\n+            refcount = refcounter.incr(block_id)\n             assert refcount != 1, \"can't fork free'd block_id = {}\".format(\n                 block_id)\n \n-            forked_block = self._block_pool.init_block(\n+            forked_block = block_pool.init_block(\n                 prev_block=prev_block,\n                 token_ids=block.token_ids,\n-                block_size=self._block_size,\n+                block_size=block_size,\n                 physical_block_id=block_id)\n \n             forked_blocks.append(forked_block)\n@@ -505,20 +510,26 @@ class PrefixCachingBlockAllocator(BlockAllocator):\n         If the block is added into evictor, we need to update corresponding\n         info in evictor's metadata.\n         \"\"\"\n-\n+        if not block_ids:\n+            return\n+        block_tracker = self._block_tracker\n+        evictor = self.evictor\n         for block_id in block_ids:\n-            if self._block_tracker[block_id].active:\n-                self._block_tracker[block_id].last_accessed = now\n-            elif block_id in self.evictor:\n-                self.evictor.update(block_id, now)\n+            if block_tracker[block_id].active:\n+                block_tracker[block_id].last_accessed = now\n+            elif block_id in evictor:\n+                evictor.update(block_id, now)\n             else:\n                 raise ValueError(\n                     \"Mark block as accessed which is not belonged to GPU\")\n \n     def mark_blocks_as_computed(self, block_ids: List[int]) -> None:\n         # Mark all touched blocks as computed.\n+        if not self._touched_blocks:\n+            return\n+        block_tracker = self._block_tracker\n         for block_id in self._touched_blocks:\n-            self._block_tracker[block_id].computed = True\n+            block_tracker[block_id].computed = True\n         self._touched_blocks.clear()\n \n     def _track_block_id(self, block_id: Optional[BlockId],\ndiff --git a/vllm/core/block_manager_v1.py b/vllm/core/block_manager_v1.py\nindex 666723313..4a6543b62 100644\n--- a/vllm/core/block_manager_v1.py\n+++ b/vllm/core/block_manager_v1.py\n@@ -550,6 +550,8 @@ class BlockSpaceManagerV1(BlockSpaceManager):\n             dest_allocator: BlockAllocatorBase,\n             mapping: Dict[PhysicalTokenBlock,\n                           PhysicalTokenBlock]) -> BlockTable:\n+        if not block_table:\n+            return BlockTable()\n         new_block_table: BlockTable = BlockTable()\n \n         for from_block in block_table:\n@@ -678,8 +680,9 @@ class BlockSpaceManagerV1(BlockSpaceManager):\n             # Update the last accessed time of all the blocks accessed\n             # in this step.\n             block_table = self.block_tables[seq.seq_id]\n-            for block in block_table:\n-                block.last_accessed = access_time\n+            if block_table:\n+                for block in block_table:\n+                    block.last_accessed = access_time\n \n     def compute_full_blocks_in_seq(self, seq: Sequence):\n         if seq.seq_id not in self.block_tables:\n@@ -697,6 +700,8 @@ class BlockSpaceManagerV1(BlockSpaceManager):\n         if seq.seq_id not in self.block_tables:\n             return []\n         block_table = self.block_tables[seq.seq_id]\n+        if len(block_table) <= 1:\n+            return []\n         # NOTE We exclude the last block to avoid the case where the entire\n         # prompt is cached. This would cause erroneous behavior in model\n         # runner.\n", "model_name_or_path": "gpt-5-2025-08-07"}
