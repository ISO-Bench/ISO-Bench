diff --git a/vllm/v1/engine/async_llm.py b/vllm/v1/engine/async_llm.py
index e0169f1a4..fab8923af 100644
--- a/vllm/v1/engine/async_llm.py
+++ b/vllm/v1/engine/async_llm.py
@@ -269,15 +269,20 @@ class AsyncLLM(EngineClient):
             # The output_handler task pushes items into the queue.
             # This task pulls from the queue and yields to caller.
             finished = False
+            # Cache for performance
+            is_delta = sampling_params.output_kind == RequestOutputKind.DELTA
+            q_empty = q.empty
+            q_get_nowait = q.get_nowait
+
             while not finished:
                 # Note: drain queue without await if possible (avoids
                 # task switching under load which helps performance).
-                out = q.get_nowait() if not q.empty() else await q.get()
+                out = q_get_nowait() if not q_empty() else await q.get()
 
                 # Coalesce any additional queued outputs
-                while not q.empty():
-                    next_out = q.get_nowait()
-                    if sampling_params.output_kind == RequestOutputKind.DELTA:
+                while not q_empty():
+                    next_out = q_get_nowait()
+                    if is_delta:
                         out.add(next_out)
                     else:
                         out = next_out
@@ -298,43 +303,55 @@ class AsyncLLM(EngineClient):
         """Background loop: pulls from EngineCore and pushes to AsyncStreams."""
 
         try:
+            # Cache method references and constants for performance
+            get_output_async = self.engine_core.get_output_async
+            process_outputs = self.output_processor.process_outputs
+            abort_requests_async = self.engine_core.abort_requests_async
+            record_stats = self._record_stats
+            chunk_size = VLLM_V1_OUTPUT_PROC_CHUNK_SIZE
+            should_log_stats = self.log_stats
+
             while True:
                 # 1) Pull EngineCoreOutputs from the EngineCore.
-                outputs = await self.engine_core.get_output_async()
+                outputs = await get_output_async()
                 num_outputs = len(outputs.outputs)
 
                 iteration_stats = IterationStats() if (
-                    self.log_stats and num_outputs) else None
+                    should_log_stats and num_outputs) else None
 
                 # Split outputs into chunks of at most
                 # VLLM_V1_OUTPUT_PROC_CHUNK_SIZE, so that we don't block the
                 # event loop for too long.
-                if num_outputs <= VLLM_V1_OUTPUT_PROC_CHUNK_SIZE:
+                if num_outputs <= chunk_size:
                     slices = (outputs.outputs, )
                 else:
                     slices = np.array_split(
                         outputs.outputs,
-                        cdiv(num_outputs, VLLM_V1_OUTPUT_PROC_CHUNK_SIZE))
+                        cdiv(num_outputs, chunk_size))
+
+                outputs_timestamp = outputs.timestamp
+                num_slices = len(slices)
 
                 for i, outputs_slice in enumerate(slices):
                     # 2) Process EngineCoreOutputs.
-                    processed_outputs = self.output_processor.process_outputs(
-                        outputs_slice, outputs.timestamp, iteration_stats)
+                    processed_outputs = process_outputs(
+                        outputs_slice, outputs_timestamp, iteration_stats)
                     # NOTE: RequestOutputs are pushed to their queues.
                     assert not processed_outputs.request_outputs
 
                     # Allow other asyncio tasks to run between chunks
-                    if i + 1 < len(slices):
+                    if i + 1 < num_slices:
                         await asyncio.sleep(0)
 
                     # 3) Abort any reqs that finished due to stop strings.
-                    await self.engine_core.abort_requests_async(
-                        processed_outputs.reqs_to_abort)
+                    if processed_outputs.reqs_to_abort:
+                        await abort_requests_async(
+                            processed_outputs.reqs_to_abort)
 
                 # 4) Logging.
                 # TODO(rob): make into a coroutine and launch it in
                 # background thread once Prometheus overhead is non-trivial.
-                self._record_stats(
+                record_stats(
                     scheduler_stats=outputs.scheduler_stats,
                     iteration_stats=iteration_stats,
                 )
diff --git a/vllm/v1/engine/output_processor.py b/vllm/v1/engine/output_processor.py
index 12df34177..d40413939 100644
--- a/vllm/v1/engine/output_processor.py
+++ b/vllm/v1/engine/output_processor.py
@@ -112,11 +112,14 @@ class RequestState:
         completion_output = self._new_completion_output(
             new_token_ids, finish_reason, stop_reason)
 
+        # Cache attribute lookups
         request_id = self.request_id
-        if self.parent_req is None:
+        parent_req = self.parent_req
+
+        if parent_req is None:
             outputs = [completion_output]
         else:
-            request_id, outputs, finished = self.parent_req.get_outputs(
+            request_id, outputs, finished = parent_req.get_outputs(
                 request_id, completion_output)
             if not outputs:
                 return None
@@ -200,16 +203,21 @@ class OutputProcessor:
         request_ids: Iterable[str],
     ) -> list[str]:
         request_ids_to_abort = []
+        # Cache dictionary references
+        request_states = self.request_states
+        parent_requests = self.parent_requests
+        lora_states = self.lora_states
+
         for request_id in request_ids:
-            req_state = self.request_states.pop(request_id, None)
+            req_state = request_states.pop(request_id, None)
             if req_state is not None:
-                self.lora_states.abort_request(req_state)
+                lora_states.abort_request(req_state)
                 request_ids_to_abort.append(request_id)
             else:
-                parent = self.parent_requests.pop(request_id, None)
+                parent = parent_requests.pop(request_id, None)
                 if parent and parent.child_requests:
-                    self.abort_requests(parent.child_requests)
-                    request_ids_to_abort.extend(parent.child_requests)
+                    child_aborts = self.abort_requests(parent.child_requests)
+                    request_ids_to_abort.extend(child_aborts)
         return request_ids_to_abort
 
     def add_request(
@@ -246,38 +254,46 @@ class OutputProcessor:
         1) Compute stats for logging
         2) Detokenize
         3) Create and handle RequestOutput objects:
-            * If there is a queue (for usage with AsyncLLM), 
+            * If there is a queue (for usage with AsyncLLM),
               put the RequestOutput objects into the queue for
               handling by the per-request generate() tasks.
 
-            * If there is no queue (for usage with LLMEngine), 
+            * If there is no queue (for usage with LLMEngine),
               return a list of RequestOutput objects.
 
         ****************** NOTE FOR DEVELOPERS ******************
 
         vLLM V1 minimizes the number of python loops over the full
-        batch to ensure system overheads are minimized. This is the 
+        batch to ensure system overheads are minimized. This is the
         only function that should loop over EngineCoreOutputs.
 
         If you need to touch every element of the batch, do it from
         within the loop below.
-        
+
         **********************************************************
         """
 
         request_outputs: list[RequestOutput] = []
         reqs_to_abort: list[str] = []
+
+        # Cache frequently accessed attributes to reduce lookups
+        request_states_dict = self.request_states
+        parent_requests_dict = self.parent_requests
+        update_stats_fn = self._update_stats_from_output
+        update_finished_stats_fn = self._update_stats_from_finished
+        finish_reason_stop = FinishReason.STOP
+
         for engine_core_output in engine_core_outputs:
             req_id = engine_core_output.request_id
-            req_state = self.request_states.get(req_id)
+            req_state = request_states_dict.get(req_id)
             if req_state is None:
                 # Ignore output for already-aborted request.
                 continue
 
             # 1) Compute stats for this iteration.
-            self._update_stats_from_output(req_state, engine_core_output,
-                                           engine_core_timestamp,
-                                           iteration_stats)
+            update_stats_fn(req_state, engine_core_output,
+                            engine_core_timestamp,
+                            iteration_stats)
 
             new_token_ids = engine_core_output.new_token_ids
             finish_reason = engine_core_output.finish_reason
@@ -287,39 +303,41 @@ class OutputProcessor:
 
             # 2) Detokenize the token ids into text and perform stop checks.
             stop_string = req_state.detokenizer.update(
-                new_token_ids, finish_reason == FinishReason.STOP)
-            if stop_string and finish_reason != FinishReason.STOP:
-                finish_reason = FinishReason.STOP
+                new_token_ids, finish_reason == finish_reason_stop)
+            if stop_string and finish_reason != finish_reason_stop:
+                finish_reason = finish_reason_stop
                 stop_reason = stop_string
 
             # 3) Compute sample and prompt logprobs for request, if required.
             req_state.logprobs_processor.update_from_output(engine_core_output)
 
             # 4) Create and handle RequestOutput objects.
-            if request_output := req_state.make_request_output(
-                    new_token_ids, finish_reason, stop_reason):
-                if req_state.queue is not None:
+            request_output = req_state.make_request_output(
+                new_token_ids, finish_reason, stop_reason)
+            if request_output is not None:
+                queue = req_state.queue
+                if queue is not None:
                     # AsyncLLM: put into queue for handling by generate().
-                    req_state.queue.put_nowait(request_output)
+                    queue.put_nowait(request_output)
                 else:
                     # LLMEngine: return list of RequestOutputs.
                     request_outputs.append(request_output)
 
             # Free completed requests.
             if finish_reason is not None:
-                self.request_states.pop(req_id)
+                request_states_dict.pop(req_id)
                 # Remove parent request if applicable.
                 parent_req = req_state.parent_req
                 if parent_req and not parent_req.child_requests:
-                    self.parent_requests.pop(parent_req.request_id, None)
+                    parent_requests_dict.pop(parent_req.request_id, None)
                 if not engine_core_output.finished:
                     # If req not finished in EngineCore, but Detokenizer
                     # detected stop string, abort needed in EngineCore.
                     reqs_to_abort.append(req_id)
 
                 # Track per-request stats
-                self._update_stats_from_finished(req_state, finish_reason,
-                                                 iteration_stats)
+                update_finished_stats_fn(req_state, finish_reason,
+                                         iteration_stats)
 
         self.lora_states.update_iteration_stats(iteration_stats)
 
