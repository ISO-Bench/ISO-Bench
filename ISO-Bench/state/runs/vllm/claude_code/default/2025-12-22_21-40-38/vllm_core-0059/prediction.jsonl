{"instance_id": "vllm-project__vllm-3d92516", "model_patch": "diff --git a/vllm/core/scheduler.py b/vllm/core/scheduler.py\nindex 419855062..abd518515 100644\n--- a/vllm/core/scheduler.py\n+++ b/vllm/core/scheduler.py\n@@ -337,8 +337,7 @@ class Scheduler:\n                     self.free_seq(seq)\n \n     def has_unfinished_seqs(self) -> bool:\n-        return len(self.waiting) != 0 or len(self.running) != 0 or len(\n-            self.swapped) != 0\n+        return bool(self.waiting or self.running or self.swapped)\n \n     def get_num_unfinished_seq_groups(self) -> int:\n         return len(self.waiting) + len(self.running) + len(self.swapped)\n@@ -594,7 +593,7 @@ class Scheduler:\n         seq_groups: List[SequenceGroup] = []\n         # We don't sort waiting queue because we assume it is sorted.\n         # Copy the queue so that the input queue is not modified.\n-        waiting_queue = deque([s for s in waiting_queue])\n+        waiting_queue = waiting_queue.copy()\n \n         leftover_waiting_sequences: Deque[SequenceGroup] = deque()\n         while self._passed_delay(time.time()) and waiting_queue:\n@@ -691,12 +690,12 @@ class Scheduler:\n         )\n         # Make sure we include num running seqs before scheduling prefill,\n         # so that we don't schedule beyond max_num_seqs for prefill.\n+        curr_loras = set() if self.lora_enabled else None\n         for seq_group in self.running:\n             budget.add_num_seqs(seq_group.request_id,\n                                 seq_group.get_max_num_running_seqs())\n-        curr_loras = set(\n-            seq_group.lora_int_id\n-            for seq_group in self.running) if self.lora_enabled else None\n+            if curr_loras is not None:\n+                curr_loras.add(seq_group.lora_int_id)\n \n         remaining_waiting, prefills = (self.waiting,\n                                        SchedulerPrefillOutputs.create_empty())\n@@ -899,15 +898,15 @@ class Scheduler:\n             # seq_id -> physical block numbers\n             block_tables: Dict[int, List[int]] = {}\n \n-            for seq in seq_group.get_seqs(status=SequenceStatus.RUNNING):\n+            running_seqs = seq_group.get_seqs(status=SequenceStatus.RUNNING)\n+            for seq in running_seqs:\n                 seq_id = seq.seq_id\n                 seq_data[seq_id] = seq.data\n                 block_tables[seq_id] = self.block_manager.get_block_table(seq)\n                 self.block_manager.access_all_blocks_in_seq(seq, now)\n \n             common_computed_block_nums = (\n-                self.block_manager.get_common_computed_block_ids(\n-                    seq_group.get_seqs(status=SequenceStatus.RUNNING)))\n+                self.block_manager.get_common_computed_block_ids(running_seqs))\n \n             # It assumes the scheduled_seq_groups is ordered by\n             # prefill < decoding.\n@@ -979,9 +978,7 @@ class Scheduler:\n             cows = self.block_manager.append_slots(seq, num_lookahead_slots)\n \n             for src, dests in cows.items():\n-                if src not in blocks_to_copy:\n-                    blocks_to_copy[src] = []\n-                blocks_to_copy[src].extend(dests)\n+                blocks_to_copy.setdefault(src, []).extend(dests)\n \n     def _preempt(\n         self,\n@@ -1064,7 +1061,7 @@ class Scheduler:\n         # Delay scheduling prompts to let waiting queue fill up\n         if self.scheduler_config.delay_factor > 0 and self.waiting:\n             earliest_arrival_time = min(\n-                [e.metrics.arrival_time for e in self.waiting])\n+                e.metrics.arrival_time for e in self.waiting)\n             passed_delay = (\n                 (now - earliest_arrival_time) >\n                 (self.scheduler_config.delay_factor * self.last_prompt_latency)\n", "model_name_or_path": "gpt-5-2025-08-07"}
