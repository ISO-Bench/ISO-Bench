diff --git a/vllm/core/block_manager_v1.py b/vllm/core/block_manager_v1.py
index b2aaeb33c..9d52c2751 100644
--- a/vllm/core/block_manager_v1.py
+++ b/vllm/core/block_manager_v1.py
@@ -266,7 +266,8 @@ class BlockSpaceManagerV1(BlockSpaceManager):
     def allocate(self, seq_group: SequenceGroup) -> None:
         # NOTE: Here we assume that all sequences in the group have the same
         # prompt.
-        seq = seq_group.get_seqs(status=SequenceStatus.WAITING)[0]
+        waiting_seqs = seq_group.get_seqs(status=SequenceStatus.WAITING)
+        seq = waiting_seqs[0]
 
         # Allocate new physical token blocks that will store the prompt tokens.
         num_prompt_blocks = len(seq.logical_token_blocks)
@@ -289,7 +290,7 @@ class BlockSpaceManagerV1(BlockSpaceManager):
             block_table.append(block)
 
         # Assign the block table for each sequence.
-        for seq in seq_group.get_seqs(status=SequenceStatus.WAITING):
+        for seq in waiting_seqs:
             self.block_tables[seq.seq_id] = block_table.copy()
 
     def can_append_slots(self,
@@ -425,8 +426,14 @@ class BlockSpaceManagerV1(BlockSpaceManager):
         # When forking, we must make sure that each block's `ref_count`
         # is only incremented by one, so we deduplicate them by wrapping
         # them in a set.
-        for block in set(src_block_table):
-            block.ref_count += 1
+        if self.block_sliding_window is not None:
+            # Only need deduplication with sliding window
+            for block in set(src_block_table):
+                block.ref_count += 1
+        else:
+            # No duplicates without sliding window - avoid set creation
+            for block in src_block_table:
+                block.ref_count += 1
 
     def _get_physical_blocks(
             self, seq_group: SequenceGroup) -> List[PhysicalTokenBlock]:
@@ -461,6 +468,7 @@ class BlockSpaceManagerV1(BlockSpaceManager):
 
         # CPU block -> GPU block.
         mapping: Dict[PhysicalTokenBlock, PhysicalTokenBlock] = {}
+        block_number_mapping: Dict[int, int] = {}
         for seq in seq_group.get_seqs(status=SequenceStatus.SWAPPED):
             new_block_table: BlockTable = []
             block_table = self.block_tables[seq.seq_id]
@@ -473,15 +481,12 @@ class BlockSpaceManagerV1(BlockSpaceManager):
                     gpu_block = self.gpu_allocator.allocate(
                         cpu_block.block_hash, cpu_block.num_hashed_tokens)
                     mapping[cpu_block] = gpu_block
+                    block_number_mapping[cpu_block.block_number] = gpu_block.block_number
                 new_block_table.append(gpu_block)
                 # Free the CPU block swapped in to GPU.
                 self.cpu_allocator.free(cpu_block)
             self.block_tables[seq.seq_id] = new_block_table
 
-        block_number_mapping = {
-            cpu_block.block_number: gpu_block.block_number
-            for cpu_block, gpu_block in mapping.items()
-        }
         return block_number_mapping
 
     def can_swap_out(self, seq_group: SequenceGroup) -> bool:
@@ -491,6 +496,7 @@ class BlockSpaceManagerV1(BlockSpaceManager):
     def swap_out(self, seq_group: SequenceGroup) -> Dict[int, int]:
         # GPU block -> CPU block.
         mapping: Dict[PhysicalTokenBlock, PhysicalTokenBlock] = {}
+        block_number_mapping: Dict[int, int] = {}
         for seq in seq_group.get_seqs(status=SequenceStatus.RUNNING):
             new_block_table: BlockTable = []
             block_table = self.block_tables[seq.seq_id]
@@ -503,15 +509,12 @@ class BlockSpaceManagerV1(BlockSpaceManager):
                     cpu_block = self.cpu_allocator.allocate(
                         gpu_block.block_hash, gpu_block.num_hashed_tokens)
                     mapping[gpu_block] = cpu_block
+                    block_number_mapping[gpu_block.block_number] = cpu_block.block_number
                 new_block_table.append(cpu_block)
                 # Free the GPU block swapped out to CPU.
                 self.gpu_allocator.free(gpu_block)
             self.block_tables[seq.seq_id] = new_block_table
 
-        block_number_mapping = {
-            gpu_block.block_number: cpu_block.block_number
-            for gpu_block, cpu_block in mapping.items()
-        }
         return block_number_mapping
 
     def _free_block_table(self, block_table: BlockTable) -> None:
@@ -520,14 +523,21 @@ class BlockSpaceManagerV1(BlockSpaceManager):
         # the block table, we must make sure to not free blocks more
         # than once. If no sliding window is used, there is no block
         # reuse in the block table, so we must free all blocks.
-        blocks_to_free = (block_table[-self.block_sliding_window:]
-                          if self.block_sliding_window is not None else
-                          block_table)
-        for block in set(blocks_to_free):
-            if block.device == Device.GPU:
-                self.gpu_allocator.free(block)
-            else:
-                self.cpu_allocator.free(block)
+        if self.block_sliding_window is not None:
+            blocks_to_free = block_table[-self.block_sliding_window:]
+            # Need deduplication with sliding window
+            for block in set(blocks_to_free):
+                if block.device == Device.GPU:
+                    self.gpu_allocator.free(block)
+                else:
+                    self.cpu_allocator.free(block)
+        else:
+            # No duplicates without sliding window - avoid set creation
+            for block in block_table:
+                if block.device == Device.GPU:
+                    self.gpu_allocator.free(block)
+                else:
+                    self.cpu_allocator.free(block)
 
     def free(self, seq: Sequence) -> None:
         if seq.seq_id not in self.block_tables:
@@ -571,7 +581,8 @@ class BlockSpaceManagerV1(BlockSpaceManager):
         block_table = self.block_tables[seq.seq_id]
         if max_full_block == -1:
             return
-        for i in reversed(range(max_full_block)):
+        # Iterate backwards without creating reversed iterator
+        for i in range(max_full_block - 1, -1, -1):
             if block_table[i].computed:
                 break
             block_table[i].computed = True
