{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-ca4f1ab", "model_patch": "diff --git a/python/sglang/srt/managers/router/radix_cache.py b/python/sglang/srt/managers/router/radix_cache.py\nindex 6ee6703..d03e0b5 100644\n--- a/python/sglang/srt/managers/router/radix_cache.py\n+++ b/python/sglang/srt/managers/router/radix_cache.py\n@@ -1,6 +1,5 @@\n import heapq\n import time\n-from collections import defaultdict\n from dataclasses import dataclass\n from typing import Tuple\n \n@@ -8,24 +7,27 @@ import torch\n \n \n class TreeNode:\n+    __slots__ = ('children', 'parent', 'value', 'ref_counter', 'last_access_time', 'key')\n+    \n     def __init__(self):\n-        self.children = defaultdict(TreeNode)\n+        self.children = {}\n         self.parent = None\n         self.value = None\n         self.ref_counter = 0\n-        self.last_access_time = time.time()\n+        self.last_access_time = 0\n+        self.key = None\n \n     def __lt__(self, other):\n         return self.last_access_time < other.last_access_time\n \n \n def match(key, seq):\n-    i = 0\n-    for k, w in zip(key, seq):\n-        if k != w:\n-            break\n-        i += 1\n-    return i\n+    # Optimized prefix matching\n+    min_len = min(len(key), len(seq))\n+    for i in range(min_len):\n+        if key[i] != seq[i]:\n+            return i\n+    return min_len\n \n \n class RadixCache:\n@@ -40,6 +42,7 @@ class RadixCache:\n         self.root_node.value = []\n         self.root_node.ref_counter = 1\n         self.evictable_size_ = 0\n+        self._access_counter = 0\n \n     def match_prefix(self, key):\n         if self.disable:\n@@ -49,7 +52,8 @@ class RadixCache:\n         last_node = [self.root_node]\n         self._match_prefix_helper(self.root_node, key, value, last_node)\n         if value:\n-            value = torch.concat(value)\n+            # Use torch.cat instead of torch.concat for better performance\n+            value = torch.cat(value, dim=0) if len(value) > 1 else value[0]\n         return value, last_node[0]\n \n     def insert(self, key, value=None):\n@@ -57,7 +61,7 @@ class RadixCache:\n             return len(key)\n \n         if value is None:\n-            value = [x for x in key]\n+            value = list(key)\n         return self._insert_helper(self.root_node, key, value)\n \n     def pretty_print(self):\n@@ -75,7 +79,7 @@ class RadixCache:\n         heapq.heapify(leaves)\n \n         num_evicted = 0\n-        while num_evicted < num_tokens and len(leaves):\n+        while num_evicted < num_tokens and leaves:\n             x = heapq.heappop(leaves)\n \n             if x == self.root_node:\n@@ -86,7 +90,7 @@ class RadixCache:\n             num_evicted += evict_callback(x.value)\n             self._delete_leaf(x)\n \n-            if len(x.parent.children) == 0:\n+            if not x.parent.children:\n                 heapq.heappush(leaves, x.parent)\n \n     def inc_ref_counter(self, node):\n@@ -114,12 +118,14 @@ class RadixCache:\n \n     ##### Internal Helper Functions #####\n     def _match_prefix_helper(self, node, key, value, last_node):\n-        node.last_access_time = time.time()\n+        self._access_counter += 1\n+        node.last_access_time = self._access_counter\n \n         for c_key, child in node.children.items():\n             prefix_len = match(c_key, key)\n-            if prefix_len != 0:\n-                if prefix_len < len(c_key):\n+            if prefix_len:\n+                c_key_len = len(c_key)\n+                if prefix_len < c_key_len:\n                     new_node = self._split_node(c_key, child, prefix_len)\n                     value.append(new_node.value)\n                     last_node[0] = new_node\n@@ -132,40 +138,49 @@ class RadixCache:\n     def _split_node(self, key, child, split_len):\n         # new_node -> child\n         new_node = TreeNode()\n-        new_node.children = {key[split_len:]: child}\n+        new_key = key[:split_len]\n+        child_key = key[split_len:]\n+        new_node.children = {child_key: child}\n         new_node.parent = child.parent\n         new_node.ref_counter = child.ref_counter\n         new_node.value = child.value[:split_len]\n+        new_node.key = new_key\n         child.parent = new_node\n         child.value = child.value[split_len:]\n-        new_node.parent.children[key[:split_len]] = new_node\n+        child.key = child_key\n+        new_node.parent.children[new_key] = new_node\n         del new_node.parent.children[key]\n         return new_node\n \n     def _insert_helper(self, node, key, value):\n-        node.last_access_time = time.time()\n+        self._access_counter += 1\n+        node.last_access_time = self._access_counter\n \n         for c_key, child in node.children.items():\n             prefix_len = match(c_key, key)\n-\n-            if prefix_len == len(c_key):\n-                if prefix_len == len(key):\n-                    return prefix_len\n-                else:\n-                    key = key[prefix_len:]\n-                    value = value[prefix_len:]\n-                    return prefix_len + self._insert_helper(child, key, value)\n-\n+            \n             if prefix_len:\n-                new_node = self._split_node(c_key, child, prefix_len)\n-                return prefix_len + self._insert_helper(\n-                    new_node, key[prefix_len:], value[prefix_len:]\n-                )\n+                c_key_len = len(c_key)\n+                key_len = len(key)\n+                \n+                if prefix_len == c_key_len:\n+                    if prefix_len == key_len:\n+                        return prefix_len\n+                    else:\n+                        key = key[prefix_len:]\n+                        value = value[prefix_len:]\n+                        return prefix_len + self._insert_helper(child, key, value)\n+                else:\n+                    new_node = self._split_node(c_key, child, prefix_len)\n+                    return prefix_len + self._insert_helper(\n+                        new_node, key[prefix_len:], value[prefix_len:]\n+                    )\n \n         if len(key):\n             new_node = TreeNode()\n             new_node.parent = node\n             new_node.value = value\n+            new_node.key = key\n             node.children[key] = new_node\n             self.evictable_size_ += len(value)\n         return 0\n@@ -176,11 +191,10 @@ class RadixCache:\n             self._print_helper(child, indent=indent + 2)\n \n     def _delete_leaf(self, node):\n-        for k, v in node.parent.children.items():\n-            if v == node:\n-                break\n-        del node.parent.children[k]\n-        self.evictable_size_ -= len(k)\n+        # Optimized: use stored key instead of iterating\n+        if node.key is not None:\n+            del node.parent.children[node.key]\n+            self.evictable_size_ -= len(node.key)\n \n     def _total_size_helper(self, node):\n         x = len(node.value)\n@@ -189,16 +203,17 @@ class RadixCache:\n         return x\n \n     def _collect_leaves(self):\n+        # Optimized: iterative DFS instead of recursive\n         ret_list = []\n-\n-        def dfs_(cur_node):\n-            if len(cur_node.children) == 0:\n+        stack = [self.root_node]\n+        \n+        while stack:\n+            cur_node = stack.pop()\n+            if not cur_node.children:\n                 ret_list.append(cur_node)\n-\n-            for x in cur_node.children.values():\n-                dfs_(x)\n-\n-        dfs_(self.root_node)\n+            else:\n+                stack.extend(cur_node.children.values())\n+        \n         return ret_list\n \n \n", "model_name_or_path": "gpt-5-2025-08-07"}
