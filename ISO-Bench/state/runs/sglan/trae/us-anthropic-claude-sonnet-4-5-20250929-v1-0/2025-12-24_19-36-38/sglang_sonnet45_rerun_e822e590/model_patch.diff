diff --git a/python/sglang/srt/managers/router/radix_cache.py b/python/sglang/srt/managers/router/radix_cache.py
index 6ee6703..d03e0b5 100644
--- a/python/sglang/srt/managers/router/radix_cache.py
+++ b/python/sglang/srt/managers/router/radix_cache.py
@@ -1,6 +1,5 @@
 import heapq
 import time
-from collections import defaultdict
 from dataclasses import dataclass
 from typing import Tuple
 
@@ -8,24 +7,27 @@ import torch
 
 
 class TreeNode:
+    __slots__ = ('children', 'parent', 'value', 'ref_counter', 'last_access_time', 'key')
+    
     def __init__(self):
-        self.children = defaultdict(TreeNode)
+        self.children = {}
         self.parent = None
         self.value = None
         self.ref_counter = 0
-        self.last_access_time = time.time()
+        self.last_access_time = 0
+        self.key = None
 
     def __lt__(self, other):
         return self.last_access_time < other.last_access_time
 
 
 def match(key, seq):
-    i = 0
-    for k, w in zip(key, seq):
-        if k != w:
-            break
-        i += 1
-    return i
+    # Optimized prefix matching
+    min_len = min(len(key), len(seq))
+    for i in range(min_len):
+        if key[i] != seq[i]:
+            return i
+    return min_len
 
 
 class RadixCache:
@@ -40,6 +42,7 @@ class RadixCache:
         self.root_node.value = []
         self.root_node.ref_counter = 1
         self.evictable_size_ = 0
+        self._access_counter = 0
 
     def match_prefix(self, key):
         if self.disable:
@@ -49,7 +52,8 @@ class RadixCache:
         last_node = [self.root_node]
         self._match_prefix_helper(self.root_node, key, value, last_node)
         if value:
-            value = torch.concat(value)
+            # Use torch.cat instead of torch.concat for better performance
+            value = torch.cat(value, dim=0) if len(value) > 1 else value[0]
         return value, last_node[0]
 
     def insert(self, key, value=None):
@@ -57,7 +61,7 @@ class RadixCache:
             return len(key)
 
         if value is None:
-            value = [x for x in key]
+            value = list(key)
         return self._insert_helper(self.root_node, key, value)
 
     def pretty_print(self):
@@ -75,7 +79,7 @@ class RadixCache:
         heapq.heapify(leaves)
 
         num_evicted = 0
-        while num_evicted < num_tokens and len(leaves):
+        while num_evicted < num_tokens and leaves:
             x = heapq.heappop(leaves)
 
             if x == self.root_node:
@@ -86,7 +90,7 @@ class RadixCache:
             num_evicted += evict_callback(x.value)
             self._delete_leaf(x)
 
-            if len(x.parent.children) == 0:
+            if not x.parent.children:
                 heapq.heappush(leaves, x.parent)
 
     def inc_ref_counter(self, node):
@@ -114,12 +118,14 @@ class RadixCache:
 
     ##### Internal Helper Functions #####
     def _match_prefix_helper(self, node, key, value, last_node):
-        node.last_access_time = time.time()
+        self._access_counter += 1
+        node.last_access_time = self._access_counter
 
         for c_key, child in node.children.items():
             prefix_len = match(c_key, key)
-            if prefix_len != 0:
-                if prefix_len < len(c_key):
+            if prefix_len:
+                c_key_len = len(c_key)
+                if prefix_len < c_key_len:
                     new_node = self._split_node(c_key, child, prefix_len)
                     value.append(new_node.value)
                     last_node[0] = new_node
@@ -132,40 +138,49 @@ class RadixCache:
     def _split_node(self, key, child, split_len):
         # new_node -> child
         new_node = TreeNode()
-        new_node.children = {key[split_len:]: child}
+        new_key = key[:split_len]
+        child_key = key[split_len:]
+        new_node.children = {child_key: child}
         new_node.parent = child.parent
         new_node.ref_counter = child.ref_counter
         new_node.value = child.value[:split_len]
+        new_node.key = new_key
         child.parent = new_node
         child.value = child.value[split_len:]
-        new_node.parent.children[key[:split_len]] = new_node
+        child.key = child_key
+        new_node.parent.children[new_key] = new_node
         del new_node.parent.children[key]
         return new_node
 
     def _insert_helper(self, node, key, value):
-        node.last_access_time = time.time()
+        self._access_counter += 1
+        node.last_access_time = self._access_counter
 
         for c_key, child in node.children.items():
             prefix_len = match(c_key, key)
-
-            if prefix_len == len(c_key):
-                if prefix_len == len(key):
-                    return prefix_len
-                else:
-                    key = key[prefix_len:]
-                    value = value[prefix_len:]
-                    return prefix_len + self._insert_helper(child, key, value)
-
+            
             if prefix_len:
-                new_node = self._split_node(c_key, child, prefix_len)
-                return prefix_len + self._insert_helper(
-                    new_node, key[prefix_len:], value[prefix_len:]
-                )
+                c_key_len = len(c_key)
+                key_len = len(key)
+                
+                if prefix_len == c_key_len:
+                    if prefix_len == key_len:
+                        return prefix_len
+                    else:
+                        key = key[prefix_len:]
+                        value = value[prefix_len:]
+                        return prefix_len + self._insert_helper(child, key, value)
+                else:
+                    new_node = self._split_node(c_key, child, prefix_len)
+                    return prefix_len + self._insert_helper(
+                        new_node, key[prefix_len:], value[prefix_len:]
+                    )
 
         if len(key):
             new_node = TreeNode()
             new_node.parent = node
             new_node.value = value
+            new_node.key = key
             node.children[key] = new_node
             self.evictable_size_ += len(value)
         return 0
@@ -176,11 +191,10 @@ class RadixCache:
             self._print_helper(child, indent=indent + 2)
 
     def _delete_leaf(self, node):
-        for k, v in node.parent.children.items():
-            if v == node:
-                break
-        del node.parent.children[k]
-        self.evictable_size_ -= len(k)
+        # Optimized: use stored key instead of iterating
+        if node.key is not None:
+            del node.parent.children[node.key]
+            self.evictable_size_ -= len(node.key)
 
     def _total_size_helper(self, node):
         x = len(node.value)
@@ -189,16 +203,17 @@ class RadixCache:
         return x
 
     def _collect_leaves(self):
+        # Optimized: iterative DFS instead of recursive
         ret_list = []
-
-        def dfs_(cur_node):
-            if len(cur_node.children) == 0:
+        stack = [self.root_node]
+        
+        while stack:
+            cur_node = stack.pop()
+            if not cur_node.children:
                 ret_list.append(cur_node)
-
-            for x in cur_node.children.values():
-                dfs_(x)
-
-        dfs_(self.root_node)
+            else:
+                stack.extend(cur_node.children.values())
+        
         return ret_list
 
 
