diff --git a/python/sglang/srt/mem_cache/radix_cache.py b/python/sglang/srt/mem_cache/radix_cache.py
index 68bcb5b..0ca6f43 100644
--- a/python/sglang/srt/mem_cache/radix_cache.py
+++ b/python/sglang/srt/mem_cache/radix_cache.py
@@ -21,7 +21,6 @@ The radix tree data structure for managing the KV cache.
 
 import heapq
 import time
-from collections import defaultdict
 from typing import TYPE_CHECKING, Callable, List, Optional
 
 import torch
@@ -35,7 +34,7 @@ if TYPE_CHECKING:
 
 class TreeNode:
     def __init__(self):
-        self.children = defaultdict(TreeNode)
+        self.children = {}
         self.parent = None
         self.key = None
         self.value = None
@@ -47,12 +46,12 @@ class TreeNode:
 
 
 def _key_match(key0: List, key1: List):
-    i = 0
-    for k0, k1 in zip(key0, key1):
-        if k0 != k1:
-            break
-        i += 1
-    return i
+    # Optimize by using min length and early exit
+    min_len = min(len(key0), len(key1))
+    for i in range(min_len):
+        if key0[i] != key1[i]:
+            return i
+    return min_len
 
 
 class RadixCache(BasePrefixCache):
@@ -65,6 +64,8 @@ class RadixCache(BasePrefixCache):
         self.req_to_token_pool = req_to_token_pool
         self.token_to_kv_pool = token_to_kv_pool
         self.disable = disable
+        # Cache empty tensor to avoid repeated allocations
+        self._empty_tensor = torch.tensor([], dtype=torch.int32)
         self.reset()
 
     ##### Public API #####
@@ -86,7 +87,7 @@ class RadixCache(BasePrefixCache):
         if value:
             value = torch.concat(value)
         else:
-            value = torch.tensor([], dtype=torch.int32)
+            value = self._empty_tensor
         return value, last_node[0]
 
     def insert(self, key: List, value=None):
@@ -177,10 +178,11 @@ class RadixCache(BasePrefixCache):
         heapq.heapify(leaves)
 
         num_evicted = 0
-        while num_evicted < num_tokens and len(leaves):
+        root = self.root_node
+        while num_evicted < num_tokens and leaves:
             x = heapq.heappop(leaves)
 
-            if x == self.root_node:
+            if x == root:
                 break
             if x.lock_ref > 0:
                 continue
@@ -189,7 +191,7 @@ class RadixCache(BasePrefixCache):
             num_evicted += len(x.value)
             self._delete_leaf(x)
 
-            if len(x.parent.children) == 0:
+            if not x.parent.children:
                 heapq.heappush(leaves, x.parent)
 
     def inc_lock_ref(self, node: TreeNode):
@@ -197,10 +199,12 @@ class RadixCache(BasePrefixCache):
             return 0
 
         delta = 0
-        while node != self.root_node:
+        root = self.root_node
+        while node != root:
             if node.lock_ref == 0:
-                self.evictable_size_ -= len(node.value)
-                delta -= len(node.value)
+                value_len = len(node.value)
+                self.evictable_size_ -= value_len
+                delta -= value_len
             node.lock_ref += 1
             node = node.parent
         return delta
@@ -210,10 +214,12 @@ class RadixCache(BasePrefixCache):
             return 0
 
         delta = 0
-        while node != self.root_node:
+        root = self.root_node
+        while node != root:
             if node.lock_ref == 1:
-                self.evictable_size_ += len(node.value)
-                delta += len(node.value)
+                value_len = len(node.value)
+                self.evictable_size_ += value_len
+                delta += value_len
             node.lock_ref -= 1
             node = node.parent
         return delta
@@ -227,11 +233,12 @@ class RadixCache(BasePrefixCache):
         self, node: TreeNode, key: List, value, last_node: TreeNode
     ):
         node.last_access_time = time.time()
-        if len(key) == 0:
+        if not key:
             return
 
-        if key[0] in node.children.keys():
-            child = node.children[key[0]]
+        first_key = key[0]
+        child = node.children.get(first_key)
+        if child is not None:
             prefix_len = _key_match(child.key, key)
             if prefix_len < len(child.key):
                 new_node = self._split_node(child.key, child, prefix_len)
@@ -258,11 +265,12 @@ class RadixCache(BasePrefixCache):
 
     def _insert_helper(self, node: TreeNode, key: List, value):
         node.last_access_time = time.time()
-        if len(key) == 0:
+        if not key:
             return 0
 
-        if key[0] in node.children.keys():
-            child = node.children[key[0]]
+        first_key = key[0]
+        child = node.children.get(first_key)
+        if child is not None:
             prefix_len = _key_match(child.key, key)
 
             if prefix_len == len(child.key):
@@ -278,12 +286,12 @@ class RadixCache(BasePrefixCache):
                 new_node, key[prefix_len:], value[prefix_len:]
             )
 
-        if len(key):
+        if key:
             new_node = TreeNode()
             new_node.parent = node
             new_node.key = key
             new_node.value = value
-            node.children[key[0]] = new_node
+            node.children[first_key] = new_node
             self.evictable_size_ += len(value)
         return 0
 
@@ -311,7 +319,7 @@ class RadixCache(BasePrefixCache):
 
         while stack:
             cur_node = stack.pop()
-            if len(cur_node.children) == 0:
+            if not cur_node.children:
                 ret_list.append(cur_node)
             else:
                 stack.extend(cur_node.children.values())
