{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-5ab20cc", "model_patch": "diff --git a/python/sglang/srt/mem_cache/radix_cache.py b/python/sglang/srt/mem_cache/radix_cache.py\nindex 68bcb5b..0ca6f43 100644\n--- a/python/sglang/srt/mem_cache/radix_cache.py\n+++ b/python/sglang/srt/mem_cache/radix_cache.py\n@@ -21,7 +21,6 @@ The radix tree data structure for managing the KV cache.\n \n import heapq\n import time\n-from collections import defaultdict\n from typing import TYPE_CHECKING, Callable, List, Optional\n \n import torch\n@@ -35,7 +34,7 @@ if TYPE_CHECKING:\n \n class TreeNode:\n     def __init__(self):\n-        self.children = defaultdict(TreeNode)\n+        self.children = {}\n         self.parent = None\n         self.key = None\n         self.value = None\n@@ -47,12 +46,12 @@ class TreeNode:\n \n \n def _key_match(key0: List, key1: List):\n-    i = 0\n-    for k0, k1 in zip(key0, key1):\n-        if k0 != k1:\n-            break\n-        i += 1\n-    return i\n+    # Optimize by using min length and early exit\n+    min_len = min(len(key0), len(key1))\n+    for i in range(min_len):\n+        if key0[i] != key1[i]:\n+            return i\n+    return min_len\n \n \n class RadixCache(BasePrefixCache):\n@@ -65,6 +64,8 @@ class RadixCache(BasePrefixCache):\n         self.req_to_token_pool = req_to_token_pool\n         self.token_to_kv_pool = token_to_kv_pool\n         self.disable = disable\n+        # Cache empty tensor to avoid repeated allocations\n+        self._empty_tensor = torch.tensor([], dtype=torch.int32)\n         self.reset()\n \n     ##### Public API #####\n@@ -86,7 +87,7 @@ class RadixCache(BasePrefixCache):\n         if value:\n             value = torch.concat(value)\n         else:\n-            value = torch.tensor([], dtype=torch.int32)\n+            value = self._empty_tensor\n         return value, last_node[0]\n \n     def insert(self, key: List, value=None):\n@@ -177,10 +178,11 @@ class RadixCache(BasePrefixCache):\n         heapq.heapify(leaves)\n \n         num_evicted = 0\n-        while num_evicted < num_tokens and len(leaves):\n+        root = self.root_node\n+        while num_evicted < num_tokens and leaves:\n             x = heapq.heappop(leaves)\n \n-            if x == self.root_node:\n+            if x == root:\n                 break\n             if x.lock_ref > 0:\n                 continue\n@@ -189,7 +191,7 @@ class RadixCache(BasePrefixCache):\n             num_evicted += len(x.value)\n             self._delete_leaf(x)\n \n-            if len(x.parent.children) == 0:\n+            if not x.parent.children:\n                 heapq.heappush(leaves, x.parent)\n \n     def inc_lock_ref(self, node: TreeNode):\n@@ -197,10 +199,12 @@ class RadixCache(BasePrefixCache):\n             return 0\n \n         delta = 0\n-        while node != self.root_node:\n+        root = self.root_node\n+        while node != root:\n             if node.lock_ref == 0:\n-                self.evictable_size_ -= len(node.value)\n-                delta -= len(node.value)\n+                value_len = len(node.value)\n+                self.evictable_size_ -= value_len\n+                delta -= value_len\n             node.lock_ref += 1\n             node = node.parent\n         return delta\n@@ -210,10 +214,12 @@ class RadixCache(BasePrefixCache):\n             return 0\n \n         delta = 0\n-        while node != self.root_node:\n+        root = self.root_node\n+        while node != root:\n             if node.lock_ref == 1:\n-                self.evictable_size_ += len(node.value)\n-                delta += len(node.value)\n+                value_len = len(node.value)\n+                self.evictable_size_ += value_len\n+                delta += value_len\n             node.lock_ref -= 1\n             node = node.parent\n         return delta\n@@ -227,11 +233,12 @@ class RadixCache(BasePrefixCache):\n         self, node: TreeNode, key: List, value, last_node: TreeNode\n     ):\n         node.last_access_time = time.time()\n-        if len(key) == 0:\n+        if not key:\n             return\n \n-        if key[0] in node.children.keys():\n-            child = node.children[key[0]]\n+        first_key = key[0]\n+        child = node.children.get(first_key)\n+        if child is not None:\n             prefix_len = _key_match(child.key, key)\n             if prefix_len < len(child.key):\n                 new_node = self._split_node(child.key, child, prefix_len)\n@@ -258,11 +265,12 @@ class RadixCache(BasePrefixCache):\n \n     def _insert_helper(self, node: TreeNode, key: List, value):\n         node.last_access_time = time.time()\n-        if len(key) == 0:\n+        if not key:\n             return 0\n \n-        if key[0] in node.children.keys():\n-            child = node.children[key[0]]\n+        first_key = key[0]\n+        child = node.children.get(first_key)\n+        if child is not None:\n             prefix_len = _key_match(child.key, key)\n \n             if prefix_len == len(child.key):\n@@ -278,12 +286,12 @@ class RadixCache(BasePrefixCache):\n                 new_node, key[prefix_len:], value[prefix_len:]\n             )\n \n-        if len(key):\n+        if key:\n             new_node = TreeNode()\n             new_node.parent = node\n             new_node.key = key\n             new_node.value = value\n-            node.children[key[0]] = new_node\n+            node.children[first_key] = new_node\n             self.evictable_size_ += len(value)\n         return 0\n \n@@ -311,7 +319,7 @@ class RadixCache(BasePrefixCache):\n \n         while stack:\n             cur_node = stack.pop()\n-            if len(cur_node.children) == 0:\n+            if not cur_node.children:\n                 ret_list.append(cur_node)\n             else:\n                 stack.extend(cur_node.children.values())\n", "model_name_or_path": "gpt-5-2025-08-07"}
