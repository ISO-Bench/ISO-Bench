{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-ff91474", "model_patch": "diff --git a/sgl-kernel/csrc/cpu/norm.cpp b/sgl-kernel/csrc/cpu/norm.cpp\nindex 391a0d4e5..678a30805 100644\n--- a/sgl-kernel/csrc/cpu/norm.cpp\n+++ b/sgl-kernel/csrc/cpu/norm.cpp\n@@ -152,7 +152,7 @@ void fused_add_rmsnorm_kernel_impl(\n #pragma GCC unroll 4\n       for (; d < hidden_size; ++d) {\n         float x_val = buffer_ptr[d] * rsqrt_var * static_cast<float>(weight[d]);\n-        input_ptr[d] = x_val;\n+        input_ptr[d] = static_cast<scalar_t>(x_val);\n       }\n     }\n   });\ndiff --git a/sgl-kernel/csrc/cpu/rope.cpp b/sgl-kernel/csrc/cpu/rope.cpp\nindex 64bc297fe..b9128c345 100644\n--- a/sgl-kernel/csrc/cpu/rope.cpp\n+++ b/sgl-kernel/csrc/cpu/rope.cpp\n@@ -22,44 +22,41 @@ void rope_kernel_impl(\n     int64_t k_pe_stride_s,\n     int64_t q_pe_stride_n,\n     int64_t out_stride_qn) {\n-  int64_t COFF = HR / 2;\n+  const int64_t COFF = HR / 2;\n   at::parallel_for(0, seq_len * num_head, GRAIN_SIZE / rotary_dim, [&](int64_t begin, int64_t end) {\n     int64_t seq{0}, head_id{0};\n     data_index_init(begin, seq, seq_len, head_id, num_head);\n     for (int64_t i = begin; i < end; ++i) {\n-      int64_t in_offset_q = seq * q_pe_stride_s + head_id * q_pe_stride_n;\n-      int64_t out_offset_q = seq * out_stride_qs + head_id * out_stride_qn;\n-      int64_t out_offset_k = seq * out_stride_ks;\n-      int64_t p = 0;\n-      scalar_t* sin_start = nullptr;\n-      scalar_t* cos_start = nullptr;\n+      const int64_t in_offset_q = seq * q_pe_stride_s + head_id * q_pe_stride_n;\n+      const int64_t out_offset_q = seq * out_stride_qs + head_id * out_stride_qn;\n+      const int64_t out_offset_k = seq * out_stride_ks;\n+      const int64_t k_pe_offset = seq * k_pe_stride_s;\n+\n       // step 0) get the rotary position embedding for the current position\n-      p = t_pos[seq];\n-      sin_start = t_emb_pos + p * HR + COFF;\n-      cos_start = t_emb_pos + p * HR;\n-      // step 1) apply_rotary_pos_emb for the rotary_dim elements in every\n-      // head of query/key\n-      for (int64_t h = 0; h < rotary_dim; h += 2) {\n-        scalar_t cos = cos_start[h >> 1];\n-        scalar_t sin = sin_start[h >> 1];\n-        scalar_t in1 = q_pe[in_offset_q + h];\n-        scalar_t in2 = q_pe[in_offset_q + h + 1];\n-        scalar_t out1 = in1 * cos - in2 * sin;\n-        scalar_t out2 = in2 * cos + in1 * sin;\n-        q_pe_out[out_offset_q + h] = out1;\n-        q_pe_out[out_offset_q + h + 1] = out2;\n-      }\n-      for (int64_t h = 0; h < HK; h += 2) {\n-        scalar_t cos = cos_start[h >> 1];\n-        scalar_t sin = sin_start[h >> 1];\n-        int64_t k_pe_offset = seq * k_pe_stride_s;\n-        scalar_t in1_k = k_pe[k_pe_offset + h];\n-        scalar_t in2_k = k_pe[k_pe_offset + h + 1];\n-        scalar_t out1_k = in1_k * cos - in2_k * sin;\n-        scalar_t out2_k = in2_k * cos + in1_k * sin;\n-        k_pe_out[out_offset_k + h] = out1_k;\n-        k_pe_out[out_offset_k + h + 1] = out2_k;\n+      const int64_t p = t_pos[seq];\n+      scalar_t* __restrict__ sin_start = t_emb_pos + p * HR + COFF;\n+      scalar_t* __restrict__ cos_start = t_emb_pos + p * HR;\n+\n+      // step 1) apply_rotary_pos_emb for the rotary_dim elements in every head\n+#pragma GCC unroll 4\n+      for (int64_t pair = 0; pair < rotary_dim / 2; ++pair) {\n+        const scalar_t cos = cos_start[pair];\n+        const scalar_t sin = sin_start[pair];\n+\n+        const int64_t h = pair * 2;\n+        // query\n+        const scalar_t in1 = q_pe[in_offset_q + h];\n+        const scalar_t in2 = q_pe[in_offset_q + h + 1];\n+        q_pe_out[out_offset_q + h] = in1 * cos - in2 * sin;\n+        q_pe_out[out_offset_q + h + 1] = in2 * cos + in1 * sin;\n+\n+        // key\n+        const scalar_t in1_k = k_pe[k_pe_offset + h];\n+        const scalar_t in2_k = k_pe[k_pe_offset + h + 1];\n+        k_pe_out[out_offset_k + h] = in1_k * cos - in2_k * sin;\n+        k_pe_out[out_offset_k + h + 1] = in2_k * cos + in1_k * sin;\n       }\n+\n       // move to the next index\n       data_index_step(seq, seq_len, head_id, num_head);\n     }\ndiff --git a/sgl-kernel/csrc/cpu/topk.cpp b/sgl-kernel/csrc/cpu/topk.cpp\nindex 6a6b64d12..83788b0a7 100644\n--- a/sgl-kernel/csrc/cpu/topk.cpp\n+++ b/sgl-kernel/csrc/cpu/topk.cpp\n@@ -88,12 +88,13 @@ void grouped_topk_kernel_impl(\n       // do softmax to get scores\n       softmax<scalar_t, NUM_EXPERTS>(scores, gating_output + i * NUM_EXPERTS);\n \n-      // find max score per group\n+      // find max score per group (vectorized reduce)\n+      using Vec = at::vec::Vectorized<float>;\n       for (int64_t g = 0; g < num_groups; ++g) {\n-        float gmax = -std::numeric_limits<float>::infinity();\n-        for (int64_t e = 0; e < num_experts_per_group; ++e) {\n-          gmax = std::max(gmax, scores[g * num_experts_per_group + e]);\n-        }\n+        float gmax = at::vec::reduce_all<float>(\n+            [](Vec& x, Vec& y) { return at::vec::maximum(x, y); },\n+            scores + g * num_experts_per_group,\n+            num_experts_per_group);\n         queue[g] = {gmax, g};\n       }\n \n@@ -111,11 +112,10 @@ void grouped_topk_kernel_impl(\n         }\n       }\n \n-      // find global topk\n-      std::partial_sort(\n-          queue2.begin(), queue2.begin() + topk, queue2.end(), [](const elem_t& x, const elem_t& y) -> bool {\n-            return x.first > y.first;\n-          });\n+      // find global topk using nth_element + sort for better scalability\n+      auto comp = [](const elem_t& x, const elem_t& y) -> bool { return x.first > y.first; };\n+      std::nth_element(queue2.begin(), queue2.begin() + topk, queue2.end(), comp);\n+      std::sort(queue2.begin(), queue2.begin() + topk, comp);\n \n       for (int64_t j = 0; j < topk; ++j) {\n         topk_weights[i * topk + j] = queue2[j].first;\n", "model_name_or_path": "gpt-5-2025-08-07"}
