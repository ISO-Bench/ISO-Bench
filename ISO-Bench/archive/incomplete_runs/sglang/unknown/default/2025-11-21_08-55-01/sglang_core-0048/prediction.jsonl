{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-8c7279c", "model_patch": "diff --git a/python/sglang/srt/two_batch_overlap.py b/python/sglang/srt/two_batch_overlap.py\nindex 0fbc3c8e7..d02f29383 100644\n--- a/python/sglang/srt/two_batch_overlap.py\n+++ b/python/sglang/srt/two_batch_overlap.py\n@@ -39,14 +39,33 @@ def compute_split_seq_index(\n \n \n def _split_array_by_half_sum(arr: Sequence[int]) -> int:\n+    \"\"\"Return the split index that best balances the two halves.\n+\n+    This improves over the simple half-sum threshold by picking the index\n+    with the minimal absolute difference between left and right sums and\n+    early-exiting once the difference starts to increase. This helps imbalanced\n+    extend cases achieve better overlap scheduling.\n+    \"\"\"\n     overall_sum = sum(arr)\n-    accumulator, split_index = 0, 0\n-    for value in arr[:-1]:\n-        accumulator += value\n-        split_index += 1\n-        if accumulator >= overall_sum // 2:\n-            break\n-    return split_index\n+    half = overall_sum / 2\n+    left_sum = 0\n+\n+    # Walk until crossing half, then choose the closer side with a constant-time check\n+    for i in range(1, len(arr)):\n+        left_sum += arr[i - 1]\n+        if left_sum >= half:\n+            if i == 1:\n+                # Do not split at 0; keep at least one element on the left\n+                return 1\n+            prev_left = left_sum - arr[i - 1]\n+            # Compare the two candidates: split before or after current element\n+            diff_prev = abs(prev_left - (overall_sum - prev_left))\n+            diff_curr = abs(left_sum - (overall_sum - left_sum))\n+            return i if diff_curr <= diff_prev else (i - 1)\n+\n+    # If never crossed half (should not happen unless last element is 0),\n+    # fall back to putting everything except the last on the left.\n+    return max(1, len(arr) - 1)\n \n \n def compute_split_token_index(\n@@ -267,12 +286,19 @@ class TboForwardBatchPreparer:\n \n         # TODO improve, e.g. unify w/ `init_raw`\n         if global_server_args_dict[\"moe_dense_tp_size\"] == 1:\n-            sum_len = end_token_index - start_token_index\n-            gathered_buffer = torch.zeros(\n-                (sum_len, batch.gathered_buffer.shape[1]),\n-                dtype=batch.gathered_buffer.dtype,\n-                device=batch.gathered_buffer.device,\n-            )\n+            # Reuse parent's gathered_buffer slice when available to avoid\n+            # additional allocations and zero-initialization.\n+            if getattr(batch, \"gathered_buffer\", None) is not None:\n+                gathered_buffer = batch.gathered_buffer[\n+                    start_token_index:end_token_index\n+                ]\n+            else:\n+                sum_len = end_token_index - start_token_index\n+                gathered_buffer = torch.empty(\n+                    (sum_len, batch.gathered_buffer.shape[1]),\n+                    dtype=batch.gathered_buffer.dtype,\n+                    device=batch.gathered_buffer.device,\n+                )\n         else:\n             gathered_buffer = None\n \n@@ -423,6 +449,11 @@ def _model_forward_tbo_merge_outputs(output_a, output_b):\n         assert (value_a is None) == (value_b is None)\n         if value_a is None:\n             return None\n+        # Fast paths for imbalanced/empty cases to avoid unnecessary concat\n+        if value_a.numel() == 0:\n+            return value_b\n+        if value_b.numel() == 0:\n+            return value_a\n         return torch.concat([value_a, value_b], dim=0)\n \n     return _handle_key(\"hidden_states\"), _handle_key(\"residual\")\ndiff --git a/test/srt/test_two_batch_overlap.py b/test/srt/test_two_batch_overlap.py\nindex 89e793ca6..1758fd8eb 100644\n--- a/test/srt/test_two_batch_overlap.py\n+++ b/test/srt/test_two_batch_overlap.py\n@@ -68,5 +68,50 @@ class TestTwoBatchOverlap(unittest.TestCase):\n         self.assertGreater(metrics[\"score\"], 0.5)\n \n \n+class TestTwoBatchOverlapUnit(unittest.TestCase):\n+    \"\"\"Lightweight unit tests to verify split and merge helpers.\n+\n+    These tests avoid launching servers and only touch pure-Python helpers.\n+    If the module cannot be imported due to optional dependencies, they are skipped.\n+    \"\"\"\n+\n+    @classmethod\n+    def setUpClass(cls):\n+        try:\n+            from sglang.srt.two_batch_overlap import (\n+                _split_array_by_half_sum,\n+                _model_forward_tbo_merge_outputs,\n+            )\n+            import torch\n+        except Exception:\n+            cls._available = False\n+            return\n+        cls._available = True\n+        cls.split_fn = _split_array_by_half_sum\n+        cls.merge_fn = _model_forward_tbo_merge_outputs\n+        cls.torch = torch\n+\n+    def setUp(self):\n+        if not getattr(self, \"_available\", False):\n+            self.skipTest(\"Optional dependencies not available for unit helpers\")\n+\n+    def test_split_balanced(self):\n+        arr = [1] * 10\n+        self.assertEqual(self.split_fn(arr), 5)\n+\n+    def test_split_imbalanced(self):\n+        arr = [1, 1, 100, 1, 1]\n+        # Best balance is after second element (index 2)\n+        self.assertEqual(self.split_fn(arr), 2)\n+\n+    def test_merge_imbalanced_fastpath(self):\n+        torch = self.torch\n+        A = {\"hidden_states\": torch.empty((0, 8)), \"residual\": torch.empty((0, 8))}\n+        B = {\"hidden_states\": torch.ones((4, 8)), \"residual\": torch.ones((4, 8))}\n+        hs, res = self.merge_fn(A, B)\n+        self.assertEqual(hs.shape[0], 4)\n+        self.assertEqual(res.shape[0], 4)\n+\n+\n if __name__ == \"__main__\":\n     unittest.main()\n", "model_name_or_path": "gpt-5-2025-08-07"}
