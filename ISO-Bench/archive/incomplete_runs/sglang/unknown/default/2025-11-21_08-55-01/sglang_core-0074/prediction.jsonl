{"instance_id": "/home/ubuntu/OmniPerf-Bench/sglan__repo-ca4f1ab", "model_patch": "diff --git a/python/sglang/srt/managers/router/radix_cache.py b/python/sglang/srt/managers/router/radix_cache.py\nindex 6ee670309..e96c834c8 100644\n--- a/python/sglang/srt/managers/router/radix_cache.py\n+++ b/python/sglang/srt/managers/router/radix_cache.py\n@@ -1,6 +1,5 @@\n import heapq\n import time\n-from collections import defaultdict\n from dataclasses import dataclass\n from typing import Tuple\n \n@@ -8,22 +7,38 @@ import torch\n \n \n class TreeNode:\n+    __slots__ = (\n+        \"children\",\n+        \"parent\",\n+        \"key\",\n+        \"value\",\n+        \"ref_counter\",\n+        \"last_access_time\",\n+    )\n+\n     def __init__(self):\n-        self.children = defaultdict(TreeNode)\n+        # dict is slightly lighter/faster than defaultdict here as we\n+        # always create children explicitly.\n+        self.children = {}\n         self.parent = None\n+        # Key of this node in parent's children dict (cached for O(1) delete)\n+        self.key = None\n         self.value = None\n         self.ref_counter = 0\n-        self.last_access_time = time.time()\n+        # Monotonic clock is faster and not subject to system time changes\n+        self.last_access_time = time.monotonic()\n \n     def __lt__(self, other):\n         return self.last_access_time < other.last_access_time\n \n \n def match(key, seq):\n+    # Fast prefix match without iterator/tuple overhead\n+    n = len(key)\n+    m = len(seq)\n+    lim = n if n < m else m\n     i = 0\n-    for k, w in zip(key, seq):\n-        if k != w:\n-            break\n+    while i < lim and key[i] == seq[i]:\n         i += 1\n     return i\n \n@@ -37,6 +52,8 @@ class RadixCache:\n \n     def reset(self):\n         self.root_node = TreeNode()\n+        # Root has no key in parent\n+        self.root_node.key = []\n         self.root_node.value = []\n         self.root_node.ref_counter = 1\n         self.evictable_size_ = 0\n@@ -49,7 +66,11 @@ class RadixCache:\n         last_node = [self.root_node]\n         self._match_prefix_helper(self.root_node, key, value, last_node)\n         if value:\n-            value = torch.concat(value)\n+            # Avoid an extra allocation when only one segment matched\n+            if len(value) == 1:\n+                value = value[0]\n+            else:\n+                value = torch.concat(value)\n         return value, last_node[0]\n \n     def insert(self, key, value=None):\n@@ -114,9 +135,13 @@ class RadixCache:\n \n     ##### Internal Helper Functions #####\n     def _match_prefix_helper(self, node, key, value, last_node):\n-        node.last_access_time = time.time()\n+        node.last_access_time = time.monotonic()\n \n+        # Scan children to find the matching prefix\n         for c_key, child in node.children.items():\n+            # Quick reject by first element to avoid full match cost\n+            if len(c_key) == 0 or len(key) == 0 or c_key[0] != key[0]:\n+                continue\n             prefix_len = match(c_key, key)\n             if prefix_len != 0:\n                 if prefix_len < len(c_key):\n@@ -130,22 +155,37 @@ class RadixCache:\n                 break\n \n     def _split_node(self, key, child, split_len):\n-        # new_node -> child\n+        # Split child into new_node (prefix) -> child (suffix)\n         new_node = TreeNode()\n-        new_node.children = {key[split_len:]: child}\n+        prefix_key = key[:split_len]\n+        suffix_key = key[split_len:]\n+\n+        new_node.children = {suffix_key: child}\n         new_node.parent = child.parent\n         new_node.ref_counter = child.ref_counter\n         new_node.value = child.value[:split_len]\n+        new_node.key = prefix_key\n+\n+        # Update child\n         child.parent = new_node\n         child.value = child.value[split_len:]\n-        new_node.parent.children[key[:split_len]] = new_node\n-        del new_node.parent.children[key]\n+        child.key = suffix_key\n+\n+        # Update parent's mapping\n+        parent = new_node.parent\n+        parent.children[prefix_key] = new_node\n+        # Remove old edge\n+        del parent.children[key]\n         return new_node\n \n     def _insert_helper(self, node, key, value):\n-        node.last_access_time = time.time()\n+        node.last_access_time = time.monotonic()\n \n+        # Find a child to descend/split\n         for c_key, child in node.children.items():\n+            # Quick reject by first element\n+            if len(c_key) == 0 or len(key) == 0 or c_key[0] != key[0]:\n+                continue\n             prefix_len = match(c_key, key)\n \n             if prefix_len == len(c_key):\n@@ -166,6 +206,7 @@ class RadixCache:\n             new_node = TreeNode()\n             new_node.parent = node\n             new_node.value = value\n+            new_node.key = key\n             node.children[key] = new_node\n             self.evictable_size_ += len(value)\n         return 0\n@@ -176,11 +217,15 @@ class RadixCache:\n             self._print_helper(child, indent=indent + 2)\n \n     def _delete_leaf(self, node):\n-        for k, v in node.parent.children.items():\n-            if v == node:\n-                break\n-        del node.parent.children[k]\n-        self.evictable_size_ -= len(k)\n+        # O(1) delete using cached key\n+        parent = node.parent\n+        if parent is None:\n+            return\n+        k = node.key\n+        if k in parent.children:\n+            del parent.children[k]\n+        # Adjust evictable size by the actual value length\n+        self.evictable_size_ -= len(node.value)\n \n     def _total_size_helper(self, node):\n         x = len(node.value)\n", "model_name_or_path": "gpt-5-2025-08-07"}
