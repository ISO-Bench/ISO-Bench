{"instance_id": "/home/raven/coding-mess/kernel-corp/OmniPerf-Bench/vllm__repo-bd43973", "model_patch": "diff --git a/model_patch.diff b/model_patch.diff\nnew file mode 100644\nindex 000000000..e69de29bb\ndiff --git a/vllm/core/evictor.py b/vllm/core/evictor.py\nindex ed7e06cab..03c000339 100644\n--- a/vllm/core/evictor.py\n+++ b/vllm/core/evictor.py\n@@ -1,6 +1,9 @@\n import enum\n+import heapq\n+from heapq import heapify, heappush\n+\n from abc import ABC, abstractmethod\n-from typing import OrderedDict, Tuple\n+from typing import Dict, Tuple\n \n \n class EvictionPolicy(enum.Enum):\n@@ -60,6 +63,8 @@ class BlockMetaData:\n     blocks with the same content hash, but their physical id is unique.\n     \"\"\"\n \n+    __slots__ = (\"content_hash\", \"num_hashed_tokens\", \"last_accessed\")\n+\n     def __init__(self, content_hash: int, num_hashed_tokens: int,\n                  last_accessed: float):\n         self.content_hash = content_hash\n@@ -75,49 +80,104 @@ class LRUEvictor(Evictor):\n     highest num_hashed_tokens value, then one will be chose arbitrarily\n     \"\"\"\n \n+    # Limit how large the priority queue can grow compared to live entries\n+    CLEANUP_THRESHOLD = 1\n+    # Rebuild heap after too many stale pops to keep eviction fast\n+    STALE_POP_THRESHOLD = 32\n+    # Absolute slack for heap growth before rebuild\n+    CLEANUP_DELTA_ABS = 4096\n+\n+\n+\n     def __init__(self):\n-        self.free_table: OrderedDict[int, BlockMetaData] = OrderedDict()\n+        self.free_table: Dict[int, BlockMetaData] = {}\n+        # heap of tuples: (last_accessed, -num_hashed_tokens, block_id)\n+        self.priority_queue = []\n+        # counter for consecutive stale pops\n+        self._stale_pops = 0\n+\n \n     def __contains__(self, block_id: int) -> bool:\n         return block_id in self.free_table\n \n+    def _maybe_cleanup(self):\n+        # Rebuild the heap if it has grown disproportionately due to lazy updates\n+        live = len(self.free_table)\n+        if live == 0:\n+            self.priority_queue.clear()\n+            self._stale_pops = 0\n+            return\n+        pq_len = len(self.priority_queue)\n+        if pq_len <= live:\n+            return\n+        delta = pq_len - live\n+        # Allow up to 25% slack or an absolute slack before rebuilding\n+        if delta <= max(live >> 2, self.CLEANUP_DELTA_ABS):\n+            return\n+        self._rebuild_heap()\n+    def _rebuild_heap(self):\n+        # Build heap from current live entries\n+        self.priority_queue = [\n+            (meta.last_accessed, -meta.num_hashed_tokens, bid)\n+            for bid, meta in self.free_table.items()\n+        ]\n+        heapify(self.priority_queue)\n+        self._stale_pops = 0\n+\n     def evict(self) -> Tuple[int, int]:\n-        if len(self.free_table) == 0:\n+        free = self.free_table\n+        if not free:\n             raise ValueError(\"No usable cache memory left\")\n \n-        evicted_block, evicted_block_id = None, None\n-        # The blocks with the lowest timestamps should be placed consecutively\n-        # at the start of OrderedDict. Loop through all these blocks to\n-        # find the one with maximum number of hashed tokens.\n-        for _id, block in self.free_table.items():\n-            if evicted_block is None:\n-                evicted_block, evicted_block_id = block, _id\n+        heap = self.priority_queue\n+        heappop = heapq.heappop\n+        maybe_cleanup = self._maybe_cleanup\n+        stale_pops = 0\n+\n+        # Pop until we find a live, up-to-date entry\n+        while True:\n+            try:\n+                last_accessed, neg_tokens, bid = heappop(heap)\n+            except IndexError:\n+                self._rebuild_heap()\n+                heap = self.priority_queue\n+                stale_pops = 0\n+                last_accessed, neg_tokens, bid = heappop(heap)\n+            meta = free.get(bid)\n+            if meta is None or meta.last_accessed != last_accessed or meta.num_hashed_tokens != -neg_tokens:\n+                stale_pops += 1\n+                if stale_pops >= max(64, len(heap) >> 3):\n+                    self._rebuild_heap()\n+                    heap = self.priority_queue\n+                    stale_pops = 0\n                 continue\n-            if evicted_block.last_accessed < block.last_accessed:\n-                break\n-            if evicted_block.num_hashed_tokens < block.num_hashed_tokens:\n-                evicted_block, evicted_block_id = block, _id\n-\n-        assert evicted_block is not None\n-        assert evicted_block_id is not None\n-        self.free_table.pop(evicted_block_id)\n-\n-        return evicted_block_id, evicted_block.content_hash\n+            evicted = free.pop(bid)\n+            maybe_cleanup()\n+            return bid, evicted.content_hash\n \n     def add(self, block_id: int, content_hash: int, num_hashed_tokens: int,\n             last_accessed: float):\n-        self.free_table[block_id] = BlockMetaData(content_hash,\n-                                                  num_hashed_tokens,\n-                                                  last_accessed)\n+        meta = BlockMetaData(content_hash, num_hashed_tokens, last_accessed)\n+        self.free_table[block_id] = meta\n+        heappush(self.priority_queue,\n+                       (last_accessed, -num_hashed_tokens, block_id))\n+        self._maybe_cleanup()\n \n     def update(self, block_id: int, last_accessed: float):\n-        self.free_table[block_id].last_accessed = last_accessed\n+        meta = self.free_table[block_id]\n+        if meta.last_accessed == last_accessed:\n+            return\n+        meta.last_accessed = last_accessed\n+        # push a new entry; stale one will be lazily ignored\n+        heappush(self.priority_queue,\n+                       (last_accessed, -meta.num_hashed_tokens, block_id))\n \n     def remove(self, block_id: int):\n-        if block_id not in self.free_table:\n+        # Lazy removal: delete from map; heap entry becomes stale\n+        if self.free_table.pop(block_id, None) is None:\n             raise ValueError(\n                 \"Attempting to remove block that's not in the evictor\")\n-        self.free_table.pop(block_id)\n+        self._maybe_cleanup()\n \n     @property\n     def num_blocks(self) -> int:\n", "model_name_or_path": "gpt-5-2025-08-07"}
